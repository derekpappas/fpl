{\rtf1\ansi \deff4\deflang1033{\fonttbl{\f0\froman\fcharset0\fprq2 Tms Rmn;}{\f1\froman\fcharset2\fprq2 Symbol;}{\f2\fswiss\fcharset0\fprq2 Helv;}{\f3\fmodern\fcharset0\fprq1 Courier{\*\falt Courier};}
{\f4\froman\fcharset0\fprq2 Times New Roman;}{\f5\fswiss\fcharset0\fprq2 Arial;}{\f6\froman\fcharset0\fprq2 MS Serif;}{\f7\fswiss\fcharset0\fprq2 MS Sans Serif;}{\f8\froman\fcharset0\fprq2 Times;}{\f9\fswiss\fcharset0\fprq2 Helvetica;}
{\f10\fswiss\fcharset0\fprq2 System;}{\f11\fmodern\fcharset0\fprq1 Courier New;}{\f12\fdecor\fcharset2\fprq2 ZapfDingbats;}{\f13\fnil\fcharset2\fprq2 Marlett;}{\f14\fswiss\fcharset238\fprq2 Arial CE;}{\f15\fswiss\fcharset204\fprq2 Arial CYR;}
{\f16\fswiss\fcharset161\fprq2 Arial Greek;}{\f17\fswiss\fcharset162\fprq2 Arial TUR;}{\f18\fswiss\fcharset186\fprq2 Arial Baltic;}{\f19\fmodern\fcharset238\fprq1 Courier New CE;}{\f20\fmodern\fcharset204\fprq1 Courier New CYR;}
{\f21\fmodern\fcharset161\fprq1 Courier New Greek;}{\f22\fmodern\fcharset162\fprq1 Courier New TUR;}{\f23\fmodern\fcharset186\fprq1 Courier New Baltic;}{\f24\fmodern\fcharset0\fprq1 Lucida Console;}{\f25\froman\fcharset238\fprq2 Times New Roman CE;}
{\f26\froman\fcharset204\fprq2 Times New Roman CYR;}{\f27\froman\fcharset161\fprq2 Times New Roman Greek;}{\f28\froman\fcharset162\fprq2 Times New Roman TUR;}{\f29\froman\fcharset186\fprq2 Times New Roman Baltic;}{\f30\fnil\fcharset2\fprq2 Wingdings;}
{\f31\fswiss\fcharset0\fprq2 Verdana;}{\f32\fswiss\fcharset0\fprq2 Arial Black;}{\f33\fscript\fcharset0\fprq2 Comic Sans MS;}{\f34\froman\fcharset0\fprq2 Georgia;}{\f35\fswiss\fcharset0\fprq2 Franklin Gothic Medium;}
{\f36\froman\fcharset0\fprq2 Palatino Linotype;}{\f37\fswiss\fcharset0\fprq2 Tahoma;}{\f38\fswiss\fcharset0\fprq2 Trebuchet MS;}{\f39\froman\fcharset2\fprq2 Webdings;}{\f40\fscript\fcharset1\fprq2 Estrangelo Edessa;}{\f41\fnil\fcharset1\fprq2 Gautami;}
{\f42\fnil\fcharset1\fprq2 Latha;}{\f43\fnil\fcharset1\fprq2 Mangal;}{\f44\fnil\fcharset1\fprq2 MV Boli;}{\f45\fnil\fcharset1\fprq2 Raavi;}{\f46\fnil\fcharset1\fprq2 Shruti;}{\f47\fnil\fcharset1\fprq2 Tunga;}{\f48\froman\fcharset0\fprq2 Sylfaen;}
{\f49\fswiss\fcharset0\fprq2 Microsoft Sans Serif;}{\f50\fswiss\fcharset0\fprq2 Arial Narrow;}{\f51\fdecor\fcharset0\fprq2 Curlz MT;}{\f52\froman\fcharset0\fprq2 Engravers MT;}{\f53\fswiss\fcharset0\fprq2 Franklin Gothic Book;}
{\f54\fswiss\fcharset0\fprq2 Franklin Gothic Demi Cond;}{\f55\fswiss\fcharset0\fprq2 Franklin Gothic Heavy;}{\f56\fswiss\fcharset0\fprq2 Franklin Gothic Medium Cond;}{\f57\fswiss\fcharset0\fprq2 Century Gothic;}
{\f58\fscript\fcharset0\fprq2 Edwardian Script ITC;}{\f59\fdecor\fcharset0\fprq2 Jokerman;}{\f60\fdecor\fcharset0\fprq2 Juice ITC;}{\f61\fswiss\fcharset0\fprq2 Lucida Sans Unicode;}{\f62\fscript\fcharset0\fprq2 Mistral;}
{\f63\fmodern\fcharset0\fprq2 OCR A Extended;}{\f64\froman\fcharset0\fprq2 Rockwell;}{\f65\froman\fcharset2\fprq2 Wingdings 2;}{\f66\froman\fcharset2\fprq2 MT Extra;}{\f67\fswiss\fcharset0\fprq2 Impact;}{\f68\fmodern\fcharset2\fprq1 MS LineDraw;}
{\f69\fdecor\fcharset0\fprq2 Algerian;}{\f70\fswiss\fcharset0\fprq2 Arial Rounded MT Bold;}{\f71\froman\fcharset0\fprq2 Bookman Old Style;}{\f72\fdecor\fcharset0\fprq2 Braggadocio;}{\f73\fswiss\fcharset0\fprq2 Britannic Bold;}
{\f74\fscript\fcharset0\fprq2 Brush Script MT;}{\f75\fdecor\fcharset0\fprq2 Colonna MT;}{\f76\fdecor\fcharset0\fprq2 Desdemona;}{\f77\froman\fcharset0\fprq2 Footlight MT Light;}{\f78\fdecor\fcharset0\fprq2 Kino MT;}
{\f79\froman\fcharset0\fprq2 Wide Latin;}{\f80\fscript\fcharset0\fprq2 Matura MT Script Capitals;}{\f81\fdecor\fcharset0\fprq2 Playbill;}{\f82\fnil\fcharset0\fprq2 OpenSymbol;}{\f83\fswiss\fcharset2\fprq2 WP Phonetic;}
{\f84\fnil\fcharset2\fprq2 WP MathExtendedB;}{\f85\fmodern\fcharset0\fprq1 WP BoxDrawing;}{\f86\fnil\fcharset2\fprq2 WP IconicSymbolsB;}{\f87\fnil\fcharset2\fprq2 WP Greek Helve;}{\f88\fnil\fcharset2\fprq2 WP MathExtendedA;}
{\f89\froman\fcharset2\fprq2 WP CyrillicA;}{\f90\fnil\fcharset2\fprq2 WP Japanese;}{\f91\fnil\fcharset2\fprq2 WP MathB;}{\f92\fnil\fcharset2\fprq2 WP IconicSymbolsA;}{\f93\fnil\fcharset2\fprq2 WP Arabic Sihafa;}
{\f94\froman\fcharset2\fprq2 WP MultinationalA Roman;}{\f95\fnil\fcharset0\fprq2 WP CyrillicB;}{\f96\fnil\fcharset2\fprq2 WP MultinationalB Roman;}{\f97\fmodern\fcharset2\fprq1 WP Greek Courier;}{\f98\fnil\fcharset2\fprq2 WP MathA;}
{\f99\fnil\fcharset2\fprq2 WP ArabicScript Sihafa;}{\f100\fnil\fcharset2\fprq2 WP Greek Century;}{\f101\fnil\fcharset2\fprq2 WP TypographicSymbols;}{\f102\fnil\fcharset2\fprq2 WP Hebrew David;}{\f103\fnil\fcharset2\fprq2 WP MultinationalA Helve;}
{\f104\fnil\fcharset2\fprq2 WP MultinationalB Helve;}{\f105\fmodern\fcharset2\fprq1 WP MultinationalA Courier;}{\f106\fmodern\fcharset2\fprq1 WP MultinationalB Courier;}{\f107\fscript\fcharset0\fprq2 Ribbon131 Bd BT;}
{\f108\froman\fcharset0\fprq2 Humanst521 Lt BT;}{\f109\froman\fcharset0\fprq2 GeoSlab703 Lt BT;}{\f110\fswiss\fcharset0\fprq2 Swis721 BlkEx BT;}{\f111\fswiss\fcharset0\fprq2 Humanst521 Cn BT;}{\f112\fdecor\fcharset0\fprq2 Onyx BT;}
{\f113\fdecor\fcharset0\fprq2 CaslonOpnface BT;}{\f114\fswiss\fcharset0\fprq2 EngraversGothic BT;}{\f115\fscript\fcharset0\fprq2 ShelleyVolante BT;}{\f116\froman\fcharset0\fprq2 BernhardMod BT;}{\f117\froman\fcharset0\fprq2 Arrus BT;}
{\f118\fscript\fcharset0\fprq2 OzHandicraft BT;}{\f119\fnil\fcharset0\fprq2 Sydnie;}{\f120\froman\fcharset255\fprq2 Roman;}{\f121\fscript\fcharset255\fprq2 Script;}{\f122\fmodern\fcharset255\fprq2 Modern;}{\f123\fswiss\fcharset0\fprq1 MS Dialog;}
{\f124\fmodern\fcharset0\fprq0 Elite;}{\f125\fmodern\fcharset0\fprq0 Prestige;}{\f126\fswiss\fcharset0\fprq0 Letter Gothic;}{\f127\fmodern\fcharset0\fprq0 GothicPS;}{\f128\fmodern\fcharset0\fprq0 CubicPS;}{\f129\fmodern\fcharset0\fprq0 LinePrinter;}
{\f130\fmodern\fcharset0\fprq0 AvantGarde;}{\f131\fswiss\fcharset0\fprq0 Helvetica-Narrow;}{\f132\fmodern\fcharset0\fprq0 Metro;}{\f133\fswiss\fcharset0\fprq0 Presentation;}{\f134\fmodern\fcharset0\fprq0 APL;}{\f135\fmodern\fcharset0\fprq0 OCRA;}
{\f136\fmodern\fcharset0\fprq0 OCRB;}{\f137\froman\fcharset0\fprq0 Bookman;}{\f138\froman\fcharset0\fprq0 Madaleine;}{\f139\froman\fcharset0\fprq0 ZapfHumanist;}{\f140\froman\fcharset0\fprq0 Classic;}{\f141\froman\fcharset0\fprq0 Roman f;}
{\f142\froman\fcharset0\fprq0 Roman g;}{\f143\froman\fcharset0\fprq0 Roman h;}{\f144\froman\fcharset0\fprq0 NewCenturySchlbk;}{\f145\froman\fcharset0\fprq0 Palatino;}{\f146\froman\fcharset0\fprq0 Souvenir;}{\f147\froman\fcharset0\fprq0 Garamond;}
{\f148\froman\fcharset0\fprq0 Caledonia;}{\f149\froman\fcharset0\fprq0 Bodini;}{\f150\froman\fcharset0\fprq0 University;}{\f151\fscript\fcharset0\fprq0 ScriptPS;}{\f152\fscript\fcharset0\fprq0 Script c;}{\f153\fscript\fcharset0\fprq0 Script d;}
{\f154\fscript\fcharset0\fprq0 Commercial Script;}{\f155\fscript\fcharset0\fprq0 Park Avenue;}{\f156\fscript\fcharset0\fprq0 Coronet;}{\f157\fscript\fcharset0\fprq0 Script h;}{\f158\fscript\fcharset0\fprq0 Greek;}{\f159\froman\fcharset0\fprq0 Kana;}
{\f160\froman\fcharset0\fprq0 Hebrew;}{\f161\froman\fcharset0\fprq0 Roman s;}{\f162\froman\fcharset0\fprq0 Russian;}{\f163\froman\fcharset0\fprq0 Roman u;}{\f164\froman\fcharset0\fprq0 Roman v;}{\f165\froman\fcharset0\fprq0 Roman w;}
{\f166\fdecor\fcharset0\fprq0 Narrator;}{\f167\fdecor\fcharset0\fprq0 Emphasis;}{\f168\fdecor\fcharset0\fprq0 ZapfChancery;}{\f169\fdecor\fcharset0\fprq0 Decor d;}{\f170\fdecor\fcharset0\fprq0 Old English;}{\f171\fdecor\fcharset0\fprq0 Decor f;}
{\f172\fdecor\fcharset0\fprq0 Decor g;}{\f173\fdecor\fcharset0\fprq0 Cooper Black;}{\f174\fnil\fcharset0\fprq0 Math7;}{\f175\fnil\fcharset0\fprq0 Math8;}{\f176\fnil\fcharset0\fprq0 EAN;}{\f177\fnil\fcharset0\fprq0 PCline;}
{\f178\fnil\fcharset0\fprq0 Tech h;}{\f179\fmodern\fcharset0\fprq0 Courier Bold{\*\falt Courier};}{\f180\fmodern\fcharset0\fprq0 Courier Oblique{\*\falt Courier};}}{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;
\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;
\red128\green128\blue128;\red192\green192\blue192;}{\stylesheet{\f4\fs20 \snext0 Normal;}{\*\cs10 \additive Default Paragraph Font;}{\s15\tqc\tx4320\tqr\tx8640 \f4\fs20 \sbasedon0\snext15 header;}{\s16\tqc\tx4320\tqr\tx8640 \f4\fs20 \sbasedon0\snext16 
footer;}}{\info{\author Nicholas L. Pappas, Ph.D.}{\creatim\yr1910\mo2\dy1}{\revtim\yr1910\mo2\dy1}{\version1}{\edmins1}{\nofpages0}{\nofwords0}{\nofchars0}{\vern49203}}\margl1440\margr1152\margt720\margb720 
\facingp\ftnbj\aenddoc\ftnrestart\pgnstart260\notabind\noextrasprl\sprsspbf\brkfrm\hyphcaps0 \fet0\sectd \sbknone\pgnrestart\pgnstarts260\linex576\footery480\endnhere {\headerl \pard\plain \qj\li-1440\ri-1152\sl-240\slmult0 \f4\fs20 {\f3\fs24 
                                Computer Architecture and Design
\par }}{\headerr \pard\plain \qj\li-1440\ri-1152\sl-240\slmult0 \f4\fs20 {\f3\fs24                                 Computer Architecture and Design
\par }}{\footerl \pard\plain \qj\li-1440\ri-1152\sl-240\slmult0 \f4\fs20 {\f3\fs24  (C) Copyright 1991 Nicholas. L. Pappas, PhD.  910801          \chpgn 
\par }}{\footerr \pard\plain \qj\li-1440\ri-1152\sl-240\slmult0 \f4\fs20 {\f3\fs24  (C) Copyright 1991 Nicholas. L. Pappas, PhD.  910801          \chpgn 
\par }}{\*\pnseclvl1\pnucrm\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl2\pnucltr\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl3\pndec\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl4\pnlcltr\pnstart1\pnindent720\pnhang{\pntxta )}}
{\*\pnseclvl5\pndec\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl6\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl8
\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}\pard\plain \sl-240\slmult0 \f4\fs20 {\b\f3\fs24 2.9 Microprogramming Operators}{\f3\fs24 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 
Perhaps a review of the uI execution process and how that leads to mI lists is in order at this point.  Execution of any uI requires reading the source and destination data, processing the data, and writing the result to the destination.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24                     XOR r}{\f3\fs24\dn60 3}{\f3\fs24  r}{\f3\fs24\dn60 7}{\f3\fs24 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24      read data:     connect r}{\f3\fs24\dn60 3}{\f3\fs24  to one ALU input
\par                     connect r}{\f3\fs24\dn60 7}{\f3\fs24  to the other ALU input
\par      process data:  data}{\f3\fs24\dn60 3}{\f3\fs24  xor data}{\f3\fs24\dn60 7}{\f3\fs24  = data_result
\par      write data:    write data_result to r}{\f3\fs24\dn60 7}{\f3\fs24 
\par      exit:
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 The read, process, write, exit seq
uence executes in one computer cycle.  The XOR uI executes in one computer cycle because only one operation is needed and no memory references are required. That this is a special case becomes clear when an exchange of registers is implemented by a mI lis
t for a uI.  An exchange of the contents of two registers requires more than one computer cycle because a third register is needed to temporarily save the data from one register.  Three operations are required to exchange registers.
\par Here is a list in RTL language.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24      EXCH r}{\f3\fs24\dn60 3}{\f3\fs24  r}{\f3\fs24\dn60 7}{\f3\fs24 
\par         rt <\_\_\_ r}{\f3\fs24\dn60 3}{\f3\fs24        copy data}{\f3\fs24\dn60 3}{\f3\fs24  to rtemp
\par         r}{\f3\fs24\dn60 3}{\f3\fs24  <\_\_\_ r}{\f3\fs24\dn60 7}{\f3\fs24        copy data}{\f3\fs24\dn60 7}{\f3\fs24  to r}{\f3\fs24\dn60 3}{\f3\fs24 
\par         r}{\f3\fs24\dn60 7}{\f3\fs24  <\_\_\_ rt       copy rtemp data}{\f3\fs24\dn60 3}{\f3\fs24  to r}{\f3\fs24\dn60 7}{\f3\fs24 
\par         exit
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 The XOR mI list has one mI, EXCH has three mI in its list, and for some address modes the mI list is longer than three mI.  How is the issue of executing a variable number of mI in a list resolved?
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 One way to resolve this issue is to let each uI specify execution of what is called a microprogram.  The XOR microprogram becomes something like 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24           mALU xor r}{\f3\fs24\dn60 3}{\f3\fs24  r}{\f3\fs24\dn60 7}{\f3\fs24  r}{\f3\fs24\dn60 7}{\f3\fs24 
\par           mBR  nop un fetch_uI
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 The first microinstruction mALU performs a read\_process\_write\_exit sequence that ends with the result in r}{\f3\fs24\dn60 7}{\f3\fs24 . Next mBR executes its own read\_process\_write\_
exit sequence.  mBR tests the unconditional branch decision un and branches to the address fetch_uI.  The cI at address fetch_uI then fetch the next }{\b\f3\fs24 uI}{\f3\fs24 
 which directs control to the start address of the microprogram corresponding to that uI.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 \page Suppose the next uI is EXCH r}{\f3\fs24\dn60 3}{\f3\fs24  r}{\f3\fs24\dn60 7}{\f3\fs24 .  Here is what happens.  Control executes }{\b\f3\fs24 mI}{\f3\fs24 
 one by one.  Control executes sequentially the list of mI in the EXCH microprogram which is
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24           mMOV r}{\f3\fs24\dn60 3}{\f3\fs24  rt nop
\par           mMOV r}{\f3\fs24\dn60 7}{\f3\fs24  r}{\f3\fs24\dn60 3}{\f3\fs24  nop
\par           mMOV rt r}{\f3\fs24\dn60 7}{\f3\fs24  nop
\par           mBR  nop un fetch_uI
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 
Observe that for every pair of specific register numbers another mI list would be needed.  The mI lists would be identical except for the register numbers.  We have arranged for the actual register numbers in the uI codeword to program the register file d
irectly.  Since this is the case only one generic mI list for EXCH serves to implement the 256 register numbered mI lists.  
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24           mMOV r}{\f3\fs24\dn60 x}{\f3\fs24  rt nop
\par           mMOV r}{\f3\fs24\dn60 y}{\f3\fs24  r}{\f3\fs24\dn60 x}{\f3\fs24  nop
\par           mMOV rt r}{\f3\fs24\dn60 y}{\f3\fs24  nop
\par           mBR  nop un fetch_uI
\par }\pard {\f3\fs24 
\par 
\par }\pard \sl-240\slmult0 {\f3\fs24 The operator uI ADD  ADDC  CMP  DEC  NEG  SUB  SUBC  AND  OR  XOR are implemented in one line in the sense that other mI exist in their mI lists only to implement the address modes and to exit.  This is explained below.  

\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 
Many examples are found in section 2.9.  In those examples all one needs to do to use another operator uI is change the mALU op operand.  For example, when the XOR uI replaces the ADD uI change the op operand from add to xor.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 The shift operators are more complex because the shifter shifts only one bit per operation.  A loop implements k shifts where k is found in the source operand.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24        SRA r}{\f3\fs24\dn60 x}{\f3\fs24  r}{\f3\fs24\dn60 y}{\f3\fs24  =  mALU subr r}{\f3\fs24\dn60 x}{\f3\fs24  r0 nop nop  (cmp r}{\f3\fs24\dn60 x}{\f3\fs24  to rzero)
\par                     mBR  nop le exit         (exit if k<=0 )
\par             again   mALU sra nop r}{\f3\fs24\dn60 y}{\f3\fs24  r}{\f3\fs24\dn60 y}{\f3\fs24  nop
\par                     mALU  \_1 nop r}{\f3\fs24\dn60 x}{\f3\fs24  r}{\f3\fs24\dn60 x}{\f3\fs24  nop
\par                     mBR  nop nz again      
\par              exit   mBR  nop un fetch_uI
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 A more complex example is found in section 2.9.4.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 \page The uI ABS r}{\f3\fs24\dn60 y}{\f3\fs24  is implementated by an if\_then\_else statement.  If the number in r}{\f3\fs24\dn60 y}{\f3\fs24 
 is negative then negate the number else do nothing and exit.  The end result is that r}{\f3\fs24\dn60 y}{\f3\fs24 
 contains a positive number representing the absolute value.  A major point is that understanding the purpose of the uI is a prerequisite to writing the mI list.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24           ABS r}{\f3\fs24\dn60 y}{\f3\fs24  =  mALU sub r0  r}{\f3\fs24\dn60 y}{\f3\fs24  nop nop       (set status)
\par                     mBR  nop nn exit  
\par                     mALU neg nop r}{\f3\fs24\dn60 y}{\f3\fs24  r}{\f3\fs24\dn60 y}{\f3\fs24  nop        ( r}{\f3\fs24\dn60 y}{\f3\fs24  <\_\_\_ \_r}{\f3\fs24\dn60 y}{\f3\fs24  )
\par               exit  mBR  nop un fetch_uI
\par }\pard {\f3\fs24 
\par 
\par }\pard \sl-240\slmult0 {\f3\fs24 The mI list for the bit test uI BTST reveals how a mask is created and used.  The bit number k is the source data and the number to be tested is in the destination.  In effect BTST puts the complement of r}{\f3\fs24\dn60 y
}{\f3\fs24 's bit k in status bit Z.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 BTST r}{\f3\fs24\dn60 x}{\f3\fs24  r}{\f3\fs24\dn60 y}{\f3\fs24  =   mALU  +1 r0 nop rt  nop       (put a 1 in rtemp)
\par                mALU sub r0 r}{\f3\fs24\dn60 x}{\f3\fs24   nop nop       (cmp k to 0)
\par                mBR  nop eq mask              (skip shift if k=0)
\par                mBR  nop n  exit              (do nothing if k<0)
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24         shift  mALU sll nop rt  rt nop  (sll rtemp left)
\par                mALU  \_1 nop r}{\f3\fs24\dn60 x}{\f3\fs24   r}{\f3\fs24\dn60 x}{\f3\fs24  nop  (decrement r}{\f3\fs24\dn60 x}{\f3\fs24  by 1)
\par                mBR  nop nz  shift       (sll again if rs nz)
\par                                    <\_\_\_ (here rtemp is sll k times)
\par          mask  mALU and rt  r}{\f3\fs24\dn60 y}{\f3\fs24  nop nop  (mask bit, report in Z)
\par          exit  mBR  nop un fetch_uI     (exit when done)   
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 \page }{\b\f3\fs24 2.10 Microprogramming Address Modes}{\f3\fs24 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Data sources and destinations are registers and memory.  To reach data the addresses must 
be known.  An instruction address mode calculates the memory address to read or write.  This calculated address is called the effective address or ea.  [The eo or effective operand is the content of the ea.]  So the mI list for a uI includes mI to calcula
te the data addresses and mI to read or write data according to the uI function.  In this way the mI use the uData Path (figure 2.11).
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 With two operands per uI, source implies read and destination implies read as well as write.  Read the data from source a
nd destination, process it, and write the result back to the destination.  When reading source bits must be stable for the duration of the read, alu process, and write phases.  For example, storing an address in the mar presents a new address to the rams.
  In turn the data bits change at the memory q output when the addressed word appears.  This is why stable data bits at q require stable, and unchanging mar contents.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 In what follows mI lists for various uI demonstrate how the architecture is used by the s
ix uI operand combinations of address modes (Section 2.8.2).  In this computer the effective address is reached by one of seven modes:
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 address mode                       s_ea or d_ea 
\par \_\_\_\_\_\_\_\_\_\_\_\_                       \_\_\_\_\_\_\_\_\_\_\_\_
\par immediate                          iw (source only)
\par register direct                    rs
\par r/i (register indirect)            *rs
\par r/i with predecrement              *\_rs
\par r/i with post increment            *rs+
\par r/i with signed displacement n     *rs(n) 
\par absolute address                   addr_abs
\par }\pard {\f3\fs24 
\par }{\b\f3\fs24 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 2.10.1 Register to Register}{\f3\fs24 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 The mI list for ADD r}{\f3\fs24\dn60 x}{\f3\fs24  r}{\f3\fs24\dn60 y}{\f3\fs24  whose RTL statement is r}{\f3\fs24\dn60 y}{\f3\fs24  <\_\_ r}{\f3\fs24\dn60 x}{\f3\fs24  + r}{\f3\fs24\dn60 y}{\f3\fs24  is straightforward.

\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24     ADD r}{\f3\fs24\dn60 x}{\f3\fs24  r}{\f3\fs24\dn60 y}{\f3\fs24   =  mALU add r}{\f3\fs24\dn60 x}{\f3\fs24  r}{\f3\fs24\dn60 y}{\f3\fs24  r}{\f3\fs24\dn60 y}{\f3\fs24  nop
\par                   mBR  nop un fetch_uI 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Every mI list needs a return to the fetch_uI code.  This mBR branch is analogous to the RET return code that ends every assembly language subroutine.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 The mALU mI fetches (reads) the contents of r}{\f3\fs24\dn60 x}{\f3\fs24  and r}{\f3\fs24\dn60 y}{\f3\fs24  to the two source buses sx and sy which are connected to the two ALU inputs.  The numbers in r}{\f3\fs24\dn60 x}{
\f3\fs24  and r}{\f3\fs24\dn60 y}{\f3\fs24  are now inputs to the ALU which calculates the sum.  The sum is stored in r}{\f3\fs24\dn60 y}{\f3\fs24 .  
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 \page }{\b\f3\fs24 2.10.2 Memory to Register}{\f3\fs24 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 The mI list for ADD s_ea r}{\f3\fs24\dn60 y}{\f3\fs24  varies according to the source address calculation required.  The generic mI list is as follows.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24     ADD s_ea r}{\f3\fs24\dn60 y}{\f3\fs24   =  mI list to calc s_ea and store s_ea in mar
\par                     mALU add mem r}{\f3\fs24\dn60 y}{\f3\fs24  r}{\f3\fs24\dn60 y}{\f3\fs24  nop       
\par                     mBR  nop un fetch\_uI
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Note: the nop in mBR becomes an incpc if s_ea uses a literal.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 A memory read is requested when the s_ea is loade
d into the mar.  The accessed data appears at the memory data output (figure 2.11).  We call this output mem and show it as a source in the micro-assembly language (Table 2.7).  That is why mem is shown as an mALU source operand.  The generic s_ea is not 
a source in the micro-assembly language.
\par }\pard {\f3\fs24 
\par 
\par }\pard \sl-240\slmult0 {\f3\fs24 Examples:
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Hint: To know what to do keep looking at figure 2.11 and Table 2.7.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 In what follows we discover a need for a +4 number analogous to r0 (rzero).  The +4 needs to be implemented in the data path hardware.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24      ADD *r}{\f3\fs24\dn60 x}{\f3\fs24  r}{\f3\fs24\dn60 y}{\f3\fs24   =  mMOV r}{\f3\fs24\dn60 x}{\f3\fs24  mar r            (data address to mar)
\par                     mALU add mem r}{\f3\fs24\dn60 y}{\f3\fs24  r}{\f3\fs24\dn60 y}{\f3\fs24  nop   (sum to r}{\f3\fs24\dn60 y}{\f3\fs24 )
\par                     mBR  nop un fetch_uI\tab (exit)
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24      MOV *r}{\f3\fs24\dn60 x}{\f3\fs24 + r}{\f3\fs24\dn60 y}{\f3\fs24  =  mMOV r}{\f3\fs24\dn60 x}{\f3\fs24  mar r            (data address to mar)
\par                     mALU add r}{\f3\fs24\dn60 x}{\f3\fs24  +4 r}{\f3\fs24\dn60 x}{\f3\fs24  nop    (post increment r}{\f3\fs24\dn60 x}{\f3\fs24 )
\par                     mMOV mem r}{\f3\fs24\dn60 y}{\f3\fs24  nop          (data to r}{\f3\fs24\dn60 y}{\f3\fs24 )
\par                     mBR  nop un fetch_uI
\par }\pard {\f3\fs24 
\par 
\par }\pard \sl-240\slmult0 {\f3\fs24 \page }{\b\f3\fs24 2.10.3 Register to Memory}{\f3\fs24 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 The mI list for ADD r}{\f3\fs24\dn60 x}{\f3\fs24  d_ea varies according to the destination address calculation required.  The generic mI list is 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24     ADD r}{\f3\fs24\dn60 x}{\f3\fs24  d_ea  =  mI list to calc d_ea and store d_ea in mar
\par                     mALU add r}{\f3\fs24\dn60 x}{\f3\fs24  mem mbr w       
\par                     mBR  nop un fetch\_uI
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Note: the nop in mBR becomes an incpc if d_ea uses a literal.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 A memory read is requested when the d_ea is loaded into the mar.  The accessed data appears at the memory q data output (figure 2.11).  The mALU calculates the sum and writes it back into the memory at the same address.

\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Examples:
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24      ADD r}{\f3\fs24\dn60 x}{\f3\fs24  *r}{\f3\fs24\dn60 y}{\f3\fs24 + =  mMOV r}{\f3\fs24\dn60 y}{\f3\fs24  mar r            (data address to mar)
\par                     mALU add +4 r}{\f3\fs24\dn60 y}{\f3\fs24  r}{\f3\fs24\dn60 y}{\f3\fs24  nop    (post increment r}{\f3\fs24\dn60 y}{\f3\fs24 )
\par                     mALU add r}{\f3\fs24\dn60 x}{\f3\fs24  mem mbr w    (sum to memory)
\par                     mBR  nop un fetch_uI
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24    AND r}{\f3\fs24\dn60 x}{\f3\fs24  *r}{\f3\fs24\dn60 y}{\f3\fs24 (n) =  mMOV pc mar r            (address of n to mar)
\par                     mALU add mem r}{\f3\fs24\dn60 y}{\f3\fs24  mar r    (n + r}{\f3\fs24\dn60 y}{\f3\fs24  to mar)
\par                     mALU and r}{\f3\fs24\dn60 x}{\f3\fs24  mem mbr w    (and to memory)
\par                     mBR  incpc un fetch_uI   (incpc skips over n)
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24         CLR *\_ry =  mALU sub +4 r}{\f3\fs24\dn60 y}{\f3\fs24  r}{\f3\fs24\dn60 y}{\f3\fs24  nop    (predecrement r}{\f3\fs24\dn60 y}{\f3\fs24 )
\par                     mMOV r}{\f3\fs24\dn60 y}{\f3\fs24  mar nop          (data address to mar)
\par                     mMOV r0 mbr w            (write 0 to clr dest)
\par                     mBR  nop un fetch_uI      
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24  XOR r}{\f3\fs24\dn60 x}{\f3\fs24  addr_abs =  mMOV pc mar r            (mar points to a_a)
\par                     mMOV mem mar r           (mar points to data)
\par                     mALU xor r}{\f3\fs24\dn60 x}{\f3\fs24  mem mbr w    (xor to dest)
\par                     mBR  incpc un fetch_uI   (skip over addr_abs)
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24         NOT *\_r}{\f3\fs24\dn60 x}{\f3\fs24  =  mALU subr r}{\f3\fs24\dn60 x}{\f3\fs24  +4 r}{\f3\fs24\dn60 x}{\f3\fs24  nop   (pre decrement r}{\f3\fs24\dn60 x}{\f3\fs24 )
\par                     mMOV r}{\f3\fs24\dn60 x}{\f3\fs24   mar r           (data address to mar)
\par                     mALU not nop mem mbr w   (data' to d_ea)
\par                     mBR  nop un fetch_uI
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24          ABS *r}{\f3\fs24\dn60 y}{\f3\fs24  =  mMOV r}{\f3\fs24\dn60 y}{\f3\fs24  mar r
\par                     mALU sub r0 mem nop nop  (cmp data to 0)
\par                     mBR  nop nn exit
\par                     mALU neg nop mem mbr w
\par                exit mBR  nop un fetch_uI
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 \page }{\b\f3\fs24 2.10.4 Memory to Memory}{\f3\fs24 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Once again the mI list for ADD s_ea d_ea varies according to the address calculations required.  The generic mI list is 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24  ADD s_ea d_ea =  mI list to calc s_ea and store in mar
\par                   mMOV mem rt nop
\par                   mI list to calc d_ea and store in mar
\par                   mALU add rt mem mbr w
\par                   mBR  nop un fetch_uI
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Note: the nop in mBR becomes an incpc if s_ea or d_ea uses a literal. If both sources use literals an mBR incpc un 1 is added to the mI list. 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 This list uses the hardware register rtemp to hold s_ea data.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 
Once calculated the s_ea is stored in the mar (figure 2.11) and a memory read cycle reads s_ea data (mem) to a source bus.  The s_ea data bits are stable on the source bus until the contents of mar are changed.  Mar contents must be changed to read out d_
ea data.  Thus the s_ea data must be saved in rtemp.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 You cannot use the register file as a temporary storage because you do not want to change the contents of a user register.  This would be an undesireable side effect.  If you do this how can the 
user debug errors caused by such an }{\b\f3\fs24 interference}{\f3\fs24 ?  The user cannot debug what he does not know about.  This is why we need a register like rtemp hidden from the user (figure 2.11).
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Examples:
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24      ADD *r}{\f3\fs24\dn60 x}{\f3\fs24  *r}{\f3\fs24\dn60 y}{\f3\fs24  =  mMOV r}{\f3\fs24\dn60 x}{\f3\fs24  mar r          (s data address to mar)
\par                     mMOV mem rt nop        (put s data in rtemp)
\par                     mMOV r}{\f3\fs24\dn60 y}{\f3\fs24  mar r          (d data address to mar)
\par                     mALU add rt mem mbr w  (sum to memory)
\par                     mBR  nop un fetch_uI
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 The move of r}{\f3\fs24\dn60 y}{\f3\fs24  to mar is the last move to mar.  In this way the destination address is in the mar ready for the mALU mI to use by writing the sum to the mbr and ordering a w(rite).
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24      SLL *r}{\f3\fs24\dn60 x}{\f3\fs24  *r}{\f3\fs24\dn60 y}{\f3\fs24  =  mMOV r}{\f3\fs24\dn60 x}{\f3\fs24  mar r            (address s_data)
\par                     mMOV mem rt nop          (s_data to rtemp)
\par                     mALU sub r0 rt nop nop   (cmp to set status)
\par                     mBR  nop le exit         (exit if k<=0)
\par                     mMOV r}{\f3\fs24\dn60 y}{\f3\fs24  mar r            (address d_data)
\par               again mALU sll mem nop mbr w   (shift & write dest)
\par                     mALU  \_1 rt  nop rt  nop (decrement k in rt)
\par                     mBR  nop nz again        (shift again if k<>0)
\par                exit mBR  nop un fetch_uI
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 \page }{\b\f3\fs24 2.10.5 Literal to Register}{\f3\fs24 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 The literal word iw is a number.  A literal is one form of address mode.  When an iw is used as an operand the address mode is called the immediate mode.  Iw is immediately available for use.  
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Where is iw?  Literal operands are placed in memory in the word following the uI word.  If uI is at address m then iw is at address m+4 in this computer (figure 2.1a).
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 After fetch_uI the uI code for ADD iw r}{\f3\fs24\dn60 y}{\f3\fs24  is in the ir, and the pc points to the iw.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24           mem_addr  contents of word
\par           \_\_\_\_\_\_\_\_  \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
\par pc+4\_\_>   m+8       code of next uI
\par pc\_\_>     m+4       iw
\par           m         uI code for ADD iw r}{\f3\fs24\dn60 y}{\f3\fs24 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 You can deduce from the physical storage of code words that one possible mI list for the register direct address mode is as follows.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Example:
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24        ADD iw ry =  mMOV pc mar r          (address of iw in mar)
\par                     mALU add mem r}{\f3\fs24\dn60 y}{\f3\fs24  r}{\f3\fs24\dn60 y}{\f3\fs24  nop (add iw to num in r}{\f3\fs24\dn60 y}{\f3\fs24 )
\par                     mBR  incpc un fetch_uI (skip over iw)
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 
When the ADD uI was fetched the pc was incremented to m+4 to point to the iw by the three fetch_uI mIs.  This is why you can use mMOV pc mar as the first mI in this list.  Incpc in mBR is needed to skip over iw and point to the code of the next uI at m+8.
  This is so because each time fetch_uI is used fetch_uI assumes the pc is pointing to the next uI code word.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 \page }{\b\f3\fs24 2.10.6 Literal to Memory}{\f3\fs24 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Here iw is added to a number in memory at effective address d_ea.  The uI ADD iw d_ea means the literal iw and the contents eo of the effective address d_ea are added and the sum is stored in d_ea.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24           d_ea <\_\_ iw + d_ea 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 
Both operands refer to memory words.  Thus you need to calculate the actual address represented by d_ea and use the hidden logic that tells you where iw is stored.  Hidden because the operand iw does not tell you explicitly where to find iw.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24      ADD iw d_ea =  mMOV pc mar r       \tab (address of iw to mar)
\par                     mMOV mem rt nop     \tab (iw to rtemp)
\par                     mI list to calc d_ea and store in mar
\par                     mALU add rt mem mbr w
\par                     mBR  incpc un fetch_uI   (skip over iw)
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Two literals can be associated with a uI.  Therefore an arbitrary convention is made to put iw before n in memory.  As we start keep in mind the pc points to the iw.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24           mem_addr  contents of word
\par           \_\_\_\_\_\_\_\_  \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
\par pc+8\_\_>   m+C       code of next uI
\par pc+4\_\_>   m+8       n
\par pc\_\_>     m+4       iw
\par           m         uI code for ADD iw *r}{\f3\fs24\dn60 y}{\f3\fs24 (n)
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Examples:
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 ADD iw *r}{\f3\fs24\dn60 y}{\f3\fs24 (n)  =    mMOV pc mar r            (address of iw to mar)
\par                     mMOV mem rt nop          (iw to rtemp)
\par                     mBR  incpc un 1          (skip over iw)
\par                     mMOV pc mar r            (address of n to mar)
\par                     mALU add mem r}{\f3\fs24\dn60 y}{\f3\fs24  mar r    (n + r}{\f3\fs24\dn60 y}{\f3\fs24  to mar)
\par                     mALU add rt mem mbr w    (sum to r}{\f3\fs24\dn60 y}{\f3\fs24 +n)
\par                     mBR  incpc un fetch_uI   (skip over n)
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 ADD iw *r}{\f3\fs24\dn60 y}{\f3\fs24      =    mMOV pc mar r            (address of iw to mar)
\par                     mMOV mem rt nop          (iw to rtemp)
\par                     mMOV r}{\f3\fs24\dn60 y}{\f3\fs24  mar r            (address of data)
\par                     mALU add rt mem mbr w    (sum to address r}{\f3\fs24\dn60 y}{\f3\fs24 )
\par                     mBR  incpc un fetch_uI   (skip over iw)
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 ADD iw *r}{\f3\fs24\dn60 y}{\f3\fs24 +    =    mMOV pc mar r            (address of iw to mar)
\par                     mMOV mem rt nop          (iw to rtemp)
\par                     mMOV r}{\f3\fs24\dn60 y}{\f3\fs24  mar r            (address of data)
\par                     mALU add +4 r}{\f3\fs24\dn60 y}{\f3\fs24  r}{\f3\fs24\dn60 y}{\f3\fs24  nop    (post increment r}{\f3\fs24\dn60 y}{\f3\fs24 )
\par                     mALU add rt mem mbr w    (sum to address r}{\f3\fs24\dn60 y}{\f3\fs24 )
\par                     mBR  incpc un fetch_uI   (skip over iw)
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 \page }{\b\f3\fs24 2.10.7 Absolute Address Mode}{\f3\fs24 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 This mode is complicated by the need to fetch two literals, addr_abs and n, from memory. Again an arbitrary convention is made to put addr_abs before n in memory.  
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24           mem_addr  contents of word
\par           \_\_\_\_\_\_\_\_  \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
\par pc+8\_\_>   m+C       code of next uI
\par pc+4\_\_>   m+8       n
\par pc\_\_>     m+4       addr_abs
\par           m         uI code for ADD addr_abs *r}{\f3\fs24\dn60 y}{\f3\fs24 (n)
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Examples:
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 ADD addr_abs *r}{\f3\fs24\dn60 y}{\f3\fs24 (n) = 
\par                     mMOV pc mar r       (addr of addr_abs to mar)
\par                     mMOV mem mar r           (addr_abs to mar)
\par                     mBR  incpc un 1          (skip over addr_abs)
\par                     mMOV mem rt  nop         (s data to rtemp)
\par                     mMOV pc  mar r           (address of n to mar)
\par                     mALU add mem r}{\f3\fs24\dn60 y}{\f3\fs24  mar r    (r}{\f3\fs24\dn60 y}{\f3\fs24  + n to mar)
\par                     mALU add rt mem mbr w    (sum to r}{\f3\fs24\dn60 y}{\f3\fs24 +n)
\par                     mBR  incpc un fetch_uI   (skip over n)
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Mov addr_abs *r}{\f3\fs24\dn60 y}{\f3\fs24 + = mMOV pc mar r
\par                     mMOV mem mar r
\par                     mMOV mem rt  nop       (save source data)
\par                     mMOV r}{\f3\fs24\dn60 y}{\f3\fs24   mar nop
\par                     mMOV rt  mbr w
\par                     mALU add +4 r}{\f3\fs24\dn60 y}{\f3\fs24  r}{\f3\fs24\dn60 y}{\f3\fs24  nop
\par                     mBR  incpc un fetch_uI                       
\par }\pard {\f3\fs24 
\par 
\par }\pard \sl-240\slmult0 {\f3\fs24 \page }{\b\f3\fs24 2.11 Microprogramming Moves}{\f3\fs24 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Move uI are specified not to affect status bits.  This means the mI list must preserve status if an mALU mI is used for any reason in the mI l
ist for a MOV uI.  The following mI list emphasizes the fact any mALU mI affects status.  A MOV uI is specified not to affect status, however *\_
rx, *ry+ address modes use a mALU mI to adjust the address in a register.  The straightforward approach adds mI to preserve status.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24      MOV *\_r}{\f3\fs24\dn60 x}{\f3\fs24  r}{\f3\fs24\dn60 y}{\f3\fs24  =  mMov st rt nop
\par                     mALU subr r}{\f3\fs24\dn60 x}{\f3\fs24  +4 r}{\f3\fs24\dn60 x}{\f3\fs24  nop
\par                     mMOV rt st nop
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24                     mMov r}{\f3\fs24\dn60 x}{\f3\fs24   mar r
\par                     mMOV mem r}{\f3\fs24\dn60 y}{\f3\fs24   nop
\par                     mBR  nop un fetch\_uI
\par }\pard {\f3\fs24 
\par 
\par }\pard \sl-240\slmult0 {\f3\fs24 A desi
gner objects to adding two mI to this list or any other list.  Is there a hardware solution?  Yes there is.  The answer is use digital logic to allow status loads only when an operator uI is active.  A uI, not mI, opcode field decoder at the ir output can
 provide the signal }{\b\f3\fs24 its_an_mALU}{\f3\fs24  which is asserted only when an operator uI is being executed.  This signal can gate the ldst signal.  Note that the gate circuit will be complicated by uI such as PUTST r}{\f3\fs24\dn60 x}{\f3\fs24 .

\par }\pard {\f3\fs24 
\par 
\par }\pard \sl-240\slmult0 {\f3\fs24 Writing over a register destroys the contents.  If the contents are needed later, such as in an exchange, the contents must be saved prior to writing over.  
\par }\pard {\f3\fs24 
\par 
\par }\pard \sl-240\slmult0 {\f3\fs24      EXCH r}{\f3\fs24\dn60 x}{\f3\fs24  r}{\f3\fs24\dn60 y}{\f3\fs24  =   mMOV r}{\f3\fs24\dn60 x}{\f3\fs24  rt nop           (save r}{\f3\fs24\dn60 x}{\f3\fs24 )
\par                     mMOV r}{\f3\fs24\dn60 y}{\f3\fs24  r}{\f3\fs24\dn60 x}{\f3\fs24  nop           (write r}{\f3\fs24\dn60 y}{\f3\fs24  over r}{\f3\fs24\dn60 x}{\f3\fs24 )
\par                     mMOV rt r}{\f3\fs24\dn60 y}{\f3\fs24  nop           (r}{\f3\fs24\dn60 x}{\f3\fs24  to r}{\f3\fs24\dn60 y}{\f3\fs24 )
\par                     mBR  nop un fetch_uI
\par }\pard {\f3\fs24 
\par 
\par }\pard \sl-240\slmult0 {\f3\fs24 The moves PUSH and POP are discussed in section 2.12.3.
\par }\pard {\f3\fs24 
\par \sect }\sectd \pgnrestart\pgnstarts0\linex576\footery480\endnhere {\headerl \pard\plain \qj\li-1440\ri-1152\sl-240\slmult0 \f4\fs20 {\f3\fs24                                 Computer Architecture and Design
\par }}{\headerr \pard\plain \qj\li-1440\ri-1152\sl-240\slmult0 \f4\fs20 {\f3\fs24                                 Computer Architecture and Design
\par }}{\footerl \pard\plain \qj\li-1440\ri-1152\sl-240\slmult0 \f4\fs20 {\f3\fs24  (C) Copyright 1991 Nicholas. L. Pappas, PhD.     910308     \chpgn 
\par }}{\footerr \pard\plain \qj\li-1440\ri-1152\sl-240\slmult0 \f4\fs20 {\f3\fs24  (C) Copyright 1991 Nicholas. L. Pappas, PhD.     910308     \chpgn 
\par }}\pard\plain \sl-240\slmult0 \f4\fs20 {\b\f3\fs24 2.12 Microprogramming Program Control}{\f3\fs24 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 The program counter (pc) holds the address of the next uI to be executed.  When a uI is fetched by the fetch_uI code the pc is automatically incremented by 4 (pc <\_\_
 pc + 4) to be ready for the next in line fetch.  Therefore when a branch is desired we are only concerned with the question "branch to where?".  There are three basic types of branches.
\par }\pard {\f3\fs24 
\par 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 2.12.1 Jump}{\f3\fs24 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 
Jump to another place in the program and start executing uI from there.  Unconditional jumps provide a simple means to link together program modules.  Conditional jumps provide means to implement the decision making that separates programming from calcula
ting.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 JMP addr_abs        pc <\_\_\_ addr_abs
\par JRcc n              if cc true then pc <\_\_\_ pc+n else pc <\_\_\_ pc+4
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 Jump Absolute:}{\f3\fs24 
  JMP addr_abs allows a jump to anywheres in a user program.  The 32 bit literal operand addr_abs is stored in the memory word following the JMP uI word.  A 32 bit literal spans a 4,294,967,296 (4096M) word memory block.  
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24           mem_addr  contents of word
\par           \_\_\_\_\_\_\_\_  \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
\par pc+4\_\_>   m+8       next uI code
\par pc\_\_>     m+4       addr_abs 
\par           m         uI code for JMP addr_abs 
\par }\pard {\f3\fs24 
\par 
\par }\pard \sl-240\slmult0 {\f3\fs24 The pc holds addr_abs after JMP executes so the code at m+8 is of no concern here.  
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 JMP addr_abs = mMOV pc mar r            (addr of addr_abs to mar)
\par                mMOV mem pc nop          (pc <\_\_ addr_abs)
\par                mBR  nop un fetch_uI     (no need to skip addr_abs,
\par                                          should not modify the pc)
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 \page }{\b\f3\fs24 Jump Relative on a Condition:}{\f3\fs24 
  The jump relative uI JRcc n implements the RTL statement below (the cc are found in Table 2.2).  Note that status being evaluated by JRcc was set by the last uI operat
or to execute prior to JRcc.  That is why care is taken to make sure the basis for the branch decision is correct when }{\b\f3\fs24 uI}{\f3\fs24  programs are written.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 JRcc n         if cc true then pc <\_\_\_ pc+n else pc <\_\_\_ pc+4
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24           mem_addr  contents of word
\par           \_\_\_\_\_\_\_\_  \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
\par pc+4\_\_>   m+8       next uI code
\par pc\_\_>     m+4       n
\par           m         uI code for JRcc n 
\par }\pard {\f3\fs24 
\par 
\par }\pard \sl-240\slmult0 {\f3\fs24 
The process fetching the JRcc uI code also incremented the pc.  The pc now points to the literal n following the JRcc branch uI.  Thus the JRZ mI list includes an incpc to skip over the literal n to point to the next uI if the cc test fails.  
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Consider the following mI list.  Note that the first mBR mcc is the complement of the JR cc.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 JRZ n =   mBR  nop nz exit         (exit if not zero)
\par           mMOV pc mar r            (address of n to mar)
\par           mALU add mem pc pc nop   (pc <\_\_ pc + n)
\par           mBR  nop un fetch_uI     (exit to fetch uI at pc + n)
\par      exit mBR  incpc un fetch_uI   (exit to fetch uI at pc + 4)
\par }\pard {\f3\fs24 
\par 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 2.12.2 Jump to a subroutine}{\f3\fs24 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 
A subroutine is an independent program that is used in many places in a program.  A program can include any number of subroutines.  And, subroutines can use subroutines, and so forth.  This is called nesting of subroutines.  One option is entering the sub
routine code in line at every place in the mainline program or at every place in any subroutine where it is u
sed.  Another option is to include the subroutine code in one place and to call for it when needed.  The uI that calls for any subroutine is the CALL uI.  Here CALL has the two forms CALL target and CALL r}{\f3\fs24\dn60 y}{\f3\fs24 
.  Target and the contents of r}{\f3\fs24\dn60 y}{\f3\fs24 
 represent addresses pointing to the address of the first uI in the subroutine.  Since CALL replaces the in line subroutine code a jump to that code is required.  And, after the subroutine is executed a return to the }{\b\f3\fs24 
next in line uI following }{\f3\fs24 CALL is required (figure 2.26).  The steps are listed below.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24      Save the address of the next in line uI.
\par      Jump to the first uI in a subroutine.
\par      Execute the subroutine
\par      Fetch the address of the saved next in line uI.
\par      Return to resume executing uI from the next in line uI.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 \page 
The user programmer puts in a user program the uI CALL target to call a subroutine whose first uI is at the address target.  The programmer also places the uI RET in the last line of the subroutine to force a return to the mainline program.  CALL r}{
\f3\fs24\dn60 y}{\f3\fs24  is an alternative to CALL target.  We copy from Table 2.1 the register transfer language statements for these uI.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 CALL target    sp <\_\_ sp\_4,  then M[sp] <\_\_ pc,  pc <\_\_ target
\par CALL r}{\f3\fs24\dn60 y}{\f3\fs24         sp <\_\_ sp\_4,  then M[sp] <\_\_ pc,  pc <\_\_ r}{\f3\fs24\dn60 y}{\f3\fs24 
\par RET            pc <\_\_ M[sp], then sp <\_\_ sp+4
\par }\pard {\f3\fs24 
\par 
\par }\pard \sl-240\slmult0 {\f3\fs24 
Suppose we want to execute CALL target.  Target is the ea. The ea is placed in the pc register after saving the contents of the pc holding the next in line uI address.  Saved where?  The answer is in a block of memory designa
ted as the stack.  The stack is pointed to by a register we naturally call the stack pointer register (sp).
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 The stack:}{\f3\fs24   How does a stack function?  First you arbitrarily choose any address such as C5D0A000}{\f3\fs24\dn60 16}{\f3\fs24  as the stack start address and allocate an arbitrarily sized block of say 0800}{
\f3\fs24\dn60 16}{\f3\fs24  memory words to the stack.  The C5D0A000}{\f3\fs24\dn60 16}{\f3\fs24  start address is loaded into the sp prior to using the stack.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 A stack is called a down memory stack when the sp is decremented }{\b\f3\fs24 before }{\f3\fs24 writing to the stack.  Conversely the sp is incremented }{\b\f3\fs24 after }{\f3\fs24 
you read from the stack.  Writing to the stack is a }{\b\f3\fs24 push }{\f3\fs24 and reading from the stack is a }{\b\f3\fs24 pop}{\f3\fs24 .  For example after you push n}{\f3\fs24\dn60 0}{\f3\fs24 , n}{\f3\fs24\dn60 1}{\f3\fs24 , n}{\f3\fs24\dn60 2}{
\f3\fs24 , n}{\f3\fs24\dn60 3}{\f3\fs24 , n}{\f3\fs24\dn60 4}{\f3\fs24 , n}{\f3\fs24\dn60 5}{\f3\fs24  the (sp) = C5D09FE8.  The sp points to the last value pushed.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24      sp        >address  data      stack status
\par      \_\_\_\_\_     \_\_\_\_\_\_\_\_  \_\_\_\_\_     \_\_\_\_\_\_\_\_\_\_\_\_
\par      sp        C5D0A000  x         empty
\par      sp\_04     C5D09FFC  n}{\f3\fs24\dn60 0}{\f3\fs24 
\par      sp\_08     C5D09FF8  n}{\f3\fs24\dn60 1}{\f3\fs24 
\par      sp\_0C     C5D09FF4  n}{\f3\fs24\dn60 2}{\f3\fs24 
\par      sp\_10     C5D09FF0  n}{\f3\fs24\dn60 3}{\f3\fs24 
\par      sp\_14     C5D09FEC  n}{\f3\fs24\dn60 4}{\f3\fs24 
\par      sp\_18     C5D09FE8  n}{\f3\fs24\dn60 5}{\f3\fs24 
\par      sp\_1C     C5D09FE4  x         (x means don't care)
\par      ..        ..        ..
\par      ..        ..        ..
\par      sp\_0800   C5D09800  x         full
\par }\pard {\f3\fs24 
\par 
\par }\pard \sl-240\slmult0 {\f3\fs24 
There is also an up memory stack format.  A stack is an up memory stack when the sp is incremented before writing to the stack.  Conversely the sp is decremented after you read from the stack.  In either case writing to the stack is a push and reading fro
m the stack is a pop.  
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 \page The mI lists for PUSH and POP illustrate the stack functions.  We copy from Table 2.1 the register transfer language statements for PUSH and POP.  Note the sequence of the RTL statements.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24      PUSH r}{\f3\fs24\dn60 y}{\f3\fs24         sp <\_\_\_ sp\_4,  then M[sp] <\_\_\_ r}{\f3\fs24\dn60 y}{\f3\fs24 
\par      POP  r}{\f3\fs24\dn60 y}{\f3\fs24         r}{\f3\fs24\dn60 y}{\f3\fs24  <\_\_\_ M[sp], then sp <\_\_\_ sp+4
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24          PUSH r}{\f3\fs24\dn60 y}{\f3\fs24  =  mBR  decsp un 1
\par                     mMOV sp mar nop
\par                     mMOV r}{\f3\fs24\dn60 y}{\f3\fs24  mbr w
\par                     mBR  nop un fetch\_uI
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24           POP r}{\f3\fs24\dn60 y}{\f3\fs24  =  mMOV sp mar r
\par                     mMOV mem r}{\f3\fs24\dn60 y}{\f3\fs24  nop
\par                     mBR  incsp un fetch\_uI
\par }\pard {\f3\fs24 
\par 
\par }\pard \sl-240\slmult0 {\f3\fs24 Now write the mI list for CALL target.  The call and return algorithm is as follows (figure 2.26).
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24      Save the address of the next in line uI.  
\par      Jump to the first uI in a subroutine.
\par      Execute the subroutine.
\par      Fetch the address of the saved next inline uI
\par      and resume executing uI from there.  
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24           mem_addr  contents of word
\par           \_\_\_\_\_\_\_\_  \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
\par pc+4\_\_>   m+8       next uI code
\par pc\_\_>     m+4       target
\par           m         uI code for CALL target
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 CALL target         sp <\_\_ sp\_4, then m(sp) <\_\_ pc + 4, 
\par                                          pc <\_\_ target
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24      mMOV pc mar r       (mar <\_\_ pc)
\par      mMOV mem rt nop     (target to rt)
\par      mBR  decsp un 1     (sp <\_\_ sp\_4)
\par      mMOV sp mar nop     (mar <\_\_ sp)
\par      mBR  incpc un 1     (pc <\_\_ pc + 4, addr of next in line uI)
\par      mMOV pc mbr w       (mbr <\_\_ pc, implements M[sp] <\_\_ pc to
\par                           save m+8)
\par      mMOV rt pc nop      (pc <\_\_ target)
\par      mBR  nop un fetch_uI 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 
The first two moves retrieve target and save it for later use.  The first mBR decrements the sp by one word to point to the next empty word location in the stack.  The next mMOV points the memory to this empty stack word.  The mBR bop, incpc, points the p
c to the next in line uI.  This is followed by a mMOV which saves this pc value in the stack.  The next mMOV puts target in the pc thereby making it ready to jump to the first uI in the subroutine.  The next fetch_uI will fetch this first uI.  
\par \page Here is the status of memory after CALL executes and the subroutine executes but just before RET is executed.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24           }{\f3\fs24\ul mem_addr\tab contents of word         }{\f3\fs24 
\par pc\_\_\_>              ?
\par                     RET
\par           ...
\par           m+8       next uI code
\par           m+4       target
\par           m         uI code for CALL target
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 sp \_\_\_>             m+8 (the prior pc+4 value)
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 The program now executes the last uI in the called subroutine.  The last uI in the subroutine is RET.  RET returns the program to the next in line uI addr
ess which CALL target saved on the stack.  To achieve this RET pops the stack to reload the pc.  On exit from RET the next in line uI following CALL is executed.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 RET                 pc <\_\_ M[sp],  sp <\_\_ sp+4
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24         RET =  mMOV sp  mar r           (mar <\_\_ sp)
\par                mMOV mem pc  nop         (pc  <\_\_ m+8 the addr of \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab the next uI)
\par                mBR  incsp un fetch_uI   (sp <\_\_ sp+4 and exit)
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 Figure 2.26  Jump to a Subroutine
\par }\pard {\b\f3\fs24 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 \page 2.12.3 Jump to an Exception Service Routine}{\f3\fs24 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24      Example: Exceptions are hardware induced jumps.
\par               RETI  (the last uI in an interrupt service routine)
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 
A computer has three processing states; normal, exception, halted.  The normal state executes uI in user programs.  Halted is just that.  Exceptions are reset, external interrupt, software interrupt, trap, and other exceptional conditions.  Exception circ
uits and mI sequences process these events that occur outside of normal program execution.  These topics are covered later.  The algorithm (figure 2.27) is similar to the subroutine algorithm.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24      Save the address of the next in line uI.  
\par      Jump to the first uI in the exception service routine.
\par      Execute the service routine.
\par      Fetch the address of the saved next in line uI
\par      Resume executing uI from the next in line uI.     
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 Figure 2.27  Jump to an Exception Service Subroutine}{\f3\fs24 
\par }\pard {\f3\fs24 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par }\pard \sl-240\slmult0 {\f3\fs24 \page Exercises 2:
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Assume the uI is in the ir (fig 2.11).  List a sequence of RTL statements implementing the uI.  Use comments to give reasons for each rtl statement you use.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 2.1 ADD iw ry
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 2.2 AND abs_addr ry
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 2.3 SUBC rx ry
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 2.4 ADD rx *ry
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 2.5 XOR rx *ry(n)
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 2.6 XOR rx *\_ry
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 2.7 OR rx *ry+
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Assume 4 bit registers.  Contents of r3 r2 r1 r0 = A6F2 hex
\par                          Contents of r7 r6 r5 r4 = 8B79 hex
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 2.8 Use uI to write a program to calculate A6F2 plus 8B79.  Show all register contents before and after the program executes.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 2.9 Use uI to write a program to calculate A6F2 minus 8B79.  Show all register contents before and after the program executes.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 2.10 For problem 2.8 what are the NCZV values after each uI executes and why?
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 2.11 For problem 2.9 what are the NCZV values after each uI executes and why?
\par }\pard {\f3\fs24 
\par 
\par }\pard \sl-240\slmult0 {\f3\fs24 Use reasoning and examples to derive the cc equations of table 2.2.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 2.12 Unsigned compare cc LO, LS, HI, HS, EQ, NE
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 2.13 Signed compare cc LT, LE, GE, GT, EQ, NE
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 2.14 A study of the micro data path (fig 2.13).  Write a short      essay answering the questions.  
\par      
\par How many bits in the moff field?  
\par How many words in this range? Give decimal answer.  
\par How many lines in the moff bus to the 2x1 mux?
\par How many bits in the adder?
\par How many bits in the mpc?
\par How many address lines to the mROM?
\par How many address lines to the mROM?
\par How many bits in the mROM data word?
\par How many bits in the mIR data word?
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 \page 2.15 mDecode design.  Design a decoder for the opc field.  Assign names to the outputs.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 2.16 mDecode design.  Design a decoder for the selx, sely fields.  Assign names to the outputs.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 2.17 mDecode design.  Design a decoder for the ldz field.  Assign names to the outputs.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 2.18 mDecode design.  Design a decoder for the bop field.  Assign names to the outputs.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 2.19 What line does field adr control?  Make a truth table.  
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 2.20 What lines does field rw control?  Make a truth table.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 2.21 What lines does field selz control?  Make a truth table.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 2.22 What lines does field sh control?  Make a truth table.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 2.23 mCTRL design.  Design the mCTRL state machine per fig 2.18
\par      Show where outputs go to and where inputs come from.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 
2.24 mControl timing.  Calculate the minimum possible clock period      (fig 2.14) when  mROM taccess = 35ns, ff setup = 20ns,  ff      hold = 5ns, mDecode tprop = 30ns, alu and shifter tprops =      43ns.  There is no unique answer to this design exercis
e.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 \page 2.25 Write the mI list for ADDC rx ry
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 2.26 Write the mI list for SUB rx ry
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 2.27 Write the mI list for CMP rx ry
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 2.28 Write the mI list for ABS ry
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 2.29 Write the mI list for OR rx ry
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 2.30 Write the mI list for SRA rx ry
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 2.31 Write the mI list for XOR *rx ry
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 2.32 Write the mI list for CMP *\_rx ry
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 2.33 Write the mI list for ABS *ry+ 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 2.34 Write the mI list for SLL *rx(n) ry
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 2.35 Write the mI list for XOR rx *ry
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 2.36 Write the mI list for CMP rx *\_ry
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 2.37 Write the mI list for ABS *ry+
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 2.38 Write the mI list for SLL rx *ry(n)
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 2.39 Write the mI list for SLL *rx *ry
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 2.40 Write the mI list for ADDC *rx *\_ry
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 2.41 Write the mI list for AND *\_rx *ry
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 2.42 Write the mI list for MOV *rx(n) *\_ry
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 2.43 Write the mI list for SRA *rx *ry+
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 2.44 Write the mI list for CMP *\_rx *ry+
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 2.45 Write the mI list for MOV iw ry
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 2.46 Write the mI list for CMP iw ry
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 2.47 Write the mI list for SRL iw ry
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 2.48 Write the mI list for MOV iw *ry
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 2.49 Write the mI list for XOR iw *\_ry
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 2.50 Write the mI list for CMP iw *ry(n)
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 2.51 Write the mI list for ADD addr_abs ry
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 2.52 Write the mI list for AND rx addr_abs
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 \page 2.53 Write the mI list for SRL addr_abs *ry
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 2.54 Write the mI list for JMP addr_abs 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 2.55 Write the mI list for JRZ n
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 2.56 Write the mI list for JRNN n
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 2.57 Write the mI list for CALL ry
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 2.58 Write the mI list for CALL target
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 2.58 Write the mI list for RET
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 For the following problems see Table 2.11 and prior tables.}{\f3\fs24 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 2.59 Microcode the fields for mALU + r3 r14 r14 nop
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 2.60 Microcode the fields for mALU + mem ry mar r
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 2.61 Microcode the fields for mALU + rx mem mbr w
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 2.62 Microcode the fields for mMOV r9 mar r
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 2.63 Microcode the fields for mMOV mem rtemp nop
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 2.64 Microcode the fields for mBR nop un fetch_uI
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 2.65 Microcode the fields for mBR decsp z loop
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 2.66 Microcode the fields for mALU sub rx mem nop nop
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 2.67 Microcode the fields for mALU srl r4 r9 r4 nop
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 2.68 Microcode the fields for mALU + mem r7 mbr w
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 2.69 Microcode the fields for mMOV pc mar r
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 2.70 Microcode the fields for mBR nop nz exit
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 2.71 Microcode the fields for mALU + mem pc pc nop
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 2.72 Microcode the mI in the mI list for ADD r1 *r12+ (page 242)
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 2.73 Microcode the mI in the mI list for AND r7 *r2(n) (page 242)
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 2.74 Microcode the mI in the mI list for ADD *r7 *r12  (page 243)
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 2.75 Microcode the mI in the mI list for MOV iw r5 (page 244)
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 2.76 Microcode the mI in the mI list for ADD iw *r13 (page 245)
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 2.77 Microcode the mI in the mI list for ADD addr_abs *r6 (pg 246)
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 2.78 Microcode the mI in the mI list for ADD *\_r3 r4 (page 241)
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 \page }{\b\f3\fs24 Special problems 2:}{\f3\fs24 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 These reach back into digital design knowledge.  Schematics must meet digital design standard.  Use 74LSxxx or 74ALSxxx parts.
\par Reminder: bubble means asserted low.  Glue means simple gates.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 2.101 Design only the 12 lsb of register rtemp.  Use 173, 541
\par                 ______________
\par   x bus <\_+\_\_\_\_|              |<\_+\_\_\_\_ z bus
\par   y bus <\_+\_\_\_\_|   rtemp      |o\_\_\_\_\_o ldrt
\par    srty o\_\_\_\_\_o|              |
\par    srtx o\_\_\_\_\_o|             <|\_\_\_\_\_\_\_ clock
\par                |______________|
\par }\pard {\f3\fs24 
\par 
\par }\pard \sl-240\slmult0 {\f3\fs24 2.102 Design only the 12 lsb of register pc.  Use 163, 541
\par       What observation simplifies the incpc by 4 implementation?
\par                 ______________
\par   x bus <\_+\_\_\_\_|              |<\_+\_\_\_\_ z bus
\par   y bus <\_+\_\_\_\_|   pc         |o\_\_\_\_\_o ldpc
\par    spcy o\_\_\_\_\_o|              |o\_\_\_\_\_o incpc (by 4)  (careful!)
\par    spcx o\_\_\_\_\_o|             <|\_\_\_\_\_\_\_ clock
\par                |______________|
\par }\pard {\f3\fs24 
\par 
\par }\pard \sl-240\slmult0 {\f3\fs24 2.103 Design only the 12 lsb of register sp.  Use 169, 541, glue
\par                 ______________
\par   x bus <\_+\_\_\_\_|              |<\_+\_\_\_\_ z bus
\par   y bus <\_+\_\_\_\_|   sp         |o\_\_\_\_\_o ldsp
\par    sspy o\_\_\_\_\_o|              |o\_\_\_\_\_o incsp (by 4)  (careful!)
\par    sspx o\_\_\_\_\_o|              |o\_\_\_\_\_o decsp (by 4)
\par                |             <|\_\_\_\_\_\_\_ clock
\par                |______________|
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 2.104 Design the NCZV status logic.  Use 00, 02, 04, 133, 138.
\par      a) write the equations for N, C, Z, V
\par      b) design 4 circuits implementing the 4 equations
\par         (must use 138 and glue logic to implement V).
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24      Simplifying assumption: 16 bit word (not 32 bit).
\par      
\par      Note: aF, bF are alu msb inputs (see fig 2.11)
\par            fF is alu msb output.  
\par                           ______________
\par                      16  |              |
\par  shifter output bus \_\_+\_>|  NCZV logic  |\_\_\_> N
\par        carry output \_\_\_\_>|              |\_\_\_> C
\par          aF, bF, fF \_\_+\_>|              |\_\_\_> Z
\par                       3  |              |\_\_\_> V
\par                          |______________|
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 \page 2.105 Design the mcc_report cc logic by implementing the equations implied in table 2.2.  Use 00, 02, 04, 86, 151, 153
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Number the cc from 00 to 19 hex where the cc un is number 00.  
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 The five bit cc selection code is on the 5 mj lines.  
\par For example: when mj = 09 hex    mcc_report = NV + N'V'
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24                 ______________
\par         N \_\_\_\_>|              |
\par         C \_\_\_\_>|  mcc_report  |\_\_\_\_> mcc_report
\par         Z \_\_\_\_>|  logic       |
\par         V \_\_\_\_>|              |<\_+\_\_ mj (j=0 1 2 3 4)
\par                |______________|      5 bit mcc select code
\par }\pard {\f3\fs24 
\par 
\par 
\par }\pard \sl-240\slmult0 {\f3\fs24 2.106 Design the mData Path adder logic.  Use 02, 157, 283
\par                           ______________
\par                          |              |
\par          mcc_report \_\_\_\_>| adder logic  |\_\_+\_> sum output
\par                 mBR \_\_\_\_>|              |
\par                 one \_+\_\_>|              |
\par                moff \_+\_\_>|              |
\par                 mPC \_+\_\_>|______________|
\par }\pard {\f3\fs24 
\par 
\par }}