{\rtf1\ansi \deff4\deflang1033{\fonttbl{\f0\froman\fcharset0\fprq2 Tms Rmn;}{\f1\froman\fcharset2\fprq2 Symbol;}{\f2\fswiss\fcharset0\fprq2 Helv;}{\f3\fmodern\fcharset0\fprq1 Courier{\*\falt Courier};}
{\f4\froman\fcharset0\fprq2 Times New Roman;}{\f5\fswiss\fcharset0\fprq2 Arial;}{\f6\froman\fcharset0\fprq2 MS Serif;}{\f7\fswiss\fcharset0\fprq2 MS Sans Serif;}{\f8\froman\fcharset0\fprq2 Times;}{\f9\fswiss\fcharset0\fprq2 Helvetica;}
{\f10\fswiss\fcharset0\fprq2 System;}{\f11\fmodern\fcharset0\fprq1 Courier New;}{\f12\fdecor\fcharset2\fprq2 ZapfDingbats;}{\f13\fnil\fcharset2\fprq2 Marlett;}{\f14\fswiss\fcharset238\fprq2 Arial CE;}{\f15\fswiss\fcharset204\fprq2 Arial CYR;}
{\f16\fswiss\fcharset161\fprq2 Arial Greek;}{\f17\fswiss\fcharset162\fprq2 Arial TUR;}{\f18\fswiss\fcharset186\fprq2 Arial Baltic;}{\f19\fmodern\fcharset238\fprq1 Courier New CE;}{\f20\fmodern\fcharset204\fprq1 Courier New CYR;}
{\f21\fmodern\fcharset161\fprq1 Courier New Greek;}{\f22\fmodern\fcharset162\fprq1 Courier New TUR;}{\f23\fmodern\fcharset186\fprq1 Courier New Baltic;}{\f24\fmodern\fcharset0\fprq1 Lucida Console;}{\f25\froman\fcharset238\fprq2 Times New Roman CE;}
{\f26\froman\fcharset204\fprq2 Times New Roman CYR;}{\f27\froman\fcharset161\fprq2 Times New Roman Greek;}{\f28\froman\fcharset162\fprq2 Times New Roman TUR;}{\f29\froman\fcharset186\fprq2 Times New Roman Baltic;}{\f30\fnil\fcharset2\fprq2 Wingdings;}
{\f31\fswiss\fcharset0\fprq2 Verdana;}{\f32\fswiss\fcharset0\fprq2 Arial Black;}{\f33\fscript\fcharset0\fprq2 Comic Sans MS;}{\f34\froman\fcharset0\fprq2 Georgia;}{\f35\fswiss\fcharset0\fprq2 Franklin Gothic Medium;}
{\f36\froman\fcharset0\fprq2 Palatino Linotype;}{\f37\fswiss\fcharset0\fprq2 Tahoma;}{\f38\fswiss\fcharset0\fprq2 Trebuchet MS;}{\f39\froman\fcharset2\fprq2 Webdings;}{\f40\fscript\fcharset1\fprq2 Estrangelo Edessa;}{\f41\fnil\fcharset1\fprq2 Gautami;}
{\f42\fnil\fcharset1\fprq2 Latha;}{\f43\fnil\fcharset1\fprq2 Mangal;}{\f44\fnil\fcharset1\fprq2 MV Boli;}{\f45\fnil\fcharset1\fprq2 Raavi;}{\f46\fnil\fcharset1\fprq2 Shruti;}{\f47\fnil\fcharset1\fprq2 Tunga;}{\f48\froman\fcharset0\fprq2 Sylfaen;}
{\f49\fswiss\fcharset0\fprq2 Microsoft Sans Serif;}{\f50\fswiss\fcharset0\fprq2 Arial Narrow;}{\f51\fdecor\fcharset0\fprq2 Curlz MT;}{\f52\froman\fcharset0\fprq2 Engravers MT;}{\f53\fswiss\fcharset0\fprq2 Franklin Gothic Book;}
{\f54\fswiss\fcharset0\fprq2 Franklin Gothic Demi Cond;}{\f55\fswiss\fcharset0\fprq2 Franklin Gothic Heavy;}{\f56\fswiss\fcharset0\fprq2 Franklin Gothic Medium Cond;}{\f57\fswiss\fcharset0\fprq2 Century Gothic;}
{\f58\fscript\fcharset0\fprq2 Edwardian Script ITC;}{\f59\fdecor\fcharset0\fprq2 Jokerman;}{\f60\fdecor\fcharset0\fprq2 Juice ITC;}{\f61\fswiss\fcharset0\fprq2 Lucida Sans Unicode;}{\f62\fscript\fcharset0\fprq2 Mistral;}
{\f63\fmodern\fcharset0\fprq2 OCR A Extended;}{\f64\froman\fcharset0\fprq2 Rockwell;}{\f65\froman\fcharset2\fprq2 Wingdings 2;}{\f66\froman\fcharset2\fprq2 MT Extra;}{\f67\fswiss\fcharset0\fprq2 Impact;}{\f68\fmodern\fcharset2\fprq1 MS LineDraw;}
{\f69\fdecor\fcharset0\fprq2 Algerian;}{\f70\fswiss\fcharset0\fprq2 Arial Rounded MT Bold;}{\f71\froman\fcharset0\fprq2 Bookman Old Style;}{\f72\fdecor\fcharset0\fprq2 Braggadocio;}{\f73\fswiss\fcharset0\fprq2 Britannic Bold;}
{\f74\fscript\fcharset0\fprq2 Brush Script MT;}{\f75\fdecor\fcharset0\fprq2 Colonna MT;}{\f76\fdecor\fcharset0\fprq2 Desdemona;}{\f77\froman\fcharset0\fprq2 Footlight MT Light;}{\f78\fdecor\fcharset0\fprq2 Kino MT;}
{\f79\froman\fcharset0\fprq2 Wide Latin;}{\f80\fscript\fcharset0\fprq2 Matura MT Script Capitals;}{\f81\fdecor\fcharset0\fprq2 Playbill;}{\f82\fnil\fcharset0\fprq2 OpenSymbol;}{\f83\fswiss\fcharset2\fprq2 WP Phonetic;}
{\f84\fnil\fcharset2\fprq2 WP MathExtendedB;}{\f85\fmodern\fcharset0\fprq1 WP BoxDrawing;}{\f86\fnil\fcharset2\fprq2 WP IconicSymbolsB;}{\f87\fnil\fcharset2\fprq2 WP Greek Helve;}{\f88\fnil\fcharset2\fprq2 WP MathExtendedA;}
{\f89\froman\fcharset2\fprq2 WP CyrillicA;}{\f90\fnil\fcharset2\fprq2 WP Japanese;}{\f91\fnil\fcharset2\fprq2 WP MathB;}{\f92\fnil\fcharset2\fprq2 WP IconicSymbolsA;}{\f93\fnil\fcharset2\fprq2 WP Arabic Sihafa;}
{\f94\froman\fcharset2\fprq2 WP MultinationalA Roman;}{\f95\fnil\fcharset0\fprq2 WP CyrillicB;}{\f96\fnil\fcharset2\fprq2 WP MultinationalB Roman;}{\f97\fmodern\fcharset2\fprq1 WP Greek Courier;}{\f98\fnil\fcharset2\fprq2 WP MathA;}
{\f99\fnil\fcharset2\fprq2 WP ArabicScript Sihafa;}{\f100\fnil\fcharset2\fprq2 WP Greek Century;}{\f101\fnil\fcharset2\fprq2 WP TypographicSymbols;}{\f102\fnil\fcharset2\fprq2 WP Hebrew David;}{\f103\fnil\fcharset2\fprq2 WP MultinationalA Helve;}
{\f104\fnil\fcharset2\fprq2 WP MultinationalB Helve;}{\f105\fmodern\fcharset2\fprq1 WP MultinationalA Courier;}{\f106\fmodern\fcharset2\fprq1 WP MultinationalB Courier;}{\f107\fscript\fcharset0\fprq2 Ribbon131 Bd BT;}
{\f108\froman\fcharset0\fprq2 Humanst521 Lt BT;}{\f109\froman\fcharset0\fprq2 GeoSlab703 Lt BT;}{\f110\fswiss\fcharset0\fprq2 Swis721 BlkEx BT;}{\f111\fswiss\fcharset0\fprq2 Humanst521 Cn BT;}{\f112\fdecor\fcharset0\fprq2 Onyx BT;}
{\f113\fdecor\fcharset0\fprq2 CaslonOpnface BT;}{\f114\fswiss\fcharset0\fprq2 EngraversGothic BT;}{\f115\fscript\fcharset0\fprq2 ShelleyVolante BT;}{\f116\froman\fcharset0\fprq2 BernhardMod BT;}{\f117\froman\fcharset0\fprq2 Arrus BT;}
{\f118\fscript\fcharset0\fprq2 OzHandicraft BT;}{\f119\fnil\fcharset0\fprq2 Sydnie;}{\f120\froman\fcharset255\fprq2 Roman;}{\f121\fscript\fcharset255\fprq2 Script;}{\f122\fmodern\fcharset255\fprq2 Modern;}{\f123\fswiss\fcharset0\fprq1 MS Dialog;}
{\f124\fmodern\fcharset0\fprq0 Elite;}{\f125\fmodern\fcharset0\fprq0 Prestige;}{\f126\fswiss\fcharset0\fprq0 Letter Gothic;}{\f127\fmodern\fcharset0\fprq0 GothicPS;}{\f128\fmodern\fcharset0\fprq0 CubicPS;}{\f129\fmodern\fcharset0\fprq0 LinePrinter;}
{\f130\fmodern\fcharset0\fprq0 AvantGarde;}{\f131\fswiss\fcharset0\fprq0 Helvetica-Narrow;}{\f132\fmodern\fcharset0\fprq0 Metro;}{\f133\fswiss\fcharset0\fprq0 Presentation;}{\f134\fmodern\fcharset0\fprq0 APL;}{\f135\fmodern\fcharset0\fprq0 OCRA;}
{\f136\fmodern\fcharset0\fprq0 OCRB;}{\f137\froman\fcharset0\fprq0 Bookman;}{\f138\froman\fcharset0\fprq0 Madaleine;}{\f139\froman\fcharset0\fprq0 ZapfHumanist;}{\f140\froman\fcharset0\fprq0 Classic;}{\f141\froman\fcharset0\fprq0 Roman f;}
{\f142\froman\fcharset0\fprq0 Roman g;}{\f143\froman\fcharset0\fprq0 Roman h;}{\f144\froman\fcharset0\fprq0 NewCenturySchlbk;}{\f145\froman\fcharset0\fprq0 Palatino;}{\f146\froman\fcharset0\fprq0 Souvenir;}{\f147\froman\fcharset0\fprq0 Garamond;}
{\f148\froman\fcharset0\fprq0 Caledonia;}{\f149\froman\fcharset0\fprq0 Bodini;}{\f150\froman\fcharset0\fprq0 University;}{\f151\fscript\fcharset0\fprq0 ScriptPS;}{\f152\fscript\fcharset0\fprq0 Script c;}{\f153\fscript\fcharset0\fprq0 Script d;}
{\f154\fscript\fcharset0\fprq0 Commercial Script;}{\f155\fscript\fcharset0\fprq0 Park Avenue;}{\f156\fscript\fcharset0\fprq0 Coronet;}{\f157\fscript\fcharset0\fprq0 Script h;}{\f158\fscript\fcharset0\fprq0 Greek;}{\f159\froman\fcharset0\fprq0 Kana;}
{\f160\froman\fcharset0\fprq0 Hebrew;}{\f161\froman\fcharset0\fprq0 Roman s;}{\f162\froman\fcharset0\fprq0 Russian;}{\f163\froman\fcharset0\fprq0 Roman u;}{\f164\froman\fcharset0\fprq0 Roman v;}{\f165\froman\fcharset0\fprq0 Roman w;}
{\f166\fdecor\fcharset0\fprq0 Narrator;}{\f167\fdecor\fcharset0\fprq0 Emphasis;}{\f168\fdecor\fcharset0\fprq0 ZapfChancery;}{\f169\fdecor\fcharset0\fprq0 Decor d;}{\f170\fdecor\fcharset0\fprq0 Old English;}{\f171\fdecor\fcharset0\fprq0 Decor f;}
{\f172\fdecor\fcharset0\fprq0 Decor g;}{\f173\fdecor\fcharset0\fprq0 Cooper Black;}{\f174\fnil\fcharset0\fprq0 Math7;}{\f175\fnil\fcharset0\fprq0 Math8;}{\f176\fnil\fcharset0\fprq0 EAN;}{\f177\fnil\fcharset0\fprq0 PCline;}
{\f178\fnil\fcharset0\fprq0 Tech h;}{\f179\fmodern\fcharset0\fprq0 Courier Bold{\*\falt Courier};}{\f180\fmodern\fcharset0\fprq0 Courier Oblique{\*\falt Courier};}}{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;
\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;
\red128\green128\blue128;\red192\green192\blue192;}{\stylesheet{\f4\fs20 \snext0 Normal;}{\*\cs10 \additive Default Paragraph Font;}{\s15\tqc\tx4320\tqr\tx8640 \f4\fs20 \sbasedon0\snext15 header;}{\s16\tqc\tx4320\tqr\tx8640 \f4\fs20 \sbasedon0\snext16 
footer;}}{\info{\author Nicholas L. Pappas, Ph.D.}{\creatim\yr1910\mo2\dy1}{\revtim\yr1910\mo2\dy1}{\version1}{\edmins0}{\nofpages0}{\nofwords0}{\nofchars0}{\vern49203}}\margl1440\margr1152\margt720\margb720 
\facingp\ftnbj\aenddoc\ftnrestart\pgnstart201\notabind\noextrasprl\sprsspbf\brkfrm\hyphcaps0 \fet0\sectd \sbknone\pgnrestart\pgnstarts201\linex576\footery480\endnhere {\headerl \pard\plain \qj\li-1440\ri-1152\sl-240\slmult0 \f4\fs20 {\f3\fs24 
                                Computer Architecture and Design
\par }}{\headerr \pard\plain \qj\li-1440\ri-1152\sl-240\slmult0 \f4\fs20 {\f3\fs24                                 Computer Architecture and Design
\par }}{\footerl \pard\plain \qj\li-1440\ri-1152\sl-240\slmult0 \f4\fs20 {\f3\fs24  (C) Copyright 1991 Nicholas. L. Pappas, PhD.  910801          \chpgn 
\par }}{\footerr \pard\plain \qj\li-1440\ri-1152\sl-240\slmult0 \f4\fs20 {\f3\fs24  (C) Copyright 1991 Nicholas. L. Pappas, PhD.  910801          \chpgn 
\par }}{\*\pnseclvl1\pnucrm\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl2\pnucltr\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl3\pndec\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl4\pnlcltr\pnstart1\pnindent720\pnhang{\pntxta )}}
{\*\pnseclvl5\pndec\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl6\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl8
\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}\pard\plain \sl-240\slmult0 \f4\fs20 {\b\f3\fs24 2. CISC Computers}{\f3\fs24 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 2.1  Address Modes
\par 2.2  CISC uI Set
\par 2.3  Status Logic and cc
\par 2.4  From uI to User Data Path
\par 2.5  Microinstructions
\par 2.6  Micro Data Path
\par 2.7  Micro Control
\par 2.8  Microprogramming
\par      2.8.1 Designer's Programming Model
\par      2.8.2 uI Operands
\par      2.8.3 mI Operands and mI_Word Fields
\par      2.8.4 mI Use the Data Paths
\par 2.9  Microprogramming Operators
\par 2.10 Microprogramming Address Modes
\par      2.10.1 Register to Register
\par      2.10.2 Memory to Register
\par      2.10.3 Register to Memory
\par      2.10.4 Memory to Memory
\par      2.10.5 Literal to Register
\par      2.10.6 Literal to Memory
\par      2.10.7 Absolute Address Mode
\par 2.11 Microprogramming Moves
\par 2.12 Microprogramming Program Control
\par      2.12.1 Jump
\par      2.12.2 Jump to a subroutine
\par      2.12.3 Jump to an Exception Service Routine
\par }\pard {\f3\fs24 
\par 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 Overview:}{\f3\fs24 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 
We start with the complex instruction set computer (CISC) as we pull out of thin air a minimum CISC user instruction (uI) set to use as the basis of a design.  Then address modes are defined and explained.  We show what address modes do and how they contr
ibute to the complexity of CISC machines.  Next, the role status logic plays in program control is presented.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 At this point we start from the uI set and evolve the user data path.  The data path is shown to be some set of combinational circuit blocks and sequential circuit blocks interconnected by data busses.  
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 
Starting from the data path control lines we work our way through the micro data path required to orchestrate these lines and the microcode stored in the micro data path.  Then we work out the state machine controlling the micro data path.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Finally, extensive microprogramming demonstrates that any uI can be represented by a list of microinstructions (mI) drawn from the set mALU, mMOV, mBR, mNOP in some combination.  
\par }\pard {\f3\fs24 
\par 
\par }\pard \sl-240\slmult0 {\f3\fs24 \page }{\b\f3\fs24 Introduction}{\f3\fs24 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 
Complex instruction set computers (CISC) have a large number of user instructions uI and perhaps as many as ten addressing modes.  Addressing modes provide various ways for uI to access data. A two operand uI with 7 addressing modes is potentially 42 diff
erent uI. The number 42 is explained below.  If there are 100 uI and 7 addressing modes there are 4200 possible uI available to the user.  The complex nature of the uI with various addressing m
odes requires microprogramming because in general CISC uI cannot be executed in one computer cycle.  A uI code fragment using uI from Table 2.1 illustrates the complexity of uI with two operands and seven address modes.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24           MOV  *\_r}{\f3\fs24\dn60 3}{\f3\fs24   r}{\f3\fs24\dn60 A}{\f3\fs24 
\par           ADD  r}{\f3\fs24\dn60 A}{\f3\fs24    *r}{\f3\fs24\dn60 2}{\f3\fs24 +
\par           MOV  FFFF  *r}{\f3\fs24\dn60 2}{\f3\fs24 +
\par           MODU *\_r}{\f3\fs24\dn60 2}{\f3\fs24   r}{\f3\fs24\dn60 A}{\f3\fs24 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Now we start the process of designing a 32 bit CISC computer whose address bus and data bus are each 32 bits wide and whose memory is }{\b\f3\fs24 byte}{\f3\fs24  addressable.
\par }\pard {\f3\fs24 
\par 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 2.1 Address Modes}{\f3\fs24 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Address modes defi
ne how an architecture calculates the address of the data to be accessed.  [N address modes contribute to the complexity of CISC machines.]  Each uI operand uses any of the n address modes.  A two operand uI uses address modes in n(n\_
1) combinations because the immediate mode cannot be a destination.  
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 On the other hand address modes reduce the number of uI needed in a program.  Program instruction counts are reduced because each mI list for a complex address mode uI is a small program in itself. Basically
 address modes make programming easier.  The price paid is learning how to use the address modes.  A greater price is learning what address modes have been implemented for which uI.  Know that not all address modes are implemented for all uI for practical
 reasons.  This becomes clear as we proceed.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 The data is in memory.  This is basically why discussions of instruction sets are preoccupied with the various processes of loading data from memory and storing data in memory.  Please keep in mind that address 
modes are more readily understood when you repeatedly ask
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24      1. Where is the address stored?
\par      2. Where is the data stored?
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 \page }{\b\f3\fs24 Figure 2.1 Address Mode Examples}{\f3\fs24 
\par }\pard {\f3\fs24 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par }\pard \sl-240\slmult0 {\f3\fs24 \page 
Effective address (ea) is a useful notation for the memory location actually accessed by a uI.  The concept of effective address provides greater clarity when discussing memory references.  This is because the actual address calculations are not germane 
to many discussions.  
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Literal is another generic term for program constants that are assigned memory locations.  Literals are placed in memory locations following the memory location of the uI code word associated with the literal.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 
A simple, yet useful, functional model for reading a memory is that a memory is a combinational circuit with storage registers whose input is an address and whose output is a data word.  There is one data word for each address.  Furthermore the input addr
ess can access, or deliver, only one data word at a time.  The memory is conveniently visualized as a bank of }{\b\f3\fs24 registers }{\f3\fs24 that can be accessed only one register at a time.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 The simple functional model for writing memory is that a memory is a combinational circuit with registers whose inputs are an address and a data word.  The data word is stored in the addressed memory register.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Programs are lists of user instructions uI and the associated literals stored in memory.  One uI or one literal is stored in each memory register allocated to the program.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 
Why the following addressing modes exist is a series of programming questions whose answers we only hint at as we move on.  In the following please keep in mind we need to write memory one time to store the result if a *register is the destination.
\par }\pard {\f3\fs24 
\par 
\par }\pard \sl-240\slmult0 {\f3\fs24 1. Immediate addressing: \tab ADD iw r}{\f3\fs24\dn60 y}{\f3\fs24 \tab \tab (figure 2.1a)
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 The easiest way to reach the data is to make it part of the instruction.  We can do this in two ways: incorporate the immediate word iw into the uI code word or let iw be a literal following the uI code word i
n memory.  When the iw is a small number represented by say eight bits the iw is usually incorporated into the uI code word.  We will not do that in this computer.  We will do that later when we discuss the RISC computer.  
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 The iw is one of the uI operands.  Literal iw can only be source data.  Can you store data in an iw?  Not really.  This is why there are n\_1 choices for uI operands that are destinations.  Iw cannot be a destination.

\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 This is important:  we choose to have the literal iw follow the uI co
de word in memory.  The uI code word is at address m, and iw is at m+4.  Plus 4 is used because 32 bit words are four memory bytes and the memory is byte addressable. 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Read memory two times to fetch the uI and then the iw.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 \page 2. Absolute addressing:       AND addr_abs r}{\f3\fs24\dn60 y}{\f3\fs24 \tab (figure 2.1b)
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 
Another easy way to reach data makes one operand the address.  In our 32 bit computer the literal addr_abs uses one 32 bit word to make up a 32 bit address.  Addr_abs follows the uI code word in memory.  Note that addr_abs ca
n be the address of the source data or the destination data.  The uI code word is at address m,  the addr_abs word is at address m+4.  
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Read memory two times to fetch the uI and then the addr_abs.
\par Read memory a third time to fetch the data at the addr_abs.
\par }\pard {\f3\fs24 
\par 
\par }\pard \sl-240\slmult0 {\f3\fs24 3. Register direct:\tab \tab \tab SUBC r}{\f3\fs24\dn60 x}{\f3\fs24   r}{\f3\fs24\dn60 y}{\f3\fs24  \tab \tab (figure 2.1c)
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 The set of registers in a computer is an address space separate from the memory.  The register's number is the register address.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Registers are used because their access times are much shorter than memory access times.  In this straightforward mode the data is in the registers.  The uI code word is at address m.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Read memory one time to fetch the uI.
\par }\pard {\f3\fs24 
\par 
\par }\pard \sl-240\slmult0 {\f3\fs24 4. Register indirect:\tab \tab ADD r}{\f3\fs24\dn60 x}{\f3\fs24  *r}{\f3\fs24\dn60 y}{\f3\fs24 \tab \tab (figure 2.1d)
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 The * symbol means indirect.  With direct addressing the given address is the data address.  With indirect addressing the given address is the address of the data address.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Any confusion that arises here usually stems from not recognizing that the register symbols r}{\f3\fs24\dn60 x}{\f3\fs24 , r}{\f3\fs24\dn60 y}{\f3\fs24  are addresses.  R}{\f3\fs24\dn60 x}{\f3\fs24 , the first operan
d of ADD r}{\f3\fs24\dn60 x}{\f3\fs24  *r}{\f3\fs24\dn60 y}{\f3\fs24 , is the address of the data in r}{\f3\fs24\dn60 x}{\f3\fs24 .  The second operand r}{\f3\fs24\dn60 y}{\f3\fs24  is the address of the address stored in r}{\f3\fs24\dn60 y}{\f3\fs24 
.  The content of r}{\f3\fs24\dn60 y}{\f3\fs24 , (r}{\f3\fs24\dn60 y}{\f3\fs24 ), is an address pointing to the data.  The uI code word is at address m in the program space.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 We repeat the above comments in a different way.  When specific register r}{\f3\fs24\dn60 5}{\f3\fs24  is used the symbol r}{\f3\fs24\dn60 5}{\f3\fs24  is the given address.  The address r}{\f3\fs24\dn60 5}{\f3\fs24 
 points to the data in r}{\f3\fs24\dn60 5}{\f3\fs24 .  The *r}{\f3\fs24\dn60 9}{\f3\fs24  symbol means the contents of register r}{\f3\fs24\dn60 9}{\f3\fs24  are a data address.  The symbol for the contents of r}{\f3\fs24\dn60 9}{\f3\fs24  is (r}{
\f3\fs24\dn60 9}{\f3\fs24 ).  Very Important: uI execution does not modify *registers.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Read memory twice to fetch the uI and then the data.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 \page 5. Register indirect with signed displacement n:
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 \tab \tab \tab \tab \tab \tab XOR r}{\f3\fs24\dn60 x}{\f3\fs24  *r}{\f3\fs24\dn60 y}{\f3\fs24 (n)\tab \tab (figure 2.1e)
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 The destination data address is (r}{\f3\fs24\dn60 y}{\f3\fs24 ) plus n. [A source of confusion is that this is written in practice as r}{\f3\fs24\dn60 y}{\f3\fs24 +n.]  The sum, contents of r}{\f3\fs24\dn60 y}{\f3\fs24 
 plus n, is an address pointing to the data.  The literal n is a word and literal n follows the uI code word in memory.  The uI code word is at address m, and the index n is at address m+4.  The contents of r}{\f3\fs24\dn60 y}{\f3\fs24 
 is sometimes called a base address to which the index n is added.  Very Important: uI execution does not modify *registers.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Read memory three times to fetch the uI, n, and then the data.
\par }\pard {\f3\fs24 
\par 
\par }\pard \sl-240\slmult0 {\f3\fs24 6. Register indirect with predecrement: 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 \tab \tab \tab \tab \tab \tab XOR r}{\f3\fs24\dn60 x}{\f3\fs24  *\_r}{\f3\fs24\dn60 y}{\f3\fs24 \tab \tab (figure 2.1f)
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 
This mode and mode 7. allow a user to implement a stack in memory (section 2.12.2).  If you first subtract 4 from the address in the *register then the rest is a repeat of the register indirect mode.  The decremented address in r}{\f3\fs24\dn60 y}{
\f3\fs24  is the data address.  The uI code word is at address m.  Here the *-register is modified by \_4.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Read memory two times to fetch the uI and then the data.
\par }\pard {\f3\fs24 
\par 
\par }\pard \sl-240\slmult0 {\f3\fs24 7. Register indirect with postincrement: 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 \tab \tab \tab \tab \tab \tab XOR r}{\f3\fs24\dn60 x}{\f3\fs24  *r}{\f3\fs24\dn60 y}{\f3\fs24 +\tab \tab (figure 2.1g)
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 This is another register indirect mode with the final additional operation of adding a 4 to (r}{\f3\fs24\dn60 y}{\f3\fs24 ).  Address in r}{\f3\fs24\dn60 y}{\f3\fs24 
 is the data address.  The uI code word is at address m.  Here the *register+ is modified by +4.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Read memory twice to fetch the uI and then the data.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 \page }{\b\f3\fs24 2.2 CISC uI Set}{\f3\fs24 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 We pull out of thin air a minimum CISC uI set (table 2.1) to use as a vehicle illustrating the basic principles involved.  The uI set is augmented by a programming model (figure 2.12).
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 We arbitrarily choose a two address format for the CISC uI set.  Each uI processes two opera
nds.  For a different experience the RISC uI set has a three address format (Chapter 3).  [An operand is a quantity on which a mathematical operation is performed.]  A brief discussion of the uI set follows.
\par }\pard {\f3\fs24 
\par 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 uI Codeword Format:}{\f3\fs24 
  The prior address mode discussion shows how the CISC uI set uses literals to implement some operands.  These literal words follow uI words in the program memory space.  Therefore literals are not a part of any uI codeword.  This simplifies the uI coding
.  Only opcode, r}{\f3\fs24\dn60 x}{\f3\fs24 , and r}{\f3\fs24\dn60 y}{\f3\fs24  fields (partial words) are required.  The opcode specifies the uI function and the operands' address modes.  This format is one of many possible formats.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24                |\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_|\_\_\_\_\_\_|\_\_\_\_\_\_|
\par uI codeword    |       opcode        |  r}{\f3\fs24\dn60 y}{\f3\fs24   |  r}{\f3\fs24\dn60 x}{\f3\fs24   |
\par                |\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_|\_\_\_\_\_\_|\_\_\_\_\_\_|
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 Register Transfer Language:  }{\f3\fs24 Register transfer language (RTL) symbols taken from Table 2.3 are used in Table 2.1 to define the function of each uI.  The left arrow <\_\_\_ is the replacement symbol.  T
he contents of register P are replaced by the contents of register Q in P <\_\_\_ Q.  Keep in mind that any memory location is also a }{\b\f3\fs24 register}{\f3\fs24 
.  The symbol for the contents of memory location x is M[x] where x is the address.  Various memory transfer statements are 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 \tab M[x] <\_\_\_ Q  \tab \tab (register to memory)
\par \tab P    <\_\_\_ M[x]  \tab (memory to register)
\par \tab M[x] <\_\_\_ M[y]\tab \tab (memory to memory)
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 In a bit-addressable-memory groups of n bits are copied from M[x] to M[y] by the symbol <\_\_\_}{\f3\fs24\dn60 n}{\f3\fs24 .  Our convention is that the addresses o
f the least significant bits in the n bit groups are x and y.  Note that n is not limited to word length.  
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Fields are partial words of 1 to 31 bits when words are 32 bits long.  There are several symbols representing field copying.  The single subscript symbol W}{\f3\fs24\dn60 m}{\f3\fs24 
 represents bit m in a word.  The double dot range symbol W}{\f3\fs24\dn60 m..n}{\f3\fs24  defines a copy of 2 to 31 bits.  And the superscript symbol b}{\f3\fs24\up6 n}{\f3\fs24  defines a field of n copies of bit b.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 The ## symbol concatenates two fields or words.  Finally << and >> are the left and right shift symbols.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 \page }{\b\f3\fs24 Operators: }{\f3\fs24  The typical operator ADD r}{\f3\fs24\dn60 x}{\f3\fs24  r}{\f3\fs24\dn60 y}{\f3\fs24  adds the source data in r}{\f3\fs24\dn60 x}{\f3\fs24  to the destination data in r}{
\f3\fs24\dn60 y}{\f3\fs24 , and stores the sum in r}{\f3\fs24\dn60 y}{\f3\fs24 .  The register transfer language statement for this operation is read from right to left.  
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 \tab r}{\f3\fs24\dn60 y}{\f3\fs24  <\_\_ r}{\f3\fs24\dn60 y}{\f3\fs24  + r}{\f3\fs24\dn60 x}{\f3\fs24  
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Add the contents of r}{\f3\fs24\dn60 x}{\f3\fs24  to the contents of r}{\f3\fs24\dn60 y}{\f3\fs24  and perform a data transfer of the sum to r}{\f3\fs24\dn60 y}{\f3\fs24 .  Another point of view is that the contents of r}{
\f3\fs24\dn60 y}{\f3\fs24  are replaced by the sum of the contents of r}{\f3\fs24\dn60 y}{\f3\fs24  and the contents of r}{\f3\fs24\dn60 x}{\f3\fs24 .  A more concise statement is that r}{\f3\fs24\dn60 y}{\f3\fs24  is replaced by r}{\f3\fs24\dn60 y}{
\f3\fs24  plus r}{\f3\fs24\dn60 x}{\f3\fs24 .  In this RTL statement the fact that registers' contents are manipulated is understood.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 R}{\f3\fs24\dn60 y}{\f3\fs24  and, or r}{\f3\fs24\dn60 x}{\f3\fs24  may be replaced by ea.  The symbol ea represents one of the seven address modes where subscript s is replaced by x or y.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24      iw   addr_abs    r}{\f3\fs24\dn60 s}{\f3\fs24     *r}{\f3\fs24\dn60 s}{\f3\fs24     *r}{\f3\fs24\dn60 s}{\f3\fs24 (n)    *\_r}{\f3\fs24\dn60 s}{\f3\fs24     *r}{\f3\fs24\dn60 s}{\f3\fs24 +
\par }\pard {\f3\fs24 
\par 
\par }\pard \sl-240\slmult0 {\f3\fs24 The RTL statement can be conditional like the IF THEN form describing ABS r}{\f3\fs24\dn60 y}{\f3\fs24 .
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 ABS r}{\f3\fs24\dn60 y}{\f3\fs24          If r}{\f3\fs24\dn60 y}{\f3\fs24  < 0 then r}{\f3\fs24\dn60 y}{\f3\fs24  <\_\_\_ \_r}{\f3\fs24\dn60 y}{\f3\fs24 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 For any address mode perhaps the following format clearly describes the function of a uI such as ABS *\_r}{\f3\fs24\dn60 s}{\f3\fs24  where dest_data is the data at the effective address ea.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 ABS ea         If dest_data < 0 then ea <\_\_\_ \_dest_data
\par and in concise notation
\par ABS ea         If ea        < 0 then ea <\_\_\_ \_ea
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 DIV computes the quotient q and MOD computes the remainder r where 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24      r}{\f3\fs24\dn60 y}{\f3\fs24 /r}{\f3\fs24\dn60 x}{\f3\fs24  = q + r/r}{\f3\fs24\dn60 x}{\f3\fs24 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 MUL r}{\f3\fs24\dn60 x}{\f3\fs24  r}{\f3\fs24\dn60 y}{\f3\fs24   of two 32 bit words produces a 64 bit product which is stored, by definition, in r}{\f3\fs24\dn60 y}{\f3\fs24  and r}{\f3\fs24\dn60 y+1}{\f3\fs24 .
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Negation NEG forms the 2's complement whereas logical NOT forms the 1's complement.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Shift operations use the point\_to\_the\_left symbol << for shift left and the point\_to\_the\_right symbol >> for shift right.  After the word is shifted the vacated bits are filled according to some rule.  
\par The expression r}{\f3\fs24\dn60 y}{\f3\fs24  << r}{\f3\fs24\dn60 x}{\f3\fs24  means shift the contents of r}{\f3\fs24\dn60 y}{\f3\fs24  left by the numerical amount r}{\f3\fs24\dn60 x}{\f3\fs24 
 mod 32.  Mod 32 because this is a 32 bit computer.  Clearly any shift of more than 32 bits is implemented by a shift of r}{\f3\fs24\dn60 x}{\f3\fs24  mod 32.  Here are two examples.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 SLL r}{\f3\fs24\dn60 x}{\f3\fs24  r}{\f3\fs24\dn60 y}{\f3\fs24         ry <\_\_ ry << rx     (zero fill)
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 SRA r}{\f3\fs24\dn60 x}{\f3\fs24  r}{\f3\fs24\dn60 y}{\f3\fs24         ry <\_\_ ry >> rx     (sign fill)
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 \page }{\b\f3\fs24 Memory Access: }{\f3\fs24  Memory accesses are shown as M[register] or M[number].  The symbol M[number] is a memory register address just like y is the address of register r}{\f3\fs24\dn60 y}{\f3\fs24 
.  The memory-address-register (mar) is the only register that literally addresses the memory.  This is why mar can be used in lieu of a number.  Here are several examples.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24           M[mar] <\_\_ r}{\f3\fs24\dn60 x}{\f3\fs24             r}{\f3\fs24\dn60 y}{\f3\fs24  <\_\_ M[mar]
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Specific examples are written from a designer's point of view as follows.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 M[7AC0] <\_\_ r}{\f3\fs24\dn60 x}{\f3\fs24  is implemented by   mar <\_\_ 7AC0, M[mar] <\_\_ r}{\f3\fs24\dn60 x}{\f3\fs24   
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 r}{\f3\fs24\dn60 y}{\f3\fs24  <\_\_ M[7AC0] is implemented by   mar <\_\_ 7AC0, r}{\f3\fs24\dn60 y}{\f3\fs24  <\_\_ M[mar]
\par }\pard {\f3\fs24 
\par 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 Moves: }{\f3\fs24  A move does not move data.  A move }{\b\f3\fs24 copies }{\f3\fs24 
the source data and stores it in the destination address.  The uI set has a general move uI MOV and specialized move uI EXCH, PUSH, and POP.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 The PUSH and POP uI as written do not explicitly reveal the logic that implements them.  The PUSH and POP uI move data to and from the stack (see section 2.12.2) which is a specified bank of memory }{\b\f3\fs24 registers}{
\f3\fs24 .  The special stack pointer register (sp) points to the next stack register to be used.  
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 PUSH r}{\f3\fs24\dn60 y}{\f3\fs24 \tab \tab sp <--- sp-4, then M[sp] <--- r}{\f3\fs24\dn60 y}{\b\f3\fs24 
\par }\pard {\b\f3\fs24 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 Program Control: }{\f3\fs24 
 The program control register (pc) points to the next uI to be executed in a program.  Actually the pc points to a memory location.  The mar addresses the location when the pc is moved to the mar.  The instruction register (ir) stores the uI that is being
 executed.
\par  
\par                     mar <\_\_\_ pc
\par \tab \tab \tab \tab ir  <--- M(mar)
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 The uI JMP addr_abs means that the next uI executed is found in the memory register whose address is addr_abs.  
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 JMP addr_abs\tab \tab pc <--- addr_abs
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 
The RTL statement for the conditional Jump Relative uI JRcc n reveals an important assumption.  When the condition code cc is false the branch taken is to the next-in-line-uI at pc+4.  In principal the cc false branch does not have to be to pc+4.  We will
 see there are many practical reasons for the pc+4 choice.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 JRcc n         If cc is true then pc <\_\_ pc+n else pc <\_\_ pc+4
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 CALL and RETurn are special jump uI (section 2.12.2).  Other program control uI are specialized functions that deal with external and internal interrupts.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 \page }{\b\f3\fs24 Subtraction: }{\f3\fs24  Perhaps a review of binary subtraction implemented in hardware is in order.  We define SUB r}{\f3\fs24\dn60 x}{\f3\fs24  r}{\f3\fs24\dn60 y}{\f3\fs24   to perform the operation 

\par           r}{\f3\fs24\dn60 y}{\f3\fs24  <\_\_ r}{\f3\fs24\dn60 y}{\f3\fs24  \_ r}{\f3\fs24\dn60 x}{\f3\fs24 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 However, internal to the computer what actually happens is addition of the 2's complement of r}{\f3\fs24\dn60 x}{\f3\fs24  because \_r}{\f3\fs24\dn60 x}{\f3\fs24  = \_(r}{\f3\fs24\dn60 x}{\f3\fs24 ) = r}{\f3\fs24\dn60 x}{
\f3\fs24 ' + 1.  This is why in Table 2.1 SUB r}{\f3\fs24\dn60 x}{\f3\fs24  r}{\f3\fs24\dn60 y}{\f3\fs24  performs the given RTL operation.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24           r}{\f3\fs24\dn60 y}{\f3\fs24  <\_\_ r}{\f3\fs24\dn60 y}{\f3\fs24  + r}{\f3\fs24\dn60 x}{\f3\fs24 '+ 1
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Multiple precision subtraction involves a multiplicity of words because the computer can only operate on one word pair at a time.  This why SBB is needed (subtraction with borrow).  SBB r}{\f3\fs24\dn60 x}{\f3\fs24  r}{
\f3\fs24\dn60 y}{\f3\fs24  performs the operation
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24           r}{\f3\fs24\dn60 y}{\f3\fs24  <\_\_ r}{\f3\fs24\dn60 y}{\f3\fs24  + r}{\f3\fs24\dn60 x}{\f3\fs24 '+ c 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 
Allow us to explain this by tangible example because we believe the example is more clear than a set of equations however elegant they may be.  Pretend the word length is 4 bits so we can illustrate in a simple way how we subtract numbers represented by m
ore than one word per number.  First two 8 bit binary numbers are subtracted directly using binary subtraction.  Then subtraction is implemented by adding the 2's complement.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24           Direct                  2's Complement
\par                                  1111}{\b\f3\fs24 1}{\f3\fs24 0010  carries during addition
\par      r}{\f3\fs24\dn60 y}{\f3\fs24    01111001  121       r}{\f3\fs24\dn60 y}{\f3\fs24   01111001
\par     \_r}{\f3\fs24\dn60 x}{\f3\fs24   \_01000011  \_67       r}{\f3\fs24\dn60 x}{\f3\fs24 ' 10111100
\par         \_\_\_\_\_\_\_\_\_\_\_ \_\_\_        1         1
\par           00110110   54          \_\_\_\_\_\_\_\_\_
\par                                  100110110  including carry 1
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Now divide the 8 bit words into two 4 bit words because the computer word length is 4 bits.  This time the carries within the 4 bit words are not shown.  Only the carry from word to word is shown.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 c             }{\b\f3\fs24 1}{\f3\fs24                  carry from low order word
\par r}{\f3\fs24\dn60 y}{\f3\fs24          0111           1001       121 decimal
\par r}{\f3\fs24\dn60 x}{\f3\fs24 '        1011           1100
\par 1\tab \tab }{\f3\fs24\ul      \tab \tab     1\tab   \_67}{\f3\fs24 
\par sum       10011           0110        54  ignoring output carry 1
\par sums      r}{\f3\fs24\dn60 y}{\f3\fs24  + r}{\f3\fs24\dn60 x}{\f3\fs24 '+ c     r}{\f3\fs24\dn60 y}{\f3\fs24  + r}{\f3\fs24\dn60 x}{\f3\fs24 '+ 1    
\par uI        SBB             SUB
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Exchanging the values in r}{\f3\fs24\dn60 x}{\f3\fs24 , r}{\f3\fs24\dn60 y}{\f3\fs24  the result is as follows.
\par c        0    0                 carry from low order word
\par r}{\f3\fs24\dn60 y}{\f3\fs24          0100           0011       67
\par r}{\f3\fs24\dn60 x}{\f3\fs24 '        1000           0110
\par 1\tab \tab }{\f3\fs24\ul      \tab \tab     1\tab \_121}{\f3\fs24 
\par sum      0 1100           1010      \_54  ignoring output carry 0
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 We claim the equations represent a general solution.
\par \page }{\b\f3\fs24 2.3 Status Logic and cc}{\f3\fs24 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 
Almost all programs need to test data values and change the sequence of uI executed according to the test results.  Program control is implemented by branches under specified conditions.  These conditions are known as condition codes cc which are evaluate
d by branch uI.  
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 The cc condition codes (table 2.2) used by uI branch decisions are determined to be true or false according to th
e values of status bits.  As shown in table 2.2 each cc decision is based on some equation using the status bits as variables.  The status bit values are established from results of operations by operator uI. Therefore a branch decision requires two uI.  
An operator uI executes prior to the branch uI and determines status bit values.  The second uI, the branch uI, uses the status bit values in a cc equation to make a branch decision.  The program branches to another place in the program if the equation is
 true.  If the equation is false the program proceeds to execute the next in line uI.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 Status bits:}{\f3\fs24   The status register has 4 bits with names N C Z V.  The meaning attached to these bits follows.  Msb means most significant bit.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24\ul Bit\tab Name    \tab \tab Action by operator uI                        }{\f3\fs24    N    sign bit       Set to 1 if msb is 1. 
\par \tab \tab \tab \tab Set to 0 if msb is 0.
\par C    carry bit      Set to 1 if result generates a carry.
\par \tab \tab \tab \tab Set to 0 if result does not generate a carry.
\par Z    zero bit       Set to 1 if result is 0.  
\par \tab \tab \tab \tab Set to 0 if result is not 0.
\par V    overflow bit   Set to 1 if result overflows.
\par \tab \tab \tab \tab Set to 0 if result does not overflow.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 Sign:  }{\f3\fs24 
The sign bit value is based on the msb value.  The sign bit is independent of the interpretation of the result.  When the result is known to be an unsigned number in a program context the unsigned compare cc are used.  These cc do not use status bit N.

\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 Carry: }{\f3\fs24 The carry bit from the msb has meaning only when the numbers are interpreted as unsigned.  The carry bit has no meaning when numbers are interpreted as signed because the msb are sign bits.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Carry bit C reports the carry from the msb for any ALU operation.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 The subtraction example 121 \_ 67 = 54 shows the carry from the msb as a 1.  On the other hand the example 67 \_ 121 = \_
54 shows the carry from the msb to be a zero.  Therefore carry equals 1 means no borrow and carry equals 0 means there is a borrow.  When the C bit stores this carry C = 0 when there is a borrow.  Thus C' means there was a borrow and C' must be used in th
e cc equations.  However this makes the form of the equations non symmetrical.  This is why many commercial computer chips invert carries from subtraction operations.  Then the C bit reports the complement of the carry from the msb.  
\par \page Emphasis:  The complement of the carry is stored in status bit C for two reasons.
\par 1. This makes C = 1, not 0, on borrow.
\par 2. The cc equations in Table 2.2 become symmetric.  
\par \tab For example the cc equation for LS is C + Z.  If the           \tab complement was not used the equation is C'+ Z
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 The cc equations for the two cases are shown in Table 2.2.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 Zero:  }{\f3\fs24 There is an apparent contradiction here because the zero bit is set to 1 and not 0 if the result is zero.  Z is set to 1 when the result is zero because 1 represents true.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 Overflow:  }{\f3\fs24 
Overflow occurs when operations on signed numbers produce a result out of the signed number range.  A not obvious yet straightforward way to detect overflow is to XOR the carries from the ALU output msb and msb\_1.  Unfortunately the carry from the msb\_
1 i
s not available at some ALU chip pins.  We need to find another way to detect overflow.  To find another way let us examine the additon of two positive or two negative numbers.  An overflow does not occur when numbers of different signs are added (why?).

\par }\pard {\f3\fs24 
\par 
\par }\pard \sl-240\slmult0 {\f3\fs24 Negative 4 bit numbers:  f = a + b
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Carries   1000                1100                1110
\par a          1001  \_7            1100  \_4            1010  \_6
\par b          1010  \_6            1110  \_2            1110  \_2
\par           \_\_\_\_\_  \_\_           \_\_\_\_\_  \_\_           \_\_\_\_\_  \_\_
\par f          0011  +3            1010  \_6            1000  \_8
\par Overflow?  yes                 no                  no
\par }\pard {\f3\fs24 
\par 
\par }\pard \sl-240\slmult0 {\f3\fs24 Positive 4 bit numbers:  f = a + b
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Carries   0110                0000                0110
\par a          0111   7            0100   4            0110   6
\par b          0110   6            0010   2            0010   2
\par           \_\_\_\_\_  \_\_           \_\_\_\_\_  \_\_           \_\_\_\_\_  \_\_
\par f          1101  \_3            0110   6            1000  \_8
\par Overflow?  yes                 no                  yes
\par }\pard {\f3\fs24 
\par 
\par }\pard \sl-240\slmult0 {\f3\fs24 Observations: 
\par 1. On overflow the a and b msb bits are always equal.
\par 2. On overflow the f msb bit is different from the a and b msb bits 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Therefore  V = fb'a' + f'ba \tab \tab (a, b, f msb bits)
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 In words: Overflow occurs when 
\par           both a and b msbs are 0 (positive numbers) and f msb is 1
\par        or both a and b msbs are 1 (negative numbers) and f msb is 0
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 \page }{\b\f3\fs24 Table 2.1: CISC uI set}{\f3\fs24 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 This set is a two address set.  Symbols are explained in the text and in Table 2.3.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 r}{\f3\fs24\dn60 x}{\f3\fs24 , r}{\f3\fs24\dn60 y}{\f3\fs24   source or destination registers
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 source and destination operands r}{\f3\fs24\dn60 x}{\f3\fs24 , r}{\f3\fs24\dn60 y}{\f3\fs24  may be replaced by any address mode ea form: iw (r}{\f3\fs24\dn60 x}{\f3\fs24  only), *r, *\_r, *r+, *r(n), addr_abs
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 ea is effective address of a source or destination 
\par ea', r}{\f3\fs24\dn60 x}{\f3\fs24 ', r}{\f3\fs24\dn60 y}{\f3\fs24 ' are 1's complements of the contents
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Operators: (these uI clear and set N C Z V status bits)
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 ABS       r}{\f3\fs24\dn60 y}{\f3\fs24         If r}{\f3\fs24\dn60 y}{\f3\fs24  < 0 then r}{\f3\fs24\dn60 y}{\f3\fs24  <\_\_\_ \_r}{\f3\fs24\dn60 y}{\f3\fs24 
\par ADD   r}{\f3\fs24\dn60 x}{\f3\fs24   r}{\f3\fs24\dn60 y}{\f3\fs24         r}{\f3\fs24\dn60 y}{\f3\fs24  <\_\_ r}{\f3\fs24\dn60 x}{\f3\fs24  + r}{\f3\fs24\dn60 y}{\f3\fs24            (+ means plus)
\par ADC   r}{\f3\fs24\dn60 x}{\f3\fs24   r}{\f3\fs24\dn60 y}{\f3\fs24         r}{\f3\fs24\dn60 y}{\f3\fs24  <\_\_ r}{\f3\fs24\dn60 y}{\f3\fs24  + r}{\f3\fs24\dn60 x}{\f3\fs24  + c       (+ means plus)
\par BTST  r}{\f3\fs24\dn60 x}{\f3\fs24   r}{\f3\fs24\dn60 y}{\f3\fs24         Z <\_\_\_ r}{\f3\fs24\dn60 yk}{\f3\fs24 '    Fetch bit}{\f3\fs24\dn60 k}{\f3\fs24  from r}{\f3\fs24\dn60 y}{\f3\fs24  (k in r}{\f3\fs24\dn60 x}{\f3\fs24 ). 
\par                                    Store bit}{\f3\fs24\dn60 k}{\f3\fs24 ' in Z bit.
\par CLR       r}{\f3\fs24\dn60 y}{\f3\fs24         r}{\f3\fs24\dn60 y}{\f3\fs24  <\_\_\_ 0
\par CLRC                C  <\_\_\_ 0
\par CMP   r}{\f3\fs24\dn60 x}{\f3\fs24   r}{\f3\fs24\dn60 y}{\f3\fs24         form r}{\f3\fs24\dn60 y}{\f3\fs24  \_ r}{\f3\fs24\dn60 x}{\f3\fs24  to set status (r}{\f3\fs24\dn60 y}{\f3\fs24  not changed)
\par DEC       r}{\f3\fs24\dn60 y}{\f3\fs24         r}{\f3\fs24\dn60 y}{\f3\fs24  <\_\_\_ r}{\f3\fs24\dn60 y}{\f3\fs24  \_ 1
\par DIVS  r}{\f3\fs24\dn60 x}{\f3\fs24   r}{\f3\fs24\dn60 y}{\f3\fs24         r}{\f3\fs24\dn60 y}{\f3\fs24  <\_\_\_ quotient q of r}{\f3\fs24\dn60 y}{\f3\fs24 /r}{\f3\fs24\dn60 x}{\f3\fs24   Signed divide
\par DIVU  r}{\f3\fs24\dn60 x}{\f3\fs24   r}{\f3\fs24\dn60 y}{\f3\fs24         r}{\f3\fs24\dn60 y}{\f3\fs24  <\_\_\_ quotient q of r}{\f3\fs24\dn60 y}{\f3\fs24 /r}{\f3\fs24\dn60 x}{\f3\fs24   Unsigned divide 
\par MODS  r}{\f3\fs24\dn60 x}{\f3\fs24   r}{\f3\fs24\dn60 y}{\f3\fs24         r}{\f3\fs24\dn60 y}{\f3\fs24  <\_\_\_ remainder r of r}{\f3\fs24\dn60 y}{\f3\fs24 /r}{\f3\fs24\dn60 x}{\f3\fs24   Signed modulus
\par MODU  r}{\f3\fs24\dn60 x}{\f3\fs24   r}{\f3\fs24\dn60 y}{\f3\fs24         r}{\f3\fs24\dn60 y}{\f3\fs24  <\_\_\_ remainder r of r}{\f3\fs24\dn60 y}{\f3\fs24 /r}{\f3\fs24\dn60 x}{\f3\fs24   Unsigned modulus
\par MULS  r}{\f3\fs24\dn60 x}{\f3\fs24   r}{\f3\fs24\dn60 y}{\f3\fs24         Signed multiply of r}{\f3\fs24\dn60 x}{\f3\fs24  & r}{\f3\fs24\dn60 y}{\f3\fs24                     \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab 
\tab \tab \tab \tab    \tab \tab \tab \tab r}{\f3\fs24\dn60 y}{\f3\fs24  <\_\_\_ high word, r}{\f3\fs24\dn60 y+1}{\f3\fs24  <\_\_\_ low word
\par MULU  r}{\f3\fs24\dn60 x}{\f3\fs24   r}{\f3\fs24\dn60 y}{\f3\fs24         Unsigned multiply of r}{\f3\fs24\dn60 x}{\f3\fs24  & r}{\f3\fs24\dn60 y}{\f3\fs24  \tab \tab \tab \tab \tab \tab 
\par \tab \tab \tab \tab r}{\f3\fs24\dn60 y}{\f3\fs24  <\_\_\_ high word, r}{\f3\fs24\dn60 y+1}{\f3\fs24  <\_\_\_ low word
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 NEG       r}{\f3\fs24\dn60 y}{\f3\fs24         r}{\f3\fs24\dn60 y}{\f3\fs24  <\_\_\_ r}{\f3\fs24\dn60 y}{\f3\fs24 '+ 1           (+ means plus)
\par NOP                 No operation.
\par NOT       r}{\f3\fs24\dn60 y}{\f3\fs24         r}{\f3\fs24\dn60 y}{\f3\fs24  <\_\_\_ r}{\f3\fs24\dn60 y}{\f3\fs24 '
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 SETC                C  <\_\_ 1
\par SUB   r}{\f3\fs24\dn60 x}{\f3\fs24   r}{\f3\fs24\dn60 y}{\f3\fs24         r}{\f3\fs24\dn60 y}{\f3\fs24  <\_\_ r}{\f3\fs24\dn60 y}{\f3\fs24  + r}{\f3\fs24\dn60 x}{\f3\fs24 '+ 1       (+ means plus)
\par SBB   r}{\f3\fs24\dn60 x}{\f3\fs24   r}{\f3\fs24\dn60 y}{\f3\fs24         r}{\f3\fs24\dn60 y}{\f3\fs24  <\_\_ r}{\f3\fs24\dn60 y}{\f3\fs24  + r}{\f3\fs24\dn60 x}{\f3\fs24 '+ c       (+ means plus)
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 AND   r}{\f3\fs24\dn60 x}{\f3\fs24   r}{\f3\fs24\dn60 y}{\f3\fs24         r}{\f3\fs24\dn60 y}{\f3\fs24  <\_\_ r}{\f3\fs24\dn60 y}{\f3\fs24  and r}{\f3\fs24\dn60 x}{\f3\fs24 
\par OR    r}{\f3\fs24\dn60 x}{\f3\fs24   r}{\f3\fs24\dn60 y}{\f3\fs24         r}{\f3\fs24\dn60 y}{\f3\fs24  <\_\_ r}{\f3\fs24\dn60 y}{\f3\fs24  or  r}{\f3\fs24\dn60 x}{\f3\fs24 
\par XOR   r}{\f3\fs24\dn60 x}{\f3\fs24   ry        r}{\f3\fs24\dn60 y}{\f3\fs24  <\_\_ r}{\f3\fs24\dn60 y}{\f3\fs24  xor r}{\f3\fs24\dn60 x}{\f3\fs24 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 ROTL  r}{\f3\fs24\dn60 x}{\f3\fs24   r}{\f3\fs24\dn60 y}{\f3\fs24         r}{\f3\fs24\dn60 y}{\f3\fs24  <\_\_ r}{\f3\fs24\dn60 y}{\f3\fs24  << r}{\f3\fs24\dn60 x}{\f3\fs24      (msb to lsb each shift)
\par SLL   r}{\f3\fs24\dn60 x}{\f3\fs24   r}{\f3\fs24\dn60 y}{\f3\fs24         r}{\f3\fs24\dn60 y}{\f3\fs24  <\_\_ r}{\f3\fs24\dn60 y}{\f3\fs24  << r}{\f3\fs24\dn60 x}{\f3\fs24      (zero fill)   shift k bits
\par SRA   r}{\f3\fs24\dn60 x}{\f3\fs24   r}{\f3\fs24\dn60 y}{\f3\fs24         r}{\f3\fs24\dn60 y}{\f3\fs24  <\_\_ r}{\f3\fs24\dn60 y}{\f3\fs24  >> r}{\f3\fs24\dn60 x}{\f3\fs24      (sign fill)   k in rx
\par SRL   r}{\f3\fs24\dn60 x}{\f3\fs24   r}{\f3\fs24\dn60 y}{\f3\fs24         r}{\f3\fs24\dn60 y}{\f3\fs24  <\_\_ r}{\f3\fs24\dn60 y}{\f3\fs24  >> r}{\f3\fs24\dn60 x}{\f3\fs24      (zero fill)
\par }\pard {\f3\fs24 
\par 
\par 
\par }\pard \sl-240\slmult0 {\f3\fs24 \page }{\b\f3\fs24 Table 2.1: CISC uI set continued}{\f3\fs24 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Moves: (these uI do not affect status bits.)
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 EXCH  r}{\f3\fs24\dn60 x}{\f3\fs24   r}{\f3\fs24\dn60 y}{\f3\fs24         r}{\f3\fs24\dn60 y}{\f3\fs24  <\_\_ r}{\f3\fs24\dn60 x}{\f3\fs24 ,  r}{\f3\fs24\dn60 x}{\f3\fs24  <\_\_ r}{\f3\fs24\dn60 y}{\f3\fs24 
\par MOV   r}{\f3\fs24\dn60 x}{\f3\fs24   r}{\f3\fs24\dn60 y}{\f3\fs24         r}{\f3\fs24\dn60 y}{\f3\fs24  <\_\_ r}{\f3\fs24\dn60 x}{\f3\fs24 
\par PUSH  r}{\f3\fs24\dn60 y}{\f3\fs24             sp <\_\_ sp\_4,  then M[sp] <\_\_ r}{\f3\fs24\dn60 y}{\f3\fs24 
\par POP   r}{\f3\fs24\dn60 y}{\f3\fs24             r}{\f3\fs24\dn60 y}{\f3\fs24  <\_\_ M[sp], then sp <\_\_ sp+4
\par }\pard {\f3\fs24 
\par 
\par }\pard \sl-240\slmult0 {\f3\fs24 Program control: (these uI do not affect status bits.)
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 JMP  addr_abs       pc <\_\_ addr_abs
\par JRcc n              if cc true then pc <\_\_ pc+n else pc <\_\_ pc+4
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 CALL  target        sp <\_\_ sp\_4, then M[sp] <\_\_ pc, pc <\_\_ target
\par CALL  r}{\f3\fs24\dn60 y}{\f3\fs24             sp <\_\_ sp\_4, then M[sp] <\_\_ pc, pc <\_\_ r}{\f3\fs24\dn60 y}{\f3\fs24 
\par RET                 pc <\_\_ M[sp],then sp <\_\_ sp+4
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 DINT                Disable interrupt
\par EINT                Enable interrupt
\par EXCH  pc  r}{\f3\fs24\dn60 y}{\f3\fs24         r}{\f3\fs24\dn60 y}{\f3\fs24  <\_\_ pc, pc <\_\_ r}{\f3\fs24\dn60 y}{\f3\fs24 
\par GETPC     r}{\f3\fs24\dn60 y}{\f3\fs24         r}{\f3\fs24\dn60 y}{\f3\fs24  <\_\_ pc
\par GETST     r}{\f3\fs24\dn60 y}{\f3\fs24         r}{\f3\fs24\dn60 y}{\f3\fs24  <\_\_ status
\par PUSHST              sp <\_\_ sp\_4, then M[sp] <\_\_ status
\par PUTST r}{\f3\fs24\dn60 x}{\f3\fs24             status <\_\_\_ r}{\f3\fs24\dn60 x}{\f3\fs24 
\par RETI                pc <\_\_ M[sp], then sp <\_\_ sp+4
\par TRAP  n             sp <\_\_ sp\_4, then M[sp] <\_\_ pc, pc <\_\_ vector n
\par }\pard {\f3\fs24 
\par 
\par }\pard \sl-240\slmult0 {\f3\fs24 Notation Address Modes                            ea examples 
\par \_\_\_\_\_\_\_\_ \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_                         \_\_\_\_\_\_\_\_\_\_\_\_\_\_
\par iw       Immediate                                ADD iw    r}{\f3\fs24\dn60 y}{\f3\fs24 
\par addr_abs Absolute address                         ADD r}{\f3\fs24\dn60 y}{\f3\fs24   addr_abs
\par r}{\f3\fs24\dn60 x}{\f3\fs24        Register direct                          ADD r}{\f3\fs24\dn60 x}{\f3\fs24     r}{\f3\fs24\dn60 y}{\f3\fs24 
\par *r}{\f3\fs24\dn60 x}{\f3\fs24       Register indirect                        ADD *r}{\f3\fs24\dn60 x}{\f3\fs24    r}{\f3\fs24\dn60 y}{\f3\fs24 
\par *r}{\f3\fs24\dn60 x}{\f3\fs24 (n)   Register indirect with signed offset n   ADD r}{\f3\fs24\dn60 x}{\f3\fs24    *r}{\f3\fs24\dn60 y}{\f3\fs24 (n)
\par *\_r}{\f3\fs24\dn60 x}{\f3\fs24      Register indirect with predecrement      ADD *\_r}{\f3\fs24\dn60 x}{\f3\fs24   r}{\f3\fs24\dn60 y}{\f3\fs24 
\par *r}{\f3\fs24\dn60 x}{\f3\fs24 +     Register indirect with postincrement     ADD *r}{\f3\fs24\dn60 x}{\f3\fs24 +  r}{\f3\fs24\dn60 y}{\b\f3\fs24 
\par }\pard {\b\f3\fs24 
\par 
\par 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 \page Table 2.2 CISC Condition Codes cc}{\f3\fs24 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 src = source data
\par dst = destination data
\par N C Z V are status bits 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Unconditional cc:                       cc equation (note 1) 
\par                                         C=carry   C=carry'  code
\par                                         \_\_\_\_\_\_\_   \_\_\_\_\_\_\_\_  \_\_\_\_
\par UN   branch always                      none                00hex
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Unsigned compare cc: 
\par LO   dst lower than src                 C'        C         01
\par HS   dst higher or same as src          C         C'        02
\par LS   dst lower or same as src           C'+ Z     C + Z     03
\par HI   dst higher than src                C Z'      C'Z'      04
\par EQ   dst equal to src                   Z         Z         05
\par NE   dst not equal to src               Z'        Z'        06
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Signed compare cc:
\par LT   dst less than src                  NV'+ N'V            07
\par GE   dst greater than or equal to src   NV + N'V'           08
\par LE   dst less than or equal to src      NV'+ N'V + Z        09
\par GT   dst greater than src              (NV + N'V')Z'        0A
\par EQ   dst equal to src                   Z                   0B
\par NE   dst not equal to src               Z'                  0C
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Compare to zero cc:
\par Z    result equal to zero               Z                   0D
\par NZ   result not equal to zero           Z'                  0E
\par P    result is positive, >0             N'Z'                0F
\par N    result is negative, <0             N    (sign)         10
\par NN   result not neg, >0 or =0           N'                  11
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Arithmetic cc:
\par Z    result equal to zero               Z         Z (zero)  12
\par NZ   result not equal to zero           Z'        Z'        13
\par C    result sets carry                  C         C (carry) 14
\par NC   result clears carry                C'        C'        15
\par V    result overflows                   V         V (overf) 16
\par NV   result does not overflow           V'        V'        17
\par B    result sets borrow                 C'        C         18
\par NB   result does not borrow             C         C'        19
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Note 1: use of C or C' is the designer's choice.  
\par }\pard {\f3\fs24 
\par 
\par 
\par }\pard \sl-240\slmult0 {\f3\fs24 \page }{\b\f3\fs24 Table 2.3 Register Transfer Language}{\f3\fs24\ul 
\par }\pard {\f3\fs24\ul 
\par 
\par }\pard \sl-240\slmult0 {\f3\fs24\ul Symbol\tab Function                            \tab Example}{\f3\fs24 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 <\_\_\_      Data transfer (copy)                   *r}{\f3\fs24\dn60 y}{\f3\fs24  <\_\_\_ r}{\f3\fs24\dn60 x}{\f3\fs24 
\par           Example: transfer (copy) contents of 
\par           r}{\f3\fs24\dn60 x}{\f3\fs24  to destination location *r}{\f3\fs24\dn60 y}{\f3\fs24 .
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 M[x]      Access memory at address x              r}{\f3\fs24\dn60 y}{\f3\fs24  <\_\_\_ M[x]
\par           Example: Copy contents of memory 
\par           location x to r}{\f3\fs24\dn60 y}{\f3\fs24 .
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 <\_\_\_}{\f3\fs24\dn60 n}{\f3\fs24      Data transfer, n bit field 
\par           Example: Copy 24 bits starting at 
\par           memory location x to a location 
\par           starting at memory location y.\tab \tab M[y] <\_\_\_}{\f3\fs24\dn60 24}{\f3\fs24  M[x]
\par           Note: memory must be bit addressable.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 W}{\f3\fs24\dn60 m}{\f3\fs24         Subscript selects bit m of word r}{\f3\fs24\dn60 y}{\f3\fs24  
\par           Examples: replace r}{\f3\fs24\dn60 y}{\f3\fs24  bit 5 with a 1.\tab r}{\f3\fs24\dn60 y5}{\f3\fs24  <\_\_\_}{\f3\fs24\dn60 1}{\f3\fs24  1   
\par           Replace r}{\f3\fs24\dn60 y}{\f3\fs24  bit 7 with r}{\f3\fs24\dn60 y}{\f3\fs24  bit 9.\tab \tab r}{\f3\fs24\dn60 y7}{\f3\fs24  <\_\_\_}{\f3\fs24\dn60 1}{\f3\fs24  r}{\f3\fs24\dn60 y9}{\f3\fs24 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 W}{\f3\fs24\dn60 m..n}{\f3\fs24      Subscript selects bit field range 
\par           Example: Copy 8 bits starting at 
\par           memory location x to r}{\f3\fs24\dn60 y}{\f3\fs24  field 7..0\tab \tab r}{\f3\fs24\dn60 y7..0}{\f3\fs24  <\_\_\_}{\f3\fs24\dn60 8}{\f3\fs24  M[x]
\par           Note: memory must be bit addressable.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 b}{\f3\fs24\up6 n}{\f3\fs24         Superscript builds a field. 
\par           Bit b repeats n times to make   
\par           a field.
\par           Example: replace r}{\f3\fs24\dn60 y}{\f3\fs24  16 bit field \tab r}{\f3\fs24\dn60 y23..8}{\f3\fs24  <\_\_\_}{\f3\fs24\dn60 16}{\f3\fs24  1}{\f3\fs24\up6 16}{\f3\fs24 
\par           23..8 with 16 ones.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 ##        Concatenates two fields 
\par           Example: 64 bits copied from 
\par           memory to r}{\f3\fs24\dn60 2}{\f3\fs24 ,r}{\f3\fs24\dn60 3}{\f3\fs24 .\tab \tab \tab \tab r}{\f3\fs24\dn60 2}{\f3\fs24  ## r}{\f3\fs24\dn60 3}{\f3\fs24  <\_\_\_}{\f3\fs24\dn60 64}{\f3\fs24  M[x]
\par           Note: memory must be bit addressable.
\par           
\par <<, >>    shift left, shift right              r}{\f3\fs24\dn60 y}{\f3\fs24  <\_\_\_ r}{\f3\fs24\dn60 y}{\f3\fs24  << *r}{\f3\fs24\dn60 x}{\f3\fs24 
\par                                                k at ea of *r}{\f3\fs24\dn60 x}{\f3\fs24 
\par                                                shift k bits
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Note: many of the above require special data path hardware for       implementation.
\par }\pard {\f3\fs24 
\par 
\par 
\par }}