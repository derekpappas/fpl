{\rtf1\ansi \deff4\deflang1033{\fonttbl{\f0\froman\fcharset0\fprq2 Tms Rmn;}{\f1\froman\fcharset2\fprq2 Symbol;}{\f2\fswiss\fcharset0\fprq2 Helv;}{\f3\fmodern\fcharset0\fprq1 Courier{\*\falt Courier};}
{\f4\froman\fcharset0\fprq2 Times New Roman;}{\f5\fswiss\fcharset0\fprq2 Arial;}{\f6\froman\fcharset0\fprq2 MS Serif;}{\f7\fswiss\fcharset0\fprq2 MS Sans Serif;}{\f8\froman\fcharset0\fprq2 Times;}{\f9\fswiss\fcharset0\fprq2 Helvetica;}
{\f10\fswiss\fcharset0\fprq2 System;}{\f11\fmodern\fcharset0\fprq1 Courier New;}{\f12\fdecor\fcharset2\fprq2 ZapfDingbats;}{\f13\fnil\fcharset2\fprq2 Marlett;}{\f14\fswiss\fcharset238\fprq2 Arial CE;}{\f15\fswiss\fcharset204\fprq2 Arial CYR;}
{\f16\fswiss\fcharset161\fprq2 Arial Greek;}{\f17\fswiss\fcharset162\fprq2 Arial TUR;}{\f18\fswiss\fcharset186\fprq2 Arial Baltic;}{\f19\fmodern\fcharset238\fprq1 Courier New CE;}{\f20\fmodern\fcharset204\fprq1 Courier New CYR;}
{\f21\fmodern\fcharset161\fprq1 Courier New Greek;}{\f22\fmodern\fcharset162\fprq1 Courier New TUR;}{\f23\fmodern\fcharset186\fprq1 Courier New Baltic;}{\f24\fmodern\fcharset0\fprq1 Lucida Console;}{\f25\froman\fcharset238\fprq2 Times New Roman CE;}
{\f26\froman\fcharset204\fprq2 Times New Roman CYR;}{\f27\froman\fcharset161\fprq2 Times New Roman Greek;}{\f28\froman\fcharset162\fprq2 Times New Roman TUR;}{\f29\froman\fcharset186\fprq2 Times New Roman Baltic;}{\f30\fnil\fcharset2\fprq2 Wingdings;}
{\f31\fswiss\fcharset0\fprq2 Verdana;}{\f32\fswiss\fcharset0\fprq2 Arial Black;}{\f33\fscript\fcharset0\fprq2 Comic Sans MS;}{\f34\froman\fcharset0\fprq2 Georgia;}{\f35\fswiss\fcharset0\fprq2 Franklin Gothic Medium;}
{\f36\froman\fcharset0\fprq2 Palatino Linotype;}{\f37\fswiss\fcharset0\fprq2 Tahoma;}{\f38\fswiss\fcharset0\fprq2 Trebuchet MS;}{\f39\froman\fcharset2\fprq2 Webdings;}{\f40\fscript\fcharset1\fprq2 Estrangelo Edessa;}{\f41\fnil\fcharset1\fprq2 Gautami;}
{\f42\fnil\fcharset1\fprq2 Latha;}{\f43\fnil\fcharset1\fprq2 Mangal;}{\f44\fnil\fcharset1\fprq2 MV Boli;}{\f45\fnil\fcharset1\fprq2 Raavi;}{\f46\fnil\fcharset1\fprq2 Shruti;}{\f47\fnil\fcharset1\fprq2 Tunga;}{\f48\froman\fcharset0\fprq2 Sylfaen;}
{\f49\fswiss\fcharset0\fprq2 Microsoft Sans Serif;}{\f50\fswiss\fcharset0\fprq2 Arial Narrow;}{\f51\fdecor\fcharset0\fprq2 Curlz MT;}{\f52\froman\fcharset0\fprq2 Engravers MT;}{\f53\fswiss\fcharset0\fprq2 Franklin Gothic Book;}
{\f54\fswiss\fcharset0\fprq2 Franklin Gothic Demi Cond;}{\f55\fswiss\fcharset0\fprq2 Franklin Gothic Heavy;}{\f56\fswiss\fcharset0\fprq2 Franklin Gothic Medium Cond;}{\f57\fswiss\fcharset0\fprq2 Century Gothic;}
{\f58\fscript\fcharset0\fprq2 Edwardian Script ITC;}{\f59\fdecor\fcharset0\fprq2 Jokerman;}{\f60\fdecor\fcharset0\fprq2 Juice ITC;}{\f61\fswiss\fcharset0\fprq2 Lucida Sans Unicode;}{\f62\fscript\fcharset0\fprq2 Mistral;}
{\f63\fmodern\fcharset0\fprq2 OCR A Extended;}{\f64\froman\fcharset0\fprq2 Rockwell;}{\f65\froman\fcharset2\fprq2 Wingdings 2;}{\f66\froman\fcharset2\fprq2 MT Extra;}{\f67\fswiss\fcharset0\fprq2 Impact;}{\f68\fmodern\fcharset2\fprq1 MS LineDraw;}
{\f69\fdecor\fcharset0\fprq2 Algerian;}{\f70\fswiss\fcharset0\fprq2 Arial Rounded MT Bold;}{\f71\froman\fcharset0\fprq2 Bookman Old Style;}{\f72\fdecor\fcharset0\fprq2 Braggadocio;}{\f73\fswiss\fcharset0\fprq2 Britannic Bold;}
{\f74\fscript\fcharset0\fprq2 Brush Script MT;}{\f75\fdecor\fcharset0\fprq2 Colonna MT;}{\f76\fdecor\fcharset0\fprq2 Desdemona;}{\f77\froman\fcharset0\fprq2 Footlight MT Light;}{\f78\fdecor\fcharset0\fprq2 Kino MT;}
{\f79\froman\fcharset0\fprq2 Wide Latin;}{\f80\fscript\fcharset0\fprq2 Matura MT Script Capitals;}{\f81\fdecor\fcharset0\fprq2 Playbill;}{\f82\fnil\fcharset0\fprq2 OpenSymbol;}{\f83\fswiss\fcharset2\fprq2 WP Phonetic;}
{\f84\fnil\fcharset2\fprq2 WP MathExtendedB;}{\f85\fmodern\fcharset0\fprq1 WP BoxDrawing;}{\f86\fnil\fcharset2\fprq2 WP IconicSymbolsB;}{\f87\fnil\fcharset2\fprq2 WP Greek Helve;}{\f88\fnil\fcharset2\fprq2 WP MathExtendedA;}
{\f89\froman\fcharset2\fprq2 WP CyrillicA;}{\f90\fnil\fcharset2\fprq2 WP Japanese;}{\f91\fnil\fcharset2\fprq2 WP MathB;}{\f92\fnil\fcharset2\fprq2 WP IconicSymbolsA;}{\f93\fnil\fcharset2\fprq2 WP Arabic Sihafa;}
{\f94\froman\fcharset2\fprq2 WP MultinationalA Roman;}{\f95\fnil\fcharset0\fprq2 WP CyrillicB;}{\f96\fnil\fcharset2\fprq2 WP MultinationalB Roman;}{\f97\fmodern\fcharset2\fprq1 WP Greek Courier;}{\f98\fnil\fcharset2\fprq2 WP MathA;}
{\f99\fnil\fcharset2\fprq2 WP ArabicScript Sihafa;}{\f100\fnil\fcharset2\fprq2 WP Greek Century;}{\f101\fnil\fcharset2\fprq2 WP TypographicSymbols;}{\f102\fnil\fcharset2\fprq2 WP Hebrew David;}{\f103\fnil\fcharset2\fprq2 WP MultinationalA Helve;}
{\f104\fnil\fcharset2\fprq2 WP MultinationalB Helve;}{\f105\fmodern\fcharset2\fprq1 WP MultinationalA Courier;}{\f106\fmodern\fcharset2\fprq1 WP MultinationalB Courier;}{\f107\fscript\fcharset0\fprq2 Ribbon131 Bd BT;}
{\f108\froman\fcharset0\fprq2 Humanst521 Lt BT;}{\f109\froman\fcharset0\fprq2 GeoSlab703 Lt BT;}{\f110\fswiss\fcharset0\fprq2 Swis721 BlkEx BT;}{\f111\fswiss\fcharset0\fprq2 Humanst521 Cn BT;}{\f112\fdecor\fcharset0\fprq2 Onyx BT;}
{\f113\fdecor\fcharset0\fprq2 CaslonOpnface BT;}{\f114\fswiss\fcharset0\fprq2 EngraversGothic BT;}{\f115\fscript\fcharset0\fprq2 ShelleyVolante BT;}{\f116\froman\fcharset0\fprq2 BernhardMod BT;}{\f117\froman\fcharset0\fprq2 Arrus BT;}
{\f118\fscript\fcharset0\fprq2 OzHandicraft BT;}{\f119\fnil\fcharset0\fprq2 Sydnie;}{\f120\froman\fcharset255\fprq2 Roman;}{\f121\fscript\fcharset255\fprq2 Script;}{\f122\fmodern\fcharset255\fprq2 Modern;}{\f123\fswiss\fcharset0\fprq1 MS Dialog;}
{\f124\fmodern\fcharset0\fprq0 Elite;}{\f125\fmodern\fcharset0\fprq0 Prestige;}{\f126\fswiss\fcharset0\fprq0 Letter Gothic;}{\f127\fmodern\fcharset0\fprq0 GothicPS;}{\f128\fmodern\fcharset0\fprq0 CubicPS;}{\f129\fmodern\fcharset0\fprq0 LinePrinter;}
{\f130\fmodern\fcharset0\fprq0 AvantGarde;}{\f131\fswiss\fcharset0\fprq0 Helvetica-Narrow;}{\f132\fmodern\fcharset0\fprq0 Metro;}{\f133\fswiss\fcharset0\fprq0 Presentation;}{\f134\fmodern\fcharset0\fprq0 APL;}{\f135\fmodern\fcharset0\fprq0 OCRA;}
{\f136\fmodern\fcharset0\fprq0 OCRB;}{\f137\froman\fcharset0\fprq0 Bookman;}{\f138\froman\fcharset0\fprq0 Madaleine;}{\f139\froman\fcharset0\fprq0 ZapfHumanist;}{\f140\froman\fcharset0\fprq0 Classic;}{\f141\froman\fcharset0\fprq0 Roman f;}
{\f142\froman\fcharset0\fprq0 Roman g;}{\f143\froman\fcharset0\fprq0 Roman h;}{\f144\froman\fcharset0\fprq0 NewCenturySchlbk;}{\f145\froman\fcharset0\fprq0 Palatino;}{\f146\froman\fcharset0\fprq0 Souvenir;}{\f147\froman\fcharset0\fprq0 Garamond;}
{\f148\froman\fcharset0\fprq0 Caledonia;}{\f149\froman\fcharset0\fprq0 Bodini;}{\f150\froman\fcharset0\fprq0 University;}{\f151\fscript\fcharset0\fprq0 ScriptPS;}{\f152\fscript\fcharset0\fprq0 Script c;}{\f153\fscript\fcharset0\fprq0 Script d;}
{\f154\fscript\fcharset0\fprq0 Commercial Script;}{\f155\fscript\fcharset0\fprq0 Park Avenue;}{\f156\fscript\fcharset0\fprq0 Coronet;}{\f157\fscript\fcharset0\fprq0 Script h;}{\f158\fscript\fcharset0\fprq0 Greek;}{\f159\froman\fcharset0\fprq0 Kana;}
{\f160\froman\fcharset0\fprq0 Hebrew;}{\f161\froman\fcharset0\fprq0 Roman s;}{\f162\froman\fcharset0\fprq0 Russian;}{\f163\froman\fcharset0\fprq0 Roman u;}{\f164\froman\fcharset0\fprq0 Roman v;}{\f165\froman\fcharset0\fprq0 Roman w;}
{\f166\fdecor\fcharset0\fprq0 Narrator;}{\f167\fdecor\fcharset0\fprq0 Emphasis;}{\f168\fdecor\fcharset0\fprq0 ZapfChancery;}{\f169\fdecor\fcharset0\fprq0 Decor d;}{\f170\fdecor\fcharset0\fprq0 Old English;}{\f171\fdecor\fcharset0\fprq0 Decor f;}
{\f172\fdecor\fcharset0\fprq0 Decor g;}{\f173\fdecor\fcharset0\fprq0 Cooper Black;}{\f174\fnil\fcharset0\fprq0 Math7;}{\f175\fnil\fcharset0\fprq0 Math8;}{\f176\fnil\fcharset0\fprq0 EAN;}{\f177\fnil\fcharset0\fprq0 PCline;}
{\f178\fnil\fcharset0\fprq0 Tech h;}{\f179\fmodern\fcharset0\fprq0 Courier Bold{\*\falt Courier};}{\f180\fmodern\fcharset0\fprq0 Courier Oblique{\*\falt Courier};}}{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;
\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;
\red128\green128\blue128;\red192\green192\blue192;}{\stylesheet{\f4\fs20 \snext0 Normal;}{\*\cs10 \additive Default Paragraph Font;}{\s15\tqc\tx4320\tqr\tx8640 \f4\fs20 \sbasedon0\snext15 header;}{\s16\tqc\tx4320\tqr\tx8640 \f4\fs20 \sbasedon0\snext16 
footer;}}{\info{\author Nicholas L. Pappas, Ph.D.}{\creatim\yr1910\mo2\dy1}{\revtim\yr1910\mo2\dy1}{\version1}{\edmins0}{\nofpages0}{\nofwords0}{\nofchars0}{\vern49203}}\margl1440\margr1152\margt720\margb720 
\facingp\ftnbj\aenddoc\ftnrestart\pgnstart301\notabind\noextrasprl\sprsspbf\brkfrm\hyphcaps0 \fet0\sectd \sbknone\pgnrestart\pgnstarts301\linex576\footery480\endnhere {\headerl \pard\plain \qj\li-1440\ri-1152\sl-240\slmult0 \f4\fs20 {\f3\fs24 
                                Computer Architecture and Design
\par }}{\headerr \pard\plain \qj\li-1440\ri-1152\sl-240\slmult0 \f4\fs20 {\f3\fs24                                 Computer Architecture and Design
\par }}{\footerl \pard\plain \qj\li-1440\ri-1152\sl-240\slmult0 \f4\fs20 {\f3\fs24 (C) Copyright 1991 Nicholas L. Pappas, PhD.     910801       \chpgn 
\par }}{\footerr \pard\plain \qj\li-1440\ri-1152\sl-240\slmult0 \f4\fs20 {\f3\fs24 (C) Copyright 1991 Nicholas L. Pappas, PhD.     910801       \chpgn 
\par }}{\*\pnseclvl1\pnucrm\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl2\pnucltr\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl3\pndec\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl4\pnlcltr\pnstart1\pnindent720\pnhang{\pntxta )}}
{\*\pnseclvl5\pndec\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl6\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl8
\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}\pard\plain \sl-240\slmult0 \f4\fs20 {\b\f3\fs24 3. RISC Computers}{\f3\fs24 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 3.1  RISC uI Set
\par      3.1.1 Literals
\par      3.1.2 Address Modes
\par      3.1.3 Load and Store
\par      3.1.4 Operators
\par      3.1.5 Program Control
\par      3.1.6 uI Codeword Formats
\par 3.2  The First Step from uI to User Data Path
\par      3.2.1 Bus
\par      3.2.2 Register File
\par      3.2.3 Memory
\par      3.2.4 Program Counter and Instruction Register
\par      3.2.5 ALU and Shifter
\par      3.2.6 Temporary Register
\par      3.2.7 Status
\par      3.2.8 Other Items
\par 3.3  The Second Step from uI to User Data Path
\par      3.3.1 RISC mI Word Format
\par      3.3.2 Branch to fetch_uI
\par      3.3.3 Shift Operations
\par      3.3.4 Scc
\par      3.3.5 CONST
\par      3.3.6 Load
\par      3.3.7 Store
\par      3.3.8 Program Control
\par \tab 3.3.9 uData Path
\par 3.4  Microinstructions
\par 3.5  Micro Data Path
\par 3.6  Micro Control
\par 3.7  Microprograming
\par      3.7.1 mI fields
\par      3.7.2 mI used as Control cI
\par      3.7.3 Arithmetic and Logical Operator
\par      3.7.4 Shift Operator
\par      3.7.5 CONST 
\par      3.7.6 Scc
\par      3.7.7 Load
\par      3.7.8 Store
\par      3.7.9 Program Control
\par }\pard {\f3\fs24 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par }\pard \sl-240\slmult0 {\f3\fs24 \page }{\b\f3\fs24 Overview}{\f3\fs24 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 We define a reduced instruction set computer (RISC) by pulling out of thin air a m
inimum RISC user instruction (uI) set.  The uI set is one specification for the RISC computer design.  Then the RISC concept is embodied in the main goal of no lists of mI.  The one-mI-per-uI goal is another specification for the design.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 
Guided by the desire to minimize the number of time consuming memory accesses literals and address modes are treated differently as we show how and why memory accesses are limited to load and store uI.  Next, new uI types are discussed and uI codeword for
mats are defined.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 
Starting from the uI set the preliminary user data path is evolved.  We show how the data path is some set of combinational circuit blocks and sequential circuit blocks interconnected by data buses.  However this preliminary user data path does not fulfil
l the main goal.  The uI set does not provide the necessary information.  
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 We show how to benefit from what we know by using the CISC mI set to write RISC uI mI lists.  Analysis of the lists reveals how special hardware replaces mI in those lists.  In thi
s way the lists are reduced to one mI except for load and stores (two mI) and a suitable user data path results.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Given the user data path control lines the RISC mControl and associated ASM is created by modifying the CISC mControl and ASM.  
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 As we proceed through the above processes we do extensive microprogramming demonstrating that any uI can be represented by mI lists with only one or two mI in each list.  
\par }\pard {\f3\fs24 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par }\pard \sl-240\slmult0 {\f3\fs24 \page }{\b\f3\fs24 Introduction}{\f3\fs24 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 In the beginning compu
ters used simple user instructions (uI) which were directly executed by the computer.  After microprogramming was invented by Wilkes, and mI's were born, the computer instruction set quickly became complex.  Designers used mI lists to implement complex uI
 and the CISC evolved.  The reduced instruction set computer (RISC) is a return to the original computers\_\_no mI lists.  At its best each RISC uI executes in one computer cycle.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Key RISC characteristics are:
\par      *uI execution in one computer cycle
\par      *memory access limited to load and store uI
\par      *simple address modes
\par      *arithmetic, logic, and shift uI only have register operands 
\par      *large register set and register windows
\par      *fixed word length and simple codeword format for uI
\par \tab * microcode replaced by hardwired logic (sometimes)
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 The last RISC characteristic in the list is the preferred implementation for RISC microprocessors.  This characteristic is not mandatory for implementing RISC as will be demonstrated.  RISC computers that do not use a 
RISC microprocessor can and do use microcode to great advantage.
\par }\pard {\f3\fs24 
\par The programmer thinks reduced instruction set computers are different primarily because only load and store uI access memory with one or two simple address modes.  Another difference is that programs need more instructions because the uI are not complex. 
 
\par 
\par }\pard \sl-240\slmult0 {\f3\fs24 The designer thinks RISC is different primarily because the mI lists contain only one or two mI.  
\par }\pard {\f3\fs24 
\par 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 3.1 RISC uI Set}{\f3\fs24 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Again we pull out of thin air a minimum RISC set (Table 3.1) we use to drive the design process.  This time a three address format is used, and the following changes are made to the CISC format to create a RISC format. 

\par }\pard {\f3\fs24 
\par 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 3.1.1 Literals}{\f3\fs24   
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 
In chapter 2 we learned the CISC uI set uses literals to implement some operands.  These literal words followed uI words in the program memory space.  One important idea underlying the risc philosophy is minimizing the number of memory accesses simply bec
ause accesses slow down the program execution process.  Therefore, unlike CISC, the RIS
C uI set uses no separate literal words.  Literals are fields in the RISC uI codewords.  This is why RISC uI have a constant length of one word.  Whereas the length of a CISC uI is one or two or three or four words.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 \page }{\b\f3\fs24 Table 3.1 RISC uI set}{\f3\fs24 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 This uI set is a three address set.
\par r}{\f3\fs24\dn60 x}{\f3\fs24 , r}{\f3\fs24\dn60 y}{\f3\fs24   source registers, r}{\f3\fs24\dn60 z}{\f3\fs24  destination register
\par s}{\f3\fs24\dn60 x}{\f3\fs24  is a source register r}{\f3\fs24\dn60 x}{\f3\fs24  or a 16 bit constant n
\par s}{\f3\fs24\dn60 x}{\f3\fs24 ', r}{\f3\fs24\dn60 z}{\f3\fs24 ' mean their contents are 1's complements
\par N C Z V status bits are updated if special uI scc bit is 1
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 Operators:}{\f3\fs24 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 ADD   s}{\f3\fs24\dn60 x}{\f3\fs24  r}{\f3\fs24\dn60 y}{\f3\fs24  r}{\f3\fs24\dn60 z}{\f3\fs24       r}{\f3\fs24\dn60 z}{\f3\fs24  <\_\_ r}{\f3\fs24\dn60 y}{\f3\fs24  + s}{\f3\fs24\dn60 x}{\f3\fs24  
\par ADDC  s}{\f3\fs24\dn60 x}{\f3\fs24  r}{\f3\fs24\dn60 y}{\f3\fs24  r}{\f3\fs24\dn60 z}{\f3\fs24       r}{\f3\fs24\dn60 z}{\f3\fs24  <\_\_ r}{\f3\fs24\dn60 y}{\f3\fs24  + s}{\f3\fs24\dn60 x}{\f3\fs24  + c 
\par SUB   s}{\f3\fs24\dn60 x}{\f3\fs24  r}{\f3\fs24\dn60 y}{\f3\fs24  r}{\f3\fs24\dn60 z}{\f3\fs24       r}{\f3\fs24\dn60 z}{\f3\fs24  <\_\_ r}{\f3\fs24\dn60 y}{\f3\fs24  + s}{\f3\fs24\dn60 x}{\f3\fs24 '+ 1       (r}{\f3\fs24\dn60 y}{\f3\fs24  \_ s}{
\f3\fs24\dn60 x}{\f3\fs24 )
\par SUBC  s}{\f3\fs24\dn60 x}{\f3\fs24  r}{\f3\fs24\dn60 y}{\f3\fs24  r}{\f3\fs24\dn60 z}{\f3\fs24       r}{\f3\fs24\dn60 z}{\f3\fs24  <\_\_ r}{\f3\fs24\dn60 y}{\f3\fs24  + s}{\f3\fs24\dn60 x}{\f3\fs24 '+ c
\par SUBR  s}{\f3\fs24\dn60 x}{\f3\fs24  r}{\f3\fs24\dn60 y}{\f3\fs24  r}{\f3\fs24\dn60 z}{\f3\fs24       r}{\f3\fs24\dn60 z}{\f3\fs24  <\_\_ s}{\f3\fs24\dn60 x}{\f3\fs24  + r}{\f3\fs24\dn60 y}{\f3\fs24 '+ 1       (s}{\f3\fs24\dn60 x}{\f3\fs24  \_ r}{
\f3\fs24\dn60 y}{\f3\fs24 )
\par SUBRC s}{\f3\fs24\dn60 x}{\f3\fs24  r}{\f3\fs24\dn60 y}{\f3\fs24  r}{\f3\fs24\dn60 z}{\f3\fs24       r}{\f3\fs24\dn60 z}{\f3\fs24  <\_\_ s}{\f3\fs24\dn60 x}{\f3\fs24  + r}{\f3\fs24\dn60 y}{\f3\fs24 '+ c
\par AND   s}{\f3\fs24\dn60 x}{\f3\fs24  r}{\f3\fs24\dn60 y}{\f3\fs24  r}{\f3\fs24\dn60 z}{\f3\fs24       r}{\f3\fs24\dn60 z}{\f3\fs24  <\_\_ s}{\f3\fs24\dn60 x}{\f3\fs24  AND r}{\f3\fs24\dn60 y}{\f3\fs24 
\par OR    s}{\f3\fs24\dn60 x}{\f3\fs24  r}{\f3\fs24\dn60 y}{\f3\fs24  r}{\f3\fs24\dn60 z}{\f3\fs24       r}{\f3\fs24\dn60 z}{\f3\fs24  <\_\_ s}{\f3\fs24\dn60 x}{\f3\fs24  OR  r}{\f3\fs24\dn60 y}{\f3\fs24  
\par XOR   s}{\f3\fs24\dn60 x}{\f3\fs24  r}{\f3\fs24\dn60 y}{\f3\fs24  r}{\f3\fs24\dn60 z}{\f3\fs24       r}{\f3\fs24\dn60 z}{\f3\fs24  <\_\_ s}{\f3\fs24\dn60 x}{\f3\fs24  XOR r}{\f3\fs24\dn60 y}{\f3\fs24  
\par ROTL  s}{\f3\fs24\dn60 x}{\f3\fs24  r}{\f3\fs24\dn60 y}{\f3\fs24  r}{\f3\fs24\dn60 z}{\f3\fs24       r}{\f3\fs24\dn60 z}{\f3\fs24  <\_\_ r}{\f3\fs24\dn60 y}{\f3\fs24  << s}{\f3\fs24\dn60 x}{\f3\fs24   (msb to lsb each shift)
\par SLL   s}{\f3\fs24\dn60 x}{\f3\fs24  r}{\f3\fs24\dn60 y}{\f3\fs24  r}{\f3\fs24\dn60 z}{\f3\fs24       r}{\f3\fs24\dn60 z}{\f3\fs24  <\_\_ r}{\f3\fs24\dn60 y}{\f3\fs24  << s}{\f3\fs24\dn60 x}{\f3\fs24   (zero fill)  
\par SRA   s}{\f3\fs24\dn60 x}{\f3\fs24  r}{\f3\fs24\dn60 y}{\f3\fs24  r}{\f3\fs24\dn60 z}{\f3\fs24       r}{\f3\fs24\dn60 z}{\f3\fs24  <\_\_ r}{\f3\fs24\dn60 y}{\f3\fs24  >> s}{\f3\fs24\dn60 x}{\f3\fs24   (sign fill)  k in s}{\f3\fs24\dn60 x}{\f3\fs24 
\par SRL   s}{\f3\fs24\dn60 x}{\f3\fs24  r}{\f3\fs24\dn60 y}{\f3\fs24  r}{\f3\fs24\dn60 z}{\f3\fs24       r}{\f3\fs24\dn60 z}{\f3\fs24  <\_\_ r}{\f3\fs24\dn60 y}{\f3\fs24  >> s}{\f3\fs24\dn60 x}{\f3\fs24   (zero fill)  shift k bits
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 CONST+   n  r}{\f3\fs24\dn60 z}{\f3\fs24       r}{\f3\fs24\dn60 z}{\f3\fs24  <\_\_ 0^16 ## n
\par CONST\_   n  r}{\f3\fs24\dn60 z}{\f3\fs24       r}{\f3\fs24\dn60 z}{\f3\fs24  <\_\_ 1^16 ## n
\par CONSTH   n  r}{\f3\fs24\dn60 z}{\f3\fs24       r}{\f3\fs24\dn60 z}{\f3\fs24  <\_\_ n ## 0^16
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Scc   s}{\f3\fs24\dn60 x}{\f3\fs24  r}{\f3\fs24\dn60 y}{\f3\fs24  r}{\f3\fs24\dn60 z}{\f3\fs24       If cc true then r}{\f3\fs24\dn60 z}{\f3\fs24  <\_\_ 1 else r}{\f3\fs24\dn60 z}{\f3\fs24  <\_\_ 0
\par                     (form r}{\f3\fs24\dn60 y}{\f3\fs24  \_ r}{\f3\fs24\dn60 x}{\f3\fs24  to set status)(cc in Table 2.2)
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 Load and Store:}{\f3\fs24 
\par Lp   *r}{\f3\fs24\dn60 y}{\f3\fs24 (n) r}{\f3\fs24\dn60 z}{\f3\fs24       r}{\f3\fs24\dn60 z}{\f3\fs24  <\_\_ M[r}{\f3\fs24\dn60 y}{\f3\fs24 +n]
\par Sq   r}{\f3\fs24\dn60 y}{\f3\fs24   *r}{\f3\fs24\dn60 x}{\f3\fs24 (n)     M[r}{\f3\fs24\dn60 x}{\f3\fs24 +n] <\_\_ r}{\f3\fs24\dn60 y}{\f3\fs24 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 where p is B  (byte),          H  (halfword)          or W (word)
\par            BU (byte unsigned), HU (halfword unsigned)
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 where q is B (byte),           H (halfword)           or W (word)
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 Program control:}{\f3\fs24 
\par BZ    n r}{\f3\fs24\dn60 y}{\f3\fs24      if ry=0  then pc <\_\_ pc + n else pc <\_\_ pc+4
\par BNZ   n r}{\f3\fs24\dn60 y}{\f3\fs24      if ry<>0 then pc <\_\_ pc + n else pc <\_\_ pc+4
\par JMP   m        pc  <\_\_ pc + m
\par JMP     r}{\f3\fs24\dn60 y}{\f3\fs24      pc  <\_\_ r}{\f3\fs24\dn60 y}{\f3\fs24 
\par CALL  m        r31 <\_\_ pc, pc <\_\_ pc + m
\par CALL    r}{\f3\fs24\dn60 y}{\f3\fs24      r31 <\_\_ pc, pc <\_\_ r}{\f3\fs24\dn60 y}{\f3\fs24 
\par TRAP           int <\_\_ pc, pc <\_\_ 0
\par RTE            pc  <\_\_ int    (return from exception)
\par HALT           halt
\par NOP            no operation.
\par }\pard {\f3\fs24 
\par 
\par 
\par }\pard \sl-240\slmult0 {\f3\fs24 \page }{\b\f3\fs24 Table 3.2 RISC Condition Codes cc}{\f3\fs24 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 src = source data
\par dst = destination data
\par N C Z V are status bits 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Unconditional cc:                       cc equation (note 1) 
\par                                         C=carry   C=carry'  code
\par                                         \_\_\_\_\_\_\_   \_\_\_\_\_\_\_\_  \_\_\_\_
\par UN   branch always                      none                00hex
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Unsigned compare cc: 
\par LO   dst lower than src                 C'        C         01
\par HS   dst higher or same as src          C         C'        02
\par LS   dst lower or same as src           C'+ Z     C + Z     03
\par HI   dst higher than src                C Z'      C'Z'      04
\par EQ   dst equal to src                   Z         Z         05
\par NE   dst not equal to src               Z'        Z'        06
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Signed compare cc:
\par LT   dst less than src                  NV'+ N'V            07
\par GE   dst greater than or equal to src   NV + N'V'           08
\par LE   dst less than or equal to src      NV'+ N'V + Z        09
\par GT   dst greater than src              (NV + N'V')Z'        0A
\par EQ   dst equal to src                   Z                   0B
\par NE   dst not equal to src               Z'                  0C
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Compare to zero cc:
\par Z    result equal to zero               Z                   0D
\par NZ   result not equal to zero           Z'                  0E
\par P    result is positive, >0             N'Z'                0F
\par N    result is negative, <0             N    (sign)         10
\par NN   result not neg, >0 or =0           N'                  11
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Arithmetic cc:
\par Z    result equal to zero               Z         Z (zero)  12
\par NZ   result not equal to zero           Z'        Z'        13
\par C    result sets carry                  C         C (carry) 14
\par NC   result clears carry                C'        C'        15
\par V    result overflows                   V         V (overf) 16
\par NV   result does not overflow           V'        V'        17
\par B    result sets borrow                 C'        C         18
\par NB   result does not borrow             C         C'        19
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Note 1: use of C or C' is the designer's choice.  
\par }\pard {\f3\fs24 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par }\pard \sl-240\slmult0 {\f3\fs24 \page }{\b\f3\fs24 3.1.2 Address Modes}{\f3\fs24 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 The mI lists for CISC uI needed many mI to implement the various address modes.  By definition RISC uI are supposed to use only one mI.  This is why the only address modes are as follows.
\par      n         signed 16 bit immediate word
\par      r}{\f3\fs24\dn60 j}{\f3\fs24         register direct where j is the register number
\par     *r}{\f3\fs24\dn60 j}{\f3\fs24 (n)     register indirect with offset n
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 3.1.3 Load and Store}{\f3\fs24 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 A
s a practical matter the state of the art always seems to make the ratio of memory access time to logic clock period greater than one.  In this sense memory accesses stall the process as mControl waits.  And so one feature of RISC uI is that memory access
 capability is restricted to what are called load and store uI.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Load uI can read one byte, or a halfword (two bytes), or a word (four bytes) on each load.  In the uI set the data address is the sum of the base address in a register and the immediate halfwo
rd n which is part of the uI codeword.  
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Lp   *r}{\f3\fs24\dn60 y}{\f3\fs24 (n) r}{\f3\fs24\dn60 z}{\f3\fs24       r}{\f3\fs24\dn60 z}{\f3\fs24  <\_\_\_ M[r}{\f3\fs24\dn60 y}{\f3\fs24 +n]
\par Sq   r}{\f3\fs24\dn60 y}{\f3\fs24   *r}{\f3\fs24\dn60 x}{\f3\fs24 (n)     M[r}{\f3\fs24\dn60 x}{\f3\fs24 +n] <\_\_ r}{\f3\fs24\dn60 y}{\f3\fs24 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 where p is B (byte),     BU (byte unsigned) 
\par            H (halfword), HU (halfword unsigned), or W (word)
\par where q is B (byte),     H (halfword)            or W (word)
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 
Memory reads (computer register loads) are full word reads maximizing the data tranfer rate.  Therefore byte and halfword loads require extraction of the byte and halfword from the full word.  Later we show how this is achieved wi
th a one mI solution if special hardware is added to the uData Path.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 3.1.4 Operators}{\f3\fs24 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 
The operator uI operands are registers or immediate halfwords.  The immediate halfwords are incorporated into the uI codeword.  The operator uI specify the usual arithmetic, logical, and shift operations.  The CONST uI are new.  
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24      CONST+   n  r}{\f3\fs24\dn60 z}{\f3\fs24       r}{\f3\fs24\dn60 z}{\f3\fs24  <\_\_ 0^16 ## n
\par      CONST\_   n  r}{\f3\fs24\dn60 z}{\f3\fs24       r}{\f3\fs24\dn60 z}{\f3\fs24  <\_\_ 1^16 ## n
\par      CONSTH   n  r}{\f3\fs24\dn60 z}{\f3\fs24       r}{\f3\fs24\dn60 z}{\f3\fs24  <\_\_ n ## 0^16
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 The immediate n is concatenated with zeros or ones forming a signed 32 bit word.  This is how positive and negative constants are stored in registers.  Any 32 bit number is constructed with a two uI sequence.  Note that n}
{\f3\fs24\dn60 2}{\f3\fs24  must be a positive number.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 \page CONSTH n}{\f3\fs24\dn60 1}{\f3\fs24  r}{\f3\fs24\dn60 y}{\f3\fs24    \tab r}{\f3\fs24\dn60 y}{\f3\fs24 _high <\_\_\_ n}{\f3\fs24\dn60 1}{\f3\fs24           r}{\f3\fs24\dn60 y}{\f3\fs24 _low <\_\_\_ 0
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 OR  n}{\f3\fs24\dn60 2}{\f3\fs24  r}{\f3\fs24\dn60 y}{\f3\fs24  r}{\f3\fs24\dn60 z}{\f3\fs24    \tab r}{\f3\fs24\dn60 z}{\f3\fs24 _high <\_\_\_ n}{\f3\fs24\dn60 1}{\f3\fs24  OR 0     r}{\f3\fs24\dn60 z}{\f3\fs24 _low <\_\_
\_ 0 OR n}{\f3\fs24\dn60 2}{\f3\fs24 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 The compare uI is Scc (set on condition cc).  The true/false report is stored in register r}{\f3\fs24\dn60 z}{\f3\fs24 .
\par   
\par Scc   s}{\f3\fs24\dn60 x}{\f3\fs24  r}{\f3\fs24\dn60 y}{\f3\fs24  r}{\f3\fs24\dn60 z}{\f3\fs24       If cc true then r}{\f3\fs24\dn60 z}{\f3\fs24  <\_\_\_ 1 else r}{\f3\fs24\dn60 z}{\f3\fs24  <\_\_\_ 0
\par                     (form r}{\f3\fs24\dn60 y}{\f3\fs24  \_ s}{\f3\fs24\dn60 x}{\f3\fs24  to set status)(cc in Table 2.2)
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 3.1.5 Program Control}{\f3\fs24 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 RISC branch uI test the flag in a register.  This is consistent with the Scc compare uI which stores the true or false test report in register r}{\f3\fs24\dn60 z}{\f3\fs24 .  Note the simplification:  r}{\f3\fs24\dn60 z}{
\f3\fs24  replaces the (CISC) status register.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Scc   s}{\f3\fs24\dn60 x}{\f3\fs24  r}{\f3\fs24\dn60 y}{\f3\fs24  r}{\f3\fs24\dn60 z}{\f3\fs24 
\par followed by
\par BZ    n r}{\f3\fs24\dn60 y}{\f3\fs24      if r}{\f3\fs24\dn60 y}{\f3\fs24 =0  then pc <\_\_ pc + n else pc <\_\_ pc + 4
\par or
\par BNZ   n r}{\f3\fs24\dn60 y}{\f3\fs24      if r}{\f3\fs24\dn60 y}{\f3\fs24 <>0 then pc <\_\_ pc + n else pc <\_\_ pc + 4
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Unconditional jumps are straightfoward.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 JMP   m             pc  <\_\_ pc + m
\par or
\par JMP   r}{\f3\fs24\dn60 y}{\f3\fs24             pc  <\_\_ r}{\f3\fs24\dn60 y}{\f3\fs24 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Calling a subroutine has two flavors:  
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 1. Jump to a compiled address (pc + m) 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 CALL  m             r31 <\_\_ pc, pc <\_\_ pc + m
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 2. Jump to the address in register r}{\f3\fs24\dn60 y}{\f3\fs24 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 CALL  r}{\f3\fs24\dn60 y}{\f3\fs24             r31 <\_\_ pc, pc <\_\_ r}{\f3\fs24\dn60 y}{\f3\fs24 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 The CISC CALL uI saves the address of the next in line uI (the return address) on a stack.  The RISC CALL uI avoids the memory access to a stack by saving the return address in register r}{\f3\fs24\dn60 31}{\f3\fs24 
.  This calling process is also known as link and jump.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 There is no RET uI because the return address is in r}{\f3\fs24\dn60 31}{\f3\fs24 .  This means JMP r}{\f3\fs24\dn60 31}{\f3\fs24  implements a RET equivalent.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 The int (interrupt) register saves the address of the next-in-line uI when exceptions occur.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 TRAP                int <\_\_ pc, pc <\_\_ 0
\par RTE                 pc  <\_\_ int    \tab (return from exception)
\par HALT                halt
\par \page }{\b\f3\fs24 3.1.6 uI Codeword Formats}{\f3\fs24 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 All codewords are 32 bit words and a six bit opcode allows for 64 uI.  The type}{\f3\fs24\dn60 3}{\f3\fs24 
 codeword (table 3.3) operation field allows for increasing the number of uI beyond 64.  This is not obvious at this point.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Type}{\f3\fs24\dn60 1}{\f3\fs24  format:  Program control uI with the offset operand m need a 6 bit opcode field and an offset field m occupying the remaining 26 bits.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Type}{\f3\fs24\dn60 2}{\f3\fs24 
 format:  Operator uI, constant uI, load and store uI, and branch uI with an immediate operand need a codeword with two register fields and the n field.  The 6 bit opcode field and two 5 bit register fields use 16 bits.  Sixteen bits remain
 for the immediate field n. 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Type}{\f3\fs24\dn60 3}{\f3\fs24 
 format:  The operator uI need three 5 bit register fields for the operands and a 6 bit opcode field.  This leaves 1 bit for the special scc field and 10 bits for the operation field. Status bits NCZV are updated when scc = 1.  NCZV status bits are not ch
anged when scc = 0.
\par }\pard {\f3\fs24 
\par 
\par 
\par 
\par 
\par 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 Table 3.3  uI Codeword Formats}{\f3\fs24 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Type}{\f3\fs24\dn60 1}{\f3\fs24     6              26
\par      |\_\_\_\_\_\_\_\_|\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_|
\par      | opcode |         m                            |
\par      |\_\_\_\_\_\_\_\_|\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_|
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Type}{\f3\fs24\dn60 2}{\f3\fs24     6        5      5        16
\par      |\_\_\_\_\_\_\_\_|\_\_\_\_\_\_|\_\_\_\_\_\_|\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_|
\par      | opcode |  rz  |  ry  |     n                  |
\par      |\_\_\_\_\_\_\_\_|\_\_\_\_\_\_|\_\_\_\_\_\_|\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_|
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Type}{\f3\fs24\dn60 3}{\f3\fs24     6        5      5      5    1    10
\par      |\_\_\_\_\_\_\_\_|\_\_\_\_\_\_|\_\_\_\_\_\_|\_\_\_\_\_\_|\_\_\_\_|\_\_\_\_\_\_\_\_\_\_\_\_|
\par      | opcode |  rz  |  ry  |  rx  |scc | operation  |
\par      |\_\_\_\_\_\_\_\_|\_\_\_\_\_\_|\_\_\_\_\_\_|\_\_\_\_\_\_|\_\_\_\_|\_\_\_\_\_\_\_\_\_\_\_\_|              
\par }\pard {\f3\fs24 
\par 
\par }\pard \sl-240\slmult0 {\f3\fs24 \page }{\b\f3\fs24 3.2 The First Step from uI to User Data Path}{\f3\fs24 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 The pro
cess evolving the RISC user data path from the RISC uI set separates into two major steps.  First the RISC uI operations, operands, address modes, and register transfer statements create the need for some set of combinational circuit blocks and sequential
 circuit blocks interconnected by data buses.  We call this the preliminary user data path.  This first part of the process evolving the RISC user data path (figure 3.1) is similar to the process used to evolve the CISC user data path in figures 2.2 to 2.
11.  
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 
The second major step modifies the preliminary user data path at a detailed circuit level.  The modifications result in execution of RISC uI in one computer cycle.  In other words mI lists consist of one mI.  Strictly speaking the one computer cycle goal 
is not met for the RISC uI that access memory.  We now proceed to implement the first major step.
\par }\pard {\f3\fs24 
\par 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 3.2.1 Bus}{\f3\fs24 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 We arbitrarily select a 32 bit word size for the RISC computer.  Performance dictates that the 32 bits are available simultaneously when a wo
rd is read from any source.  In hardware terms this means 32 wires, one wire per bit, provide parallel access to all word bits.  All the bits in a source word are connected to a destination simultaneously.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Parallel access to two sources requires two source busses x, y.  One result requires one destination bus z.
\par }\pard {\f3\fs24 
\par 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 3.2.2 Register File}{\f3\fs24 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 The operands r}{\f3\fs24\dn60 x}{\f3\fs24 , r}{\f3\fs24\dn60 y}{\f3\fs24 
 are implemented by a set of 32 bit registers. The 32 bit size is consistent with 32 bit data busses, and with our arbitrary decision to design a 32 bit machine.  
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 The number of registers is not defined in Table 3.1 nor do we have a theoretical basis for picking a number.  We selected 32 when we sized the r}{\f3\fs24\dn60 x}{\f3\fs24 , r}{\f3\fs24\dn60 y}{\f3\fs24 , r}{\f3\fs24\dn60 
z}{\f3\fs24  fields at five bits (Table 3.2).
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 The uI ADD r}{\f3\fs24\dn60 x}{\f3\fs24  r}{\f3\fs24\dn60 y}{\f3\fs24  r}{\f3\fs24\dn60 z}{\f3\fs24  reads two registers r}{\f3\fs24\dn60 x}{\f3\fs24  and r}{\f3\fs24\dn60 y}{\f3\fs24 
 in parallel (at the same time), calculates the result, and writes one register r}{\f3\fs24\dn60 z}{\f3\fs24  at another time.  The 32 32\_bit registers are implemented by a register file.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 \page }{\b\f3\fs24 3.2.3 Memory}{\f3\fs24 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 A memory is required to store programs and their data.  The computer treats random access memory as a mass of word registers that is accessed only one word at a time.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 
Reading or writing a memory word requires an address for that word.  The address is stored in the memory address register (mar).  The mar presents a stable address to the memory for the duration of a memory cycle.  Writing a memory requires data to store 
in addition to the address.  The data is placed in the memory buffer register (mbr) prior to initiating a memory access.  The mbr presents stable data to the memory data input during a memory write cycle.  
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 The instruction register (ir) is loaded with uI read from memory.  This is why the memory q outputs (mem) are connected directly to the ir inputs (figure 3.1).  We did not choose to do this in the CISC design.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 3.2.4 Program Counter and Instruction Register}{\f3\fs24 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Any user instruction uI must be fetched from memory, stored somewhe
res in the data path, and executed.  Fetching requires knowing the address of every uI word in a program list.  The easiest way to manage the list of uI is to store the uI words sequentially in memory.  The management process is as follows.  A counting re
gister is loaded with the address of the first uI word in the program.  This stand alone counting register is called the (user) program counter or pc.  The pc is incremented after each fetch of a uI from the uI program list.  In other words the pc always 
points to the next item in the program list.  Fetched uI are stored in the instruction register (ir).  
\par }\pard {\f3\fs24 
\par 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 3.2.5 ALU and Shifter}{\f3\fs24 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 
Arithmetic and logical operators used by the uI are readily implemented by an arithmetic logic unit (alu).  A separate shifter is required because an alu does not implement shift operators.  The CISC one-bit-at-a-time shifter solution is not applicable in
 a RISC data path because execution with one mI implies shifting k bits in one computer cycle.  We use two parallel paths from the
 x, y source busses to the destination bus z in lieu of the single path cascading the alu and shifter.  One path is for the alu and the other path is for a barrel shifter.  The barrel shifter shifts k bits at a time.
\par }\pard {\f3\fs24 
\par 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 3.2.6 Temporary Register}{\f3\fs24 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Executing a uI in one computer cycle implies there is no need for a temporary register holding address or data for a subsequent mI in an mI list to use.  
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 \page }{\b\f3\fs24 Figure 3.1  RISC uData Path - First Step
\par }\pard {\b\f3\fs24 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 \page 3.2.7 Status}{\f3\fs24 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 
The Scc and BZ, BNZ uI functions do not explicitly require a status register however, as will be shown, the Scc uI needs the mcc_report.  So status and mcc logic creating the mcc_report are included in the data path.  The mcc logic implements the cc equat
ions (Table 3.2).  Selection of an equation outputs the corresponding mcc_report.  Five encoded lines from mControl implement mcc_report selection.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 The uI ADDC, SUBC, SUBRC require a status register for the carry bit C.  Therefore we include a NCZV status register even though the need for NCZV bit storage is not obvious here.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 3.2.8 Other Items
\par }\pard {\b\f3\fs24 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 Transfer:}{\f3\fs24 
  Two source buses x, y deliver the source data in parallel to the alu or other destinations.  Results are delivered via one destination bus z.  Direct connections from x to z, and y to z busses allow for faster data transfer for data that does not need p
rocessing by the alu or shifter.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Since more than one output may now connect to the z bus a tri\_state multiplexer is needed.
\par }\pard {\f3\fs24 
\par 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 Zero: }{\f3\fs24 The number zero is still needed.  We implement this with hardwired register rzero (r0).
\par }\pard {\f3\fs24 
\par 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 Stack Pointer:}{\f3\fs24  The stack pointer sp is omitted because a memory stack is not used in RISC.
\par }\pard {\f3\fs24 
\par 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 User data path: }{\f3\fs24 The blocks for individual functions assembled together constitute the uData Path (figure 3.1).
\par }\pard {\f3\fs24 
\par 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 Data Path Control Lines:}{\f3\fs24 
 Signal lines shown with each data path block control the user data path (figure 3.1).  The signal lines originate in the mControl microcontroller (figure 3.11) which is explained later.  
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 \page }{\b\f3\fs24 3.3 The Second Step from uI to User Data Path}{\f3\fs24 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 
The RISC goal is an mI language that allows one mI to represent any uI.  The RISC goal is execution of any uI in one computer cycle.  We start with the four CISC mI (mALU, mMOV, mBR, mNOP) we used to microprogram the CISC uI set.  We find that our experie
nce with the four mI gives us a running start.  Our method is to write the mI list for each RISC uI using the CISC mI set and ask a question.  What changes do we make to the four CISC mI or to the RISC user data path to achieve the go
al of execution in one computer cycle?
\par }\pard {\f3\fs24 
\par 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 3.3.1 RISC mI Word Format}{\f3\fs24 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 
We need to track changes made to the CISC mI fields.  To this end we merge fields from the four CISC mI mALU, mMOV, mBR, and mNOP (Table 2.11) into one mI word.  We use this word as a preliminary RISC mI word format which we proceed to modify as we pursue
 our goal.  
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 |\_\_\_\_\_\_\_|\_\_\_|\_\_\_\_\_\_|\_\_\_\_\_|\_\_\_|\_\_\_\_|\_\_|\_\_\_\_\_|\_\_\_\_|\_\_\_\_\_|\_\_\_\_\_|\_\_\_\_|
\par |moff   |adr| opc  |aluop|sh |mcc |rw|ldz  |selz|sely |selx |bop |
\par |\_\_\_\_\_\_\_|\_\_\_|\_\_\_\_\_\_|\_\_\_\_\_|\_\_\_|\_\_\_\_|\_\_|\_\_\_\_\_|\_\_\_\_|\_\_\_\_\_|\_\_\_\_\_|\_\_\_\_|
\par }\pard {\f3\fs24 
\par 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 3.3.2 Branch to fetch_uI}{\f3\fs24   
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Every CISC mI list ends with the mBR mI.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24      mBR bop un fetch_uI
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 The need for using the above mBR or any other branch mI is eliminated if we add a jmp_to field in every mI codeword (mI not uI).  This is practical to do because the one\_mI\_for\_each\_
uI goal implies a very small RISC mROM.  The jmp_to field may only have seven bits for example. This is small compared to the thousands of mIs in the CISC mI lists stored in the CISC mROM.  The seven bit jmp_to field replaces the 16 bit moff field in the 
preliminary RISC mI word.  The CISC bop are incpc, incsp, decsp, setc, clrc.  The RISC uI set omits CLRC and SETC uI that set and clear the carry.  And, there is no stack pointer in the RISC data path.  This leaves incpc as the one remaining bop.  We chan
ge bop to misc(ellaneous).  The RISC mI word is changed as shown below.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Before:
\par |\_\_\_\_\_\_\_|\_\_\_|\_\_\_\_\_\_|\_\_\_\_\_|\_\_\_|\_\_\_\_|\_\_|\_\_\_\_\_|\_\_\_\_|\_\_\_\_\_|\_\_\_\_\_|\_\_\_\_|
\par |moff   |adr| opc  |aluop|sh |mcc |rw|ldz  |selz|sely |selx |bop |
\par |\_\_\_\_\_\_\_|\_\_\_|\_\_\_\_\_\_|\_\_\_\_\_|\_\_\_|\_\_\_\_|\_\_|\_\_\_\_\_|\_\_\_\_|\_\_\_\_\_|\_\_\_\_\_|\_\_\_\_|
\par After:
\par |\_\_\_\_\_\_\_|\_\_\_|\_\_\_\_\_\_|\_\_\_\_\_|\_\_\_|\_\_\_\_|\_\_|\_\_\_\_\_|\_\_\_\_|\_\_\_\_\_|\_\_\_\_\_|\_\_\_\_|
\par |jmp_to |adr| opc  |aluop|sh |mcc |rw|ldz  |selz|sely |selx |misc|
\par |\_\_\_\_\_\_\_|\_\_\_|\_\_\_\_\_\_|\_\_\_\_\_|\_\_\_|\_\_\_\_|\_\_|\_\_\_\_\_|\_\_\_\_|\_\_\_\_\_|\_\_\_\_\_|\_\_\_\_|
\par                                                              }{\b\f3\fs24 incpc
\par }\pard {\b\f3\fs24 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 \page Figure 3.2a RISC uData Path - Second Step
\par }\pard {\b\f3\fs24 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 \page Figure 3.2b RISC uData Path - Second Step
\par }\pard {\b\f3\fs24 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 \page 3.3.3 Shift Operations}{\f3\fs24   
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 A k-bit shift operation is executed by the barrel shifter.  The barrel shifter is microprogrammed for the desired shift operation by the sh mI field.  The RISC shift uI specify k in the s}{\f3\fs24\dn60 x}{\f3\fs24 
 operand.  S}{\f3\fs24\dn60 x}{\f3\fs24  is an immediate word n or a register r}{\f3\fs24\dn60 x}{\f3\fs24 
.  Therefore the five bits representing the number k are in the n uI field stored in the instruction register ir or the five lsb in a source register r}{\f3\fs24\dn60 x}{\f3\fs24 .  We show these facts using the mI and RTL languages.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24      SLL     r}{\f3\fs24\dn60 x}{\f3\fs24 \tab r}{\f3\fs24\dn60 y}{\f3\fs24  r}{\f3\fs24\dn60 z}{\f3\fs24 :
\par     mALU sll r}{\f3\fs24\dn60 x4..0}{\f3\fs24  r}{\f3\fs24\dn60 y}{\f3\fs24  r}{\f3\fs24\dn60 z}{\f3\fs24  nop      (mALU op sx sy dz rw)
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 R}{\f3\fs24\dn60 x4..0}{\f3\fs24  is the five bit field consisting of r}{\f3\fs24\dn60 x}{\f3\fs24  bits 4 to 0.  Field n (type}{\f3\fs24\dn60 2}{\f3\fs24 
, table 3.3) is 16 bits wide.  However, bits F to 5 are in effect zeros when n represents k because k > 31 serves no purpose.  This is why we are only concerned with bits 4 to 0 and why we ignore bits F to 5.  When s}{\f3\fs24\dn60 x}{\f3\fs24 
 is an iw, field n = k, so that with the uI in the ir we have 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24      SLL     k\tab \tab  r}{\f3\fs24\dn60 y}{\f3\fs24  r}{\f3\fs24\dn60 z}{\f3\fs24 :        (k is field n in a Type}{\f3\fs24\dn60 2}{\f3\fs24  uI)
\par     mALU sll ir}{\f3\fs24\dn60 4..0}{\f3\fs24   r}{\f3\fs24\dn60 y}{\f3\fs24  r}{\f3\fs24\dn60 z}{\f3\fs24  nop     (mALU op sx sy dz rw)
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Ir}{\f3\fs24\dn60 4..0}{\f3\fs24  is the five bit field consisting of ir bits 4 to 0.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24             F            4    0
\par \_\_\_\_\_\_\_\_\_\_\_|\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_|
\par ...      ..|0000 0000 000k kkkk| <-- r}{\f3\fs24\dn60 x}{\f3\fs24  bits or ir n-field bits
\par \_\_\_\_\_\_\_\_\_\_\_|\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_|
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 In a CISC machine there would be a k-register for the k bits driving the shifter.  We would load the k-register from the r}{\f3\fs24\dn60 x}{\f3\fs24  or the ir }{\b\f3\fs24 k}{\f3\fs24 
 fields.  However, performing the k-register load requires use of an extra mI which conflicts with our RISC one\_mI\_per\_uI goal.  
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 Figure 3.3  Source bits Specify Shift Parameter k}{\f3\fs24 
\par }\pard {\f3\fs24 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par }\pard \sl-240\slmult0 {\f3\fs24 \page Additional hardware replaces mI.  One hardware solution is to wire the r}{\f3\fs24\dn60 x}{\f3\fs24  and ir }{\b\f3\fs24 k}{\f3\fs24 
 fields (field n subfields) to a five bit wide 2 x 1 multiplexer.  This means a new control line we call }{\b\f3\fs24 skir}{\f3\fs24  is required to select k from r}{\f3\fs24\dn60 x}{\f3\fs24 
 or ir (figure 3.2).  Skir is a miscellaneous function we assign to the misc field because the bits representing k do not appear on the x or y busses.  Skir is derived from the phrase "}{\b\f3\fs24 s}{\f3\fs24 elect }{\b\f3\fs24 k}{\f3\fs24 
 value from the }{\b\f3\fs24 ir}{\f3\fs24 ."
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Figure 3.3 also shows a third source for k and the corresponding control line skmar.  This is explained in Section 3.3.6 (Load).
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 The barrel shifter path which is parallel to the alu path adds a new choice to selz.  
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24      skir \_\_\_> select k from the ir
\par      sbz  \_\_\_> connect barrel shifter output to the z bus
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 |\_\_\_\_\_\_\_|\_\_\_|\_\_\_\_\_\_|\_\_\_\_\_|\_\_\_|\_\_\_\_|\_\_|\_\_\_\_\_|\_\_\_\_|\_\_\_\_\_|\_\_\_\_\_|\_\_\_\_|
\par |jmp_to |adr| opc  |aluop|sh |mcc |rw|ldz  |selz|sely |selx |misc|
\par |\_\_\_\_\_\_\_|\_\_\_|\_\_\_\_\_\_|\_\_\_\_\_|\_\_\_|\_\_\_\_|\_\_|\_\_\_\_\_|\_\_\_\_|\_\_\_\_\_|\_\_\_\_\_|\_\_\_\_|
\par                                             }{\b\f3\fs24 sbz}{\f3\fs24               incpc
\par                                                              }{\b\f3\fs24 skir
\par }\pard {\b\f3\fs24 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 3.3.4 Scc}{\f3\fs24 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 The set on condition uI is more complex.  We write one mI list for Scc in pseudo code revealing the functions Scc performs.  The sub operation sets up status for decision making.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Scc s}{\f3\fs24\dn60 x}{\f3\fs24  r}{\f3\fs24\dn60 y}{\f3\fs24  r}{\f3\fs24\dn60 z}{\f3\fs24 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24     mALU sub s}{\f3\fs24\dn60 x}{\f3\fs24  r}{\f3\fs24\dn60 y}{\f3\fs24  nop nop         (mALU op sx sy dz rw)
\par If cc is true then
\par     mMOV 1  r}{\f3\fs24\dn60 z}{\f3\fs24   nop                (mMOV s dz rw)
\par else (cc is false)
\par     mMOV 0  r}{\f3\fs24\dn60 z}{\f3\fs24   nop                (mMOV s dz rw)
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 Figure 3.4  Mcc_Report - from Status to z bus}{\f3\fs24 
\par }\pard {\f3\fs24 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par }\pard \sl-240\slmult0 {\f3\fs24 \page The mcc report resulting from execution of the mALU mI has value 1 if cc is true and value 0 if cc is false.  The pseudo code shows that the if\_then\_else-statement is implemented if the mcc report is loaded into r}
{\f3\fs24\dn60 z}{\f3\fs24 .  This means the mcc_report is a source that needs to be placed on the z bus via a tri\_state gate (figure 3.4).  We change the pseudo code to match the new hardware.  The if\_then\_
else statement is replaced by the mcc_report supplying 1 or 0.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Scc s}{\f3\fs24\dn60 x}{\f3\fs24  r}{\f3\fs24\dn60 y}{\f3\fs24  r}{\f3\fs24\dn60 z}{\f3\fs24 
\par     mALU sub s}{\f3\fs24\dn60 x}{\f3\fs24  r}{\f3\fs24\dn60 y}{\f3\fs24  nop nop         (mALU op sx sy dz rw)
\par     mMOV mcc_report r}{\f3\fs24\dn60 z}{\f3\fs24  nop         (mMOV s dz rw)
\par }\pard {\f3\fs24 
\par 
\par }\pard \sl-240\slmult0 {\f3\fs24 
The new list still has more than one mI.  Can we merge the two mI and reduce this to one mI?  The answer is yes if we add a third source field to the mALU mI.  A third source (the mcc_report in this case) available in parallel is necessary because the fir
st two sources feed the alu for the sub operation.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24      mALU op  sx sy s3         rz  nop  (revised)
\par      mALU sub s}{\f3\fs24\dn60 x}{\f3\fs24  r}{\f3\fs24\dn60 y}{\f3\fs24             nop nop  (two sources for sub)
\par      mMOV           mcc_report r}{\f3\fs24\dn60 z}{\f3\fs24   nop  (third source for result)
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Now we merge mALU and mMOV so that the uI Scc executes in one computer cycle.  The hardware change placing the mcc_report on the z bus via a tri-state gate requires the scz choice in the selz field.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24      mALU op  sx sy s3         dz  rw
\par      mALU sub s}{\f3\fs24\dn60 x}{\f3\fs24  r}{\f3\fs24\dn60 y}{\f3\fs24  mcc_report r}{\f3\fs24\dn60 z}{\f3\fs24   nop   (r}{\f3\fs24\dn60 y}{\f3\fs24  - s}{\f3\fs24\dn60 x}{\f3\fs24  sets status)
\par                                          (r}{\f3\fs24\dn60 z}{\f3\fs24  <\_\_\_ mcc_report)
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24      scz  \_\_\_> connect mcc_report to the z bus
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 |\_\_\_\_\_\_\_|\_\_\_|\_\_\_\_\_\_|\_\_\_\_\_|\_\_\_|\_\_\_\_|\_\_|\_\_\_\_\_|\_\_\_\_|\_\_\_\_\_|\_\_\_\_\_|\_\_\_\_|
\par |jmp_to |adr| opc  |aluop|sh |mcc |rw|ldz  |selz|sely |selx |misc|
\par |\_\_\_\_\_\_\_|\_\_\_|\_\_\_\_\_\_|\_\_\_\_\_|\_\_\_|\_\_\_\_|\_\_|\_\_\_\_\_|\_\_\_\_|\_\_\_\_\_|\_\_\_\_\_|\_\_\_\_|
\par                                             sbz              incpc
\par                                             }{\b\f3\fs24 scz}{\f3\fs24               skir
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 \page }{\b\f3\fs24 3.3.5 CONST}{\f3\fs24  
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 The sixteen bit constant n is part of the uI codeword (type}{\f3\fs24\dn60 2}{\f3\fs24 
, table 3.3).  This means we need hardware to read the instruction register low halfword (the n field) and hardware generating the other halfword of 16 zeros or ones.  The 32 bit constants formed from n for various uI are as follows.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 CONST+ n r}{\f3\fs24\dn60 z}{\f3\fs24 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24     mMOV    0}{\f3\fs24\up6 16}{\f3\fs24 ##n  r}{\f3\fs24\dn60 z}{\f3\fs24   nop            (mMOV s dz rw)
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 CONST\_ n r}{\f3\fs24\dn60 z}{\f3\fs24 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24     mMOV    1}{\f3\fs24\up6 16}{\f3\fs24 ##n  r}{\f3\fs24\dn60 z}{\f3\fs24   nop            (mMOV s dz rw)
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 CONSTH n r}{\f3\fs24\dn60 z}{\f3\fs24 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24     mMOV    n##0}{\f3\fs24\up6 16}{\f3\fs24   r}{\f3\fs24\dn60 z}{\f3\fs24   nop            (mMOV s dz rw)
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Immediate word from n
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24    nsigned  msb}{\f3\fs24\up6 16}{\f3\fs24 ##n
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Each of the CONST uI place one of three formed constants on the x bus or the y bus.  It turns out there is a fourth constant.  The operand s}{\f3\fs24\dn60 x}{\f3\fs24  used by other uI is r}{\f3\fs24\dn60 x}{\f3\fs24 
 or a signed n (Table 3.1).  This implies a need for a 4 x 1 mux to select one of the four formed constants (figure 3.5).  The mux output feeds tri\_
state gates whose outputs place the selected constant on the x bus and, or the y bus (figure 3.5).  In this way n+ or n\_ or n high or a sign extended n are placed on source busses x and, or y.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 The bits sc}{\f3\fs24\dn60 1}{\f3\fs24 , sc}{\f3\fs24\dn60 0}{\f3\fs24  (figure 3.5) select the formed n required by CONST+, CONST\_
, CONSTH, or n signed.  Select lines sconx, scony put the programmmed constant on the x, y busses.  
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24                Entry in  Select    Bit Outputs to source bus
\par      uI        mI field  sc}{\f3\fs24\dn60 1}{\f3\fs24   sc}{\f3\fs24\dn60 0}{\f3\fs24   hi16   lo16 (hex)
\par      \_\_\_\_\_     \_\_\_\_\_\_\_\_  \_\_   \_\_   \_\_\_\_   \_\_\_\_
\par      CONST+    scon+     L    L    0000   n
\par      CONST\_    scon\_     L    H    FFFF   n
\par      CONSTH    sconh     H    L    n      0000
\par      nsigned   sn        H    H    msb^16 n
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24      scon+ \_\_\_> selects 0^16##n as the constant
\par      scon\_ \_\_\_> selects 1^16##n as the constant
\par      sconh \_\_\_> selects n##0^16 as the constant
\par      sn    \_\_\_> selects signed n as the constant
\par      scony \_\_\_> puts selected constant on the y bus
\par      sconx \_\_\_> puts selected constant on the x bus
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 \page |\_\_\_\_\_\_\_|\_\_\_|\_\_\_\_\_\_|\_\_\_\_\_|\_\_\_|\_\_\_\_|\_\_|\_\_\_\_\_|\_\_\_\_|\_\_\_\_\_|\_\_\_\_\_|\_\_\_\_|
\par |jmp_to |adr| opc  |aluop|sh |mcc |rw|ldz  |selz|sely |selx |misc|
\par |\_\_\_\_\_\_\_|\_\_\_|\_\_\_\_\_\_|\_\_\_\_\_|\_\_\_|\_\_\_\_|\_\_|\_\_\_\_\_|\_\_\_\_|\_\_\_\_\_|\_\_\_\_\_|\_\_\_\_|
\par                                             sbz              incpc
\par                                             scz              skir
\par                                                  }{\b\f3\fs24 scony sconx scon+
\par                                                              scon\_
\par                                                              sconh
\par                                                              sn}{\f3\fs24  
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 Figure 3.5  Constants - from IR to x and y Busses
\par }\pard {\b\f3\fs24 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 \page 3.3.6 Load}{\f3\fs24   
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 
Load executes in two computer cycles.  The second cycle is a memory access reading data (figure 2.15).  Loads suffer a performance penalty unless a pipeline is used.  [Pipelines are explained in Chapter 4.]  When load executes, the address in the mar is t
he address of the word holding the data (figure 3.6).  This word becomes available at the memory ram q output.  Two of the three data types (halfwords and bytes) require alignment to the destination register least significant bit (lsb).  The shifter align
s the word read from memory to bit 0 with 24, 16, or 8 bit shifts.  The number of bits k to shift is the in_word byte address represented by mar[1..0] (figure 3.6) multiplied by 8.  Why?
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24      k_align = mar[1..0]LLL = a}{\f3\fs24\dn60 1}{\f3\fs24 a}{\f3\fs24\dn60 0}{\f3\fs24 LLL
\par }\pard {\f3\fs24 
\par 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 Figure 3.6  Physical Memory Address}{\f3\fs24 
\par }\pard {\f3\fs24 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par }\pard \sl-240\slmult0 {\f3\fs24 
Two bytes of a halfword data type, and three bytes of a byte data type need to be replaced (filled) with zeros or copies of the msb after alignment is implemented by shifting.  Fill is required because those bytes are parts o
f other halfword data and byte data.  The aligned data is correctly filled by adding a fill-with-zero-or-msb logic circuit at the barrel shifter output (figure 3.7).  Word loads do not need alignment or filling.  This is why the second mI in the LW mI lis
t is a straighforward move.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 LW *r}{\f3\fs24\dn60 y}{\f3\fs24 (n) r}{\f3\fs24\dn60 z}{\f3\fs24 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24      mALU add n   r}{\f3\fs24\dn60 y}{\f3\fs24  mar r            \tab (mALU op sx sy dz rw)
\par      mMOV nop mem r}{\f3\fs24\dn60 z}{\f3\fs24  nop          \tab \tab (mMOV mop s dz rw)
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 \page The second mI in the mI lists for LH and LB uI is an mALU whose op operand is the desired shift 
command and whose misc field specifies the shift and the fill.  The special operators snop, srlb, srab, srlh, and srah specify the correct shift and fill operations. 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 
Halfword and byte loads are aligned to the lsb of the destination register.  Shifted unsigned halfwords and bytes are filled with zeros.  Shifted signed halfwords and bytes are filled with the most significant bit (msb).  Note: the second mI executes in (
time) parallel with the memory read access (figure 2.15).  This avoids increasing the uI execution time to three computer cycles.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 LHU *r}{\f3\fs24\dn60 y}{\f3\fs24 (n) r}{\f3\fs24\dn60 z}{\f3\fs24 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24      mALU add  n   r}{\f3\fs24\dn60 y}{\f3\fs24   mar r            (mALU op sx sy dz rw)
\par      mALU srlh mem nop r}{\f3\fs24\dn60 z}{\f3\fs24   nop          (mALU op sx sy dz rw)
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 LH  *r}{\f3\fs24\dn60 y}{\f3\fs24 (n) r}{\f3\fs24\dn60 z}{\f3\fs24 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24      mALU add  n   r}{\f3\fs24\dn60 y}{\f3\fs24   mar r            (mALU op sx sy dz rw)
\par      mALU srah mem nop r}{\f3\fs24\dn60 z}{\f3\fs24   nop          (mALU op sx sy dz rw)
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 LBU *r}{\f3\fs24\dn60 y}{\f3\fs24 (n) r}{\f3\fs24\dn60 z}{\f3\fs24 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24      mALU add  n   r}{\f3\fs24\dn60 y}{\f3\fs24   mar r            (mALU op sx sy dz rw)
\par      mALU srlb mem nop r}{\f3\fs24\dn60 z}{\f3\fs24   nop          (mALU op sx sy dz rw)
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 LB  *r}{\f3\fs24\dn60 y}{\f3\fs24 (n) r}{\f3\fs24\dn60 z}{\f3\fs24 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24      mALU add  n   r}{\f3\fs24\dn60 y}{\f3\fs24   mar r            (mALU op sx sy dz rw)
\par      mALU srab mem nop r}{\f3\fs24\dn60 z}{\f3\fs24   nop          (mALU op sx sy dz rw)
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24      skmar \_\_> }{\b\f3\fs24 s}{\f3\fs24 elect }{\b\f3\fs24 k}{\f3\fs24  from the }{\b\f3\fs24 mar}{\f3\fs24  to shift the data (figure \tab \tab \tab  \tab \tab \tab  \tab \tab \tab 3.3 and k = mar[1..0] LLL).
\par \tab fillb0 --> fill bytes with zeros
\par \tab fillbm --> fill bytes with msb
\par \tab fillh0 --> fill halfword with zeros
\par \tab fillhm --> fill halfword with msb
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 |\_\_\_\_\_\_\_|\_\_\_|\_\_\_\_\_\_|\_\_\_\_\_|\_\_\_|\_\_\_\_|\_\_|\_\_\_\_\_|\_\_\_\_|\_\_\_\_\_|\_\_\_\_\_|\_\_\_\_|
\par |jmp_to |adr| opc  |aluop|sh |mcc |rw|ldz  |selz|sely |selx |misc|
\par |\_\_\_\_\_\_\_|\_\_\_|\_\_\_\_\_\_|\_\_\_\_\_|\_\_\_|\_\_\_\_|\_\_|\_\_\_\_\_|\_\_\_\_|\_\_\_\_\_|\_\_\_\_\_|\_\_\_\_|
\par                                             sbz              incpc
\par                                             scz              skir 
\par                                                  scony sconx scon\_
\par                                                              scon+
\par                                                              sconh
\par                                 \tab \tab \tab \tab \tab \tab  sn
\par srlb assembles srl, sbz, fillb0\tab \tab \tab \tab \tab \tab  }{\b\f3\fs24 fillb0}{\f3\fs24 
\par srab assembles sra, sbz, fillbm\tab \tab \tab \tab \tab \tab  }{\b\f3\fs24 fillbm}{\f3\fs24 
\par srlh assembles srl, sbz, fillh0\tab \tab \tab \tab \tab \tab  }{\b\f3\fs24 fillh0}{\f3\fs24 
\par srah assembles sra, sbz, fillhm\tab \tab \tab \tab \tab \tab  }{\b\f3\fs24 fillhm}{\f3\fs24 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Important Note: each fill-- asserts skmar.
\par \page }{\b\f3\fs24 Figure 3.7  Load Word, Halfword, and Byte
\par }\pard {\b\f3\fs24 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 \page 3.3.7 Store}{\f3\fs24   
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 
Executing a store requires calculating and loading the address in the mar, loading the data in the mbr, and accessing the memory to write.  This implies that store executes in three computer cycles.  The third cycle, accessing memory and writing data (fig
ure 2.15), stalls the cpu during this third cycle.  The immediate question is whether or not the first two cycles can be merged into one cycle.  Can we merge the load-the-address-in-the-mar and load-the-data-in-the-mbr functions into one mI?
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 
Store copies data from a register to memory.  Halfword and byte data need to be aligned to bit 0, or 8, or 16, or 24 of the mbr register.  (Word data is already aligned to bit 0.)  The uData Path barrel shifter can align the data to bit 0, 8, 16, or 24 wi
th 0, 8, 16, or 24 bit left shifts before loading it into the mbr.  The shift is specified by the type of uI and the in_word byte address (figures 3.3, 3.6).  
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 The aligned word is loaded into the mbr.  The bytes actually written into memory are specified by the uI and the in_word address.  This information is translated into byte access lines.  Four byte access lines w}{
\f3\fs24\dn60 j}{\f3\fs24  specify the memory bank(s) to write (figure 3.8b).  This is why filling is not needed on store.  
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Sq r}{\f3\fs24\dn60 y}{\f3\fs24  *r}{\f3\fs24\dn60 x}{\f3\fs24 (n)                    \tab \tab (q is W or H or B)
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24      mALU add  r}{\f3\fs24\dn60 x}{\f3\fs24   n  mar nop
\par      mALU sllq nop r}{\f3\fs24\dn60 y}{\f3\fs24  mbr w              
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 In this mI scheme the special operand sllq would have to assemble the shift op sll and skmar, and w requires a third computer cycle. 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 The two mI are merged into one mI when we add special hardware (figure 3.8a).  The first special hardware mux connects the r}{\f3\fs24\dn60 y}{\f3\fs24  output q}{\f3\fs24\dn60 y}{\f3\fs24  to the shifter to shift q}{
\f3\fs24\dn60 y}{\f3\fs24  by 8, 16, or 24 bits according to the in_word byte address (selected by skmar).  The second special hardware mux connects shifted r}{\f3\fs24\dn60 y}{\f3\fs24  to the mbr
.  The mneumonic ldmbrqy is a new misc field operator.  Ldmbrqy controls the two multiplexers and mbr loading well as specifying sn to form a 32 bit signed word from ir field n. 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 At the same time a parallel action takes place.  The ALU calculates the address r}{\f3\fs24\dn60 y}{\f3\fs24 
+n and loads the mar.  The two destinations are specified by the marmbr operand in the mALU mI as is shown below.  The ldmar field operator loads the mar.  
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24      ldmbrqy \_\_\_> load shifted r}{\f3\fs24\dn60 y}{\f3\fs24  into mbr bypassing the busses
\par                   in parallel with normal data path action.  Also \tab \tab \tab    \tab \tab \tab    forms 32 bit signed word from ir field n and \tab \tab \tab     \tab \tab \tab    asserts skmar.
\par      marmbr  ---> activates ldmar and ldmbrqy
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Sq r}{\f3\fs24\dn60 y}{\f3\fs24  *r}{\f3\fs24\dn60 x}{\f3\fs24 (n)                    \tab \tab (q is W or H or B)
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24      mALU add r}{\f3\fs24\dn60 x}{\f3\fs24  n marmbr w             (mALU op sx sy dz rw)
\par \page |\_\_\_\_\_\_\_|\_\_\_|\_\_\_\_\_\_|\_\_\_\_\_|\_\_\_|\_\_\_\_|\_\_|\_\_\_\_\_|\_\_\_\_|\_\_\_\_\_|\_\_\_\_\_|\_\_\_\_|
\par |jmp_to |adr| opc  |aluop|sh |mcc |rw|ldz  |selz|sely |selx |misc|
\par |\_\_\_\_\_\_\_|\_\_\_|\_\_\_\_\_\_|\_\_\_\_\_|\_\_\_|\_\_\_\_|\_\_|\_\_\_\_\_|\_\_\_\_|\_\_\_\_\_|\_\_\_\_\_|\_\_\_\_|
\par                                             sbz              incpc
\par                                             scz              skir
\par                                                  scony sconx scon\_
\par                                                              scon+
\par                                                              sconh
\par                                                              sn          \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab  \tab \tab  fillb0
\par marmbr assembles sll, ldmar, ldmbrqy\tab \tab \tab \tab \tab  fillbm
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab  fillh0
\par Important Note: ldmbrqy asserts sn and skmar.\tab \tab  \tab  fillhm
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab }{\b\f3\fs24 ldmbrqy
\par }\pard {\b\f3\fs24 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 Figure 3.8  Store Word, Halfword, and Byte
\par }\pard {\b\f3\fs24 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 \page 3.3.8 Program Control}{\f3\fs24 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Program control uI test a register's contents and execute a branch if the test result is true.  The test requires passing the register word through the ALU to set status.  The branch requires the ALU to form pc+n
.  Therefore execution in one computer cycle implies use of two ALUs.  One ALU processes the test subtraction; at the same time a second ALU performs the addition forming the address.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 The branch uI (Table 3.1) imply forming a 32 bit signed word from the 16 bit n field prior to addition .  Branch uI pseudo code makes the following points.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 BZ n r}{\f3\fs24\dn60 y}{\f3\fs24    \tab if r}{\f3\fs24\dn60 y}{\f3\fs24 =0 then pc <\_\_ pc + n else pc <\_\_ pc + 4
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24      mALU sub r0 r}{\f3\fs24\dn60 y}{\f3\fs24  nop nop
\par      if    Z= 1   (r}{\f3\fs24\dn60 y}{\f3\fs24  = 0)
\par      then  mALU add msb^16##n pc pc nop      (mALU op sx sy dz rw)
\par      else  mNOP
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Call and jump uI imply forming a 32 bit signed word from the 26 bit m field prior to addition.  Call and jump uI pseudo code makes the following points.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 JMP m                              \tab pc <\_\_\_ pc + m
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24      mALU add msb^6##m pc pc nop        (mALU op sx sy dz rw)
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 CALL m                             \tab r}{\f3\fs24\dn60 31}{\f3\fs24  <\_\_\_ pc, pc <\_\_\_ pc + m
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24      mMOV pc r}{\f3\fs24\dn60 31}{\f3\fs24  nop                    (mMOV s dz rw)
\par      mALU add msb^6##m pc pc nop        (mALU op sx sy dz rw)
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 CALL r}{\f3\fs24\dn60 y}{\f3\fs24                             \tab r}{\f3\fs24\dn60 31}{\f3\fs24  <\_\_\_ pc, pc <\_\_\_ ry
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24      mMOV pc r}{\f3\fs24\dn60 31}{\f3\fs24  nop                    (mMOV s dz rw)
\par      mMOV r}{\f3\fs24\dn60 y}{\f3\fs24  pc  nop                    (mMOV s dz rw)
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 These uI add n or m to the pc, or store zero or r}{\f3\fs24\dn60 y}{\f3\fs24  in the pc.  This needs to be done in one computer cycle.  CALL also needs to load the pc into r}{\f3\fs24\dn60 31}{\f3\fs24 
 before taking a new value into the pc.  The user data path is free to load the pc into r}{\f3\fs24\dn60 31}{\f3\fs24 
 via the busses when we add special addition hardware implementing 32 bit word formations from the m or n ir fields as well as the address additions pc+n, pc+m.  And so we need hardware (figure 3.9) to form pc+n, pc+m\tab and to execute pc <-- r}{
\f3\fs24\dn60 y}{\f3\fs24 , pc <-- r0, pc <-- pc+n, pc <-- pc+n. 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 The CALL mI lists with two mMOVs must merge into one mI.  Merging implies adding an operand to the mMOV mI.  We call this operand mop for reasons that will become clear in a moment.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24      mMOV s dz rw
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 becomes
\par \tab mMOV mop s dz rw
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 \page The four operations loading new values into the pc imply a need for four mops in the mMOV operand.  We name the mops addn, addm, rypc, and r0pc.  The revised microcode follows.  
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 BZ n r}{\f3\fs24\dn60 y}{\f3\fs24 
\par    (mALU  op  sx sy s3   rz nop)
\par     mALU  sub r0 r}{\f3\fs24\dn60 y}{\f3\fs24  addn pc nop  
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 JMP  r}{\f3\fs24\dn60 y}{\f3\fs24 
\par    (mMOV  mop s  dz rw)
\par     mMOV  nop r}{\f3\fs24\dn60 y}{\f3\fs24  pc nop
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 JMP  m
\par    (mMOV  mop  s   dz  rw)
\par     mMOV  addm nop nop nop\tab \tab \tab (26_bit_offset selected)
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 CALL  m
\par    (mMOV  mop  s  dz  rw)
\par     mMOV  addm pc r}{\f3\fs24\dn60 31}{\f3\fs24  nop 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 CALL  r}{\f3\fs24\dn60 y}{\f3\fs24 
\par    (mMOV  mop  s  dz  rw)
\par     mMOV  rypc pc r}{\f3\fs24\dn60 31}{\f3\fs24  nop
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 TRAP
\par    (mMOV  mop  s   dz  rw)
\par     mMOV  r0pc pc  int nop
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 RTE
\par    (mMOV  mop  s   dz rw)
\par     mMOV  nop  int pc nop
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24      addn \_\_>       if mcc_report=1 then pc <\_\_ pc + n
\par      addm \_\_>       pc <\_\_ pc + m
\par      rypc \_\_>       pc <\_\_ r}{\f3\fs24\dn60 y}{\f3\fs24 
\par      r0pc \_\_>       pc <\_\_ 0
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 |\_\_\_\_\_\_\_|\_\_\_|\_\_\_\_\_\_|\_\_\_\_\_|\_\_\_|\_\_\_\_|\_\_|\_\_\_\_\_|\_\_\_\_|\_\_\_\_\_|\_\_\_\_\_|\_\_\_\_|
\par |jmp_to |adr| opc  |aluop|sh |mcc |rw|ldz  |selz|sely |selx |misc|
\par |\_\_\_\_\_\_\_|\_\_\_|\_\_\_\_\_\_|\_\_\_\_\_|\_\_\_|\_\_\_\_|\_\_|\_\_\_\_\_|\_\_\_\_|\_\_\_\_\_|\_\_\_\_\_|\_\_\_\_|
\par                                             sbz              incpc
\par                                             scz              skir
\par                                                  scony sconx scon\_
\par                                                              scon+
\par                                                              sconh
\par                                                              sn
\par     \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab  \tab \tab  fillb0
\par                                                         \tab  fillbm
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab  fillh0
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab  fillhm
\par                                                             ldmbrqy  \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab  }{\b\f3\fs24 addn
\par                                                              addm
\par                                                              rypc
\par                                                              r0pc
\par \page Figure 3.9  Program Control Logic
\par }\pard {\b\f3\fs24 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 \page 3.3.9 uData Path}{\f3\fs24 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 The RISC uData Path is set up to implement an mI by asserting the group of control lines specified by the bits in the mI_word representing the uI.  The RISC mI_word is partitioned into fields as shown below.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 |\_\_\_\_\_\_\_|\_\_\_|\_\_\_\_\_\_|\_\_\_\_\_|\_\_\_|\_\_\_\_|\_\_|\_\_\_\_\_|\_\_\_\_|\_\_\_\_\_|\_\_\_\_\_|\_\_\_\_-|
\par |jmp_to |adr| opc  |aluop|sh |mcc |rw|ldz  |selz|sely |selx |misc |
\par |\_\_\_\_\_\_\_|\_\_\_|\_\_\_\_\_\_|\_\_\_\_\_|\_\_\_|\_\_\_\_|\_\_|\_\_\_\_\_|\_\_\_\_|\_\_\_\_\_|\_\_\_\_\_|\_\_\_\_-|
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Each mI_word field activates a subset of user data path control lines.  The lines activated by the
 mI_word fields set up the user data path.  After setup is complete the mI functions are executed in one computer cycle when the mCtrl ASM steps through its states (figure 3.11).  [Reminder: the ASM executes one mI at a time.]
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 uData Path control lines form groups by function.  For example one functional group is the set of lines that activate tri\_
state gates connecting register outputs to the x bus.  This typical group of encoded control lines is represented by a field of bits we name selx (select x).  The
 rest of the control lines in figure 3.2 form other functional groups.  Each of these other groups are assigned to fields (table 3.4).
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 In section 2.5 under operators we explained why the CISC r}{\f3\fs24\dn60 x}{\f3\fs24  and r}{\f3\fs24\dn60 y}{\f3\fs24 
 fields were omitted from the mI_word.  Omission allows us to store only generic mI lists in the mROM.  For the same reason the r}{\f3\fs24\dn60 x}{\f3\fs24 , r}{\f3\fs24\dn60 y}{\f3\fs24 , and r}{\f3\fs24\dn60 z}{\f3\fs24 
 fields are also omitted from the RISC mI_word.  The uI bit lines representing r}{\f3\fs24\dn60 x}{\f3\fs24 , r}{\f3\fs24\dn60 y}{\f3\fs24 , and r}{\f3\fs24\dn60 z}{\f3\fs24  are wired directly to register file inputs.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 The ir bit lines, representing operands m and n, are wired directly to the program control logic (figure 3.9).  Furthermore, the scc bit in the type}{\f3\fs24\dn60 3}{\f3\fs24 
 RISC uI (Table 3.3) is wired into the status logic to activate ldst when the scc bit is one and a type}{\f3\fs24\dn60 3}{\f3\fs24  u}{\i\f3\fs24 I is in the ir.}{\f3\fs24 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 The same ir bit lines represent parts of operands m, n as well as the scc bit and the three operands r}{\f3\fs24\dn60 x}{\f3\fs24 , r}{\f3\fs24\dn60 y}{\f3\fs24 , and r}{\f3\fs24\dn60 z}{\f3\fs24 
.  Since no uI uses more than one set of operands this is not a problem.  
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 
Next, we build the 44 bit mI_word shown in Table 3.5.  The field bits total to 42.  Two spares increase the word width to 44 bits which is a multiple of four (chips are 1, 4, or 8 bits wide).  If 8 bit wide chips are more practical the resulting 48 bit mI
_word has 6 spares. 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 
This mI_word is consistent with the mI_word derived from the fields of the four CISC mI.  The opc field is deleted because the four mI are merged into one mI_word.  The merger makes this mI_word wider than the CISC mI_word.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Table 3.6 provides a recapitulation of the source figures for fields and the new RISC control lines.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 \page }{\b\f3\fs24 Table 3.4  RISC User Data Path Fields}{\f3\fs24 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Reference figure 3.2
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Field     Read sources
\par r}{\f3\fs24\dn60 x}{\f3\fs24         5 encoded lines select 1 of 32 registers
\par r}{\f3\fs24\dn60 y}{\f3\fs24         5 encoded lines select 1 of 32 registers
\par r}{\f3\fs24\dn60 z}{\f3\fs24         5 encoded lines select 1 of 32 registers
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24           Register outputs to x,y busses 
\par selx      3 encoded lines select 1 of 6 register outputs to the                x bus     (nop, int, r}{\f3\fs24\dn60 x}{\f3\fs24 , pc, r0, con, mem)
\par sely      3 encoded lines select 1 of 6 register outputs to the                y bus     (nop, int, r}{\f3\fs24\dn60 y}{\f3\fs24 , pc, r0, con, mem)
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24           Result to z bus 
\par selz      3 encoded lines select 1 of 3 function outputs or 1 of 2             transfer outputs  (nop, saz, sbz, scz, sxz, syz).
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24           Load result on z bus into register 
\par ldz       3 encoded lines select 1 of 6 registers to load from the             z bus or mem    (nop, int, r}{\f3\fs24\dn60 z}{\f3\fs24 , pc, ir, mbr, mar)
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24           Shift data 
\par sh        3 encoded lines select shift functions
\par           (nop, sll, sra, srl) 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24           Process data 
\par aluop     8 lines select alu functions 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24           Branch\_\_
\par mcc       5 lines select mcc_report cc equation 
\par jmp_to    7 lines provide the jump to address 
\par adr       1 line selects next address 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24           Other fields\_\_
\par rw        2 encoded lines select read or write
\par           (nop, r, w)
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 misc      4 encoded lines select various actions 
\par           (nop, incpc, skir, 
\par \tab \tab scon+, scon\_, sconh, sn, 
\par \tab \tab fillb0, fillbm, fillh0, fillhm,
\par \tab \tab ldmbrqy, 
\par \tab \tab addn, addm, rypc, r0pc)
\par }\pard {\f3\fs24 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par }\pard \sl-240\slmult0 {\f3\fs24 \page }{\b\f3\fs24 Table 3.5  RISC User Data Path Control Line Field Encoding}{\f3\fs24 
\par }\pard {\f3\fs24 
\par 
\par }\pard \sl-240\slmult0 {\f3\fs24  2           \tab     2
\par  B A 9 8 7 6 5 4 3 2
\par |\_\_\_\_\_\_\_\_\_\_\_--|\_\_\_|-----|
\par | jmp_to      |adr|spare|
\par |\_\_\_\_\_\_\_\_\_\_--\_|\_\_\_|-----|
\par  next mI        0 jmp_to
\par  address        1 mI_start
\par  0 to 127
\par }\pard {\f3\fs24 
\par 
\par }\pard \sl-240\slmult0 {\f3\fs24  22111111 1                 1 0                             0
\par  10FEDCBA 9 8 7 6 5 4 3 2 1 0 F E D C B A 9 8 7 6 5 4 3 2 1 0
\par |\_\_\_\_\_\_\_\_|\_\_\_\_\_|\_\_\_\_\_\_\_\_\_|\_\_\_|\_\_\_\_\_|\_\_\_\_\_|\_\_\_\_\_|\_\_\_\_\_|\_\_\_\_\_\_\_|
\par | aluop  | sh  | mcc     |rw |ldz  |selz |sely |selx | misc  |
\par |\_\_\_\_\_\_\_\_|\_\_\_\_\_|\_\_\_\_\_\_\_\_\_|\_\_\_|\_\_\_\_\_|\_\_\_\_\_|\_\_\_\_\_|\_\_\_\_\_|\_\_\_\_\_\_\_|
\par  add       nop   un       nop nop   nop   nop   nop   nop
\par  addc      rotl  see cc   r   ldmbr saz               incpc
\par  +1        sll   in       w   ldmar sxz   smemy smemx skir
\par  \_1        sra   Table        ldrz  syz   sr0y  sr0x  scon+
\par  neg       srl   3.6          ldir  sbz   sryy  srxx  scon-
\par  sub                                scz   scony sconx sconh
\par  subc                         ldint       sinty sintx sn
\par  subr                         ldpc        spcy  spcx  fillb0
\par  subrc                                                fillbm
\par                                                       fillh0
\par  not                                                  fillhm
\par  \_one
\par  zero\tab \tab \tab \tab \tab \tab \tab \tab \tab     ldmbrqy
\par  and
\par  or\tab \tab \tab \tab \tab \tab \tab \tab \tab \tab     addn  
\par  xor\tab \tab \tab \tab \tab \tab \tab \tab \tab \tab     addm  
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab     rypc  
\par                                  \tab \tab \tab \tab     r0pc  
\par srlb assembles srl, sbz, fillb0
\par srab assembles sra, sbz, fillbm
\par srlh assembles srl, sbz, fillh0
\par srah assembles sra, sbz, fillhm
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Important Note: each fill-- asserts skmar.
\par }\pard {\f3\fs24 
\par 
\par }\pard \sl-240\slmult0 {\f3\fs24 marmbr assembles sll, ldmar, ldmbrqy
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Important Note: ldmbrqy asserts sn and skmar.
\par }\pard {\f3\fs24 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par }\pard \sl-240\slmult0 {\f3\fs24 \page }{\b\f3\fs24 Table 3.6  uData Path Fields and new Control lines}{\f3\fs24 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 uI analysis gives rise to user data path control fields 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 figure 3.2   r}{\f3\fs24\dn60 x}{\f3\fs24     r}{\f3\fs24\dn60 y}{\f3\fs24     r}{\f3\fs24\dn60 z}{\f3\fs24 
\par              selx  sely  selz   ldz 
\par              aluop sh
\par              rw    mcc   misc
\par figure 3.10  adr   jmp_to
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Note: k has three sources.  This is why k cannot be a mI field.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 mI execution in one computer cycle adds control lines:
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 figure 3.3   skir, skmar 
\par figure 3.4   scz
\par figure 3.5   scony, sconx, sc}{\f3\fs24\dn60 1}{\f3\fs24 , sc}{\f3\fs24\dn60 0}{\f3\fs24  
\par \tab \tab    Note: sc}{\f3\fs24\dn60 1}{\f3\fs24 , sc}{\f3\fs24\dn60 0}{\f3\fs24  encoded from scon+, scon\_, sconh, sn.
\par figure 3.7   smemy, smemx, L}{\f3\fs24\dn60 2}{\f3\fs24 , L}{\f3\fs24\dn60 1}{\f3\fs24 , L}{\f3\fs24\dn60 0}{\f3\fs24 
\par              Note: L}{\f3\fs24\dn60 j}{\f3\fs24  encoded from fillb0, fillbm, fillh0, fillhm.
\par figure 3.8   ldmbrqy,  w}{\f3\fs24\dn60 3}{\f3\fs24  w}{\f3\fs24\dn60 2}{\f3\fs24  w}{\f3\fs24\dn60 1}{\f3\fs24  w}{\f3\fs24\dn60 0}{\f3\fs24   (to memory)
\par              Note: w}{\f3\fs24\dn60 j}{\f3\fs24  encoded from mar[1..0], SW, SH, SB
\par figure 3.9   addn, addm, rypc, r0pc
\par }\pard {\f3\fs24 
\par 
\par 
\par 
\par }}