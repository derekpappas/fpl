{\rtf1\ansi \deff4\deflang1033{\fonttbl{\f0\froman\fcharset0\fprq2 Tms Rmn;}{\f1\froman\fcharset2\fprq2 Symbol;}{\f2\fswiss\fcharset0\fprq2 Helv;}{\f3\fmodern\fcharset0\fprq1 Courier{\*\falt Courier};}
{\f4\froman\fcharset0\fprq2 Times New Roman;}{\f5\fswiss\fcharset0\fprq2 Arial;}{\f6\froman\fcharset0\fprq2 MS Serif;}{\f7\fswiss\fcharset0\fprq2 MS Sans Serif;}{\f8\froman\fcharset0\fprq2 Times;}{\f9\fswiss\fcharset0\fprq2 Helvetica;}
{\f10\fswiss\fcharset0\fprq2 System;}{\f11\fmodern\fcharset0\fprq1 Courier New;}{\f12\fdecor\fcharset2\fprq2 ZapfDingbats;}{\f13\fnil\fcharset2\fprq2 Marlett;}{\f14\fswiss\fcharset238\fprq2 Arial CE;}{\f15\fswiss\fcharset204\fprq2 Arial CYR;}
{\f16\fswiss\fcharset161\fprq2 Arial Greek;}{\f17\fswiss\fcharset162\fprq2 Arial TUR;}{\f18\fswiss\fcharset186\fprq2 Arial Baltic;}{\f19\fmodern\fcharset238\fprq1 Courier New CE;}{\f20\fmodern\fcharset204\fprq1 Courier New CYR;}
{\f21\fmodern\fcharset161\fprq1 Courier New Greek;}{\f22\fmodern\fcharset162\fprq1 Courier New TUR;}{\f23\fmodern\fcharset186\fprq1 Courier New Baltic;}{\f24\fmodern\fcharset0\fprq1 Lucida Console;}{\f25\froman\fcharset238\fprq2 Times New Roman CE;}
{\f26\froman\fcharset204\fprq2 Times New Roman CYR;}{\f27\froman\fcharset161\fprq2 Times New Roman Greek;}{\f28\froman\fcharset162\fprq2 Times New Roman TUR;}{\f29\froman\fcharset186\fprq2 Times New Roman Baltic;}{\f30\fnil\fcharset2\fprq2 Wingdings;}
{\f31\fswiss\fcharset0\fprq2 Verdana;}{\f32\fswiss\fcharset0\fprq2 Arial Black;}{\f33\fscript\fcharset0\fprq2 Comic Sans MS;}{\f34\froman\fcharset0\fprq2 Georgia;}{\f35\fswiss\fcharset0\fprq2 Franklin Gothic Medium;}
{\f36\froman\fcharset0\fprq2 Palatino Linotype;}{\f37\fswiss\fcharset0\fprq2 Tahoma;}{\f38\fswiss\fcharset0\fprq2 Trebuchet MS;}{\f39\froman\fcharset2\fprq2 Webdings;}{\f40\fscript\fcharset1\fprq2 Estrangelo Edessa;}{\f41\fnil\fcharset1\fprq2 Gautami;}
{\f42\fnil\fcharset1\fprq2 Latha;}{\f43\fnil\fcharset1\fprq2 Mangal;}{\f44\fnil\fcharset1\fprq2 MV Boli;}{\f45\fnil\fcharset1\fprq2 Raavi;}{\f46\fnil\fcharset1\fprq2 Shruti;}{\f47\fnil\fcharset1\fprq2 Tunga;}{\f48\froman\fcharset0\fprq2 Sylfaen;}
{\f49\fswiss\fcharset0\fprq2 Microsoft Sans Serif;}{\f50\fswiss\fcharset0\fprq2 Arial Narrow;}{\f51\fdecor\fcharset0\fprq2 Curlz MT;}{\f52\froman\fcharset0\fprq2 Engravers MT;}{\f53\fswiss\fcharset0\fprq2 Franklin Gothic Book;}
{\f54\fswiss\fcharset0\fprq2 Franklin Gothic Demi Cond;}{\f55\fswiss\fcharset0\fprq2 Franklin Gothic Heavy;}{\f56\fswiss\fcharset0\fprq2 Franklin Gothic Medium Cond;}{\f57\fswiss\fcharset0\fprq2 Century Gothic;}
{\f58\fscript\fcharset0\fprq2 Edwardian Script ITC;}{\f59\fdecor\fcharset0\fprq2 Jokerman;}{\f60\fdecor\fcharset0\fprq2 Juice ITC;}{\f61\fswiss\fcharset0\fprq2 Lucida Sans Unicode;}{\f62\fscript\fcharset0\fprq2 Mistral;}
{\f63\fmodern\fcharset0\fprq2 OCR A Extended;}{\f64\froman\fcharset0\fprq2 Rockwell;}{\f65\froman\fcharset2\fprq2 Wingdings 2;}{\f66\froman\fcharset2\fprq2 MT Extra;}{\f67\fswiss\fcharset0\fprq2 Impact;}{\f68\fmodern\fcharset2\fprq1 MS LineDraw;}
{\f69\fdecor\fcharset0\fprq2 Algerian;}{\f70\fswiss\fcharset0\fprq2 Arial Rounded MT Bold;}{\f71\froman\fcharset0\fprq2 Bookman Old Style;}{\f72\fdecor\fcharset0\fprq2 Braggadocio;}{\f73\fswiss\fcharset0\fprq2 Britannic Bold;}
{\f74\fscript\fcharset0\fprq2 Brush Script MT;}{\f75\fdecor\fcharset0\fprq2 Colonna MT;}{\f76\fdecor\fcharset0\fprq2 Desdemona;}{\f77\froman\fcharset0\fprq2 Footlight MT Light;}{\f78\fdecor\fcharset0\fprq2 Kino MT;}
{\f79\froman\fcharset0\fprq2 Wide Latin;}{\f80\fscript\fcharset0\fprq2 Matura MT Script Capitals;}{\f81\fdecor\fcharset0\fprq2 Playbill;}{\f82\fnil\fcharset0\fprq2 OpenSymbol;}{\f83\fswiss\fcharset2\fprq2 WP Phonetic;}
{\f84\fnil\fcharset2\fprq2 WP MathExtendedB;}{\f85\fmodern\fcharset0\fprq1 WP BoxDrawing;}{\f86\fnil\fcharset2\fprq2 WP IconicSymbolsB;}{\f87\fnil\fcharset2\fprq2 WP Greek Helve;}{\f88\fnil\fcharset2\fprq2 WP MathExtendedA;}
{\f89\froman\fcharset2\fprq2 WP CyrillicA;}{\f90\fnil\fcharset2\fprq2 WP Japanese;}{\f91\fnil\fcharset2\fprq2 WP MathB;}{\f92\fnil\fcharset2\fprq2 WP IconicSymbolsA;}{\f93\fnil\fcharset2\fprq2 WP Arabic Sihafa;}
{\f94\froman\fcharset2\fprq2 WP MultinationalA Roman;}{\f95\fnil\fcharset0\fprq2 WP CyrillicB;}{\f96\fnil\fcharset2\fprq2 WP MultinationalB Roman;}{\f97\fmodern\fcharset2\fprq1 WP Greek Courier;}{\f98\fnil\fcharset2\fprq2 WP MathA;}
{\f99\fnil\fcharset2\fprq2 WP ArabicScript Sihafa;}{\f100\fnil\fcharset2\fprq2 WP Greek Century;}{\f101\fnil\fcharset2\fprq2 WP TypographicSymbols;}{\f102\fnil\fcharset2\fprq2 WP Hebrew David;}{\f103\fnil\fcharset2\fprq2 WP MultinationalA Helve;}
{\f104\fnil\fcharset2\fprq2 WP MultinationalB Helve;}{\f105\fmodern\fcharset2\fprq1 WP MultinationalA Courier;}{\f106\fmodern\fcharset2\fprq1 WP MultinationalB Courier;}{\f107\fscript\fcharset0\fprq2 Ribbon131 Bd BT;}
{\f108\froman\fcharset0\fprq2 Humanst521 Lt BT;}{\f109\froman\fcharset0\fprq2 GeoSlab703 Lt BT;}{\f110\fswiss\fcharset0\fprq2 Swis721 BlkEx BT;}{\f111\fswiss\fcharset0\fprq2 Humanst521 Cn BT;}{\f112\fdecor\fcharset0\fprq2 Onyx BT;}
{\f113\fdecor\fcharset0\fprq2 CaslonOpnface BT;}{\f114\fswiss\fcharset0\fprq2 EngraversGothic BT;}{\f115\fscript\fcharset0\fprq2 ShelleyVolante BT;}{\f116\froman\fcharset0\fprq2 BernhardMod BT;}{\f117\froman\fcharset0\fprq2 Arrus BT;}
{\f118\fscript\fcharset0\fprq2 OzHandicraft BT;}{\f119\fnil\fcharset0\fprq2 Sydnie;}{\f120\froman\fcharset255\fprq2 Roman;}{\f121\fscript\fcharset255\fprq2 Script;}{\f122\fmodern\fcharset255\fprq2 Modern;}{\f123\fswiss\fcharset0\fprq1 MS Dialog;}
{\f124\fmodern\fcharset0\fprq0 Elite;}{\f125\fmodern\fcharset0\fprq0 Prestige;}{\f126\fswiss\fcharset0\fprq0 Letter Gothic;}{\f127\fmodern\fcharset0\fprq0 GothicPS;}{\f128\fmodern\fcharset0\fprq0 CubicPS;}{\f129\fmodern\fcharset0\fprq0 LinePrinter;}
{\f130\fmodern\fcharset0\fprq0 AvantGarde;}{\f131\fswiss\fcharset0\fprq0 Helvetica-Narrow;}{\f132\fmodern\fcharset0\fprq0 Metro;}{\f133\fswiss\fcharset0\fprq0 Presentation;}{\f134\fmodern\fcharset0\fprq0 APL;}{\f135\fmodern\fcharset0\fprq0 OCRA;}
{\f136\fmodern\fcharset0\fprq0 OCRB;}{\f137\froman\fcharset0\fprq0 Bookman;}{\f138\froman\fcharset0\fprq0 Madaleine;}{\f139\froman\fcharset0\fprq0 ZapfHumanist;}{\f140\froman\fcharset0\fprq0 Classic;}{\f141\froman\fcharset0\fprq0 Roman f;}
{\f142\froman\fcharset0\fprq0 Roman g;}{\f143\froman\fcharset0\fprq0 Roman h;}{\f144\froman\fcharset0\fprq0 NewCenturySchlbk;}{\f145\froman\fcharset0\fprq0 Palatino;}{\f146\froman\fcharset0\fprq0 Souvenir;}{\f147\froman\fcharset0\fprq0 Garamond;}
{\f148\froman\fcharset0\fprq0 Caledonia;}{\f149\froman\fcharset0\fprq0 Bodini;}{\f150\froman\fcharset0\fprq0 University;}{\f151\fscript\fcharset0\fprq0 ScriptPS;}{\f152\fscript\fcharset0\fprq0 Script c;}{\f153\fscript\fcharset0\fprq0 Script d;}
{\f154\fscript\fcharset0\fprq0 Commercial Script;}{\f155\fscript\fcharset0\fprq0 Park Avenue;}{\f156\fscript\fcharset0\fprq0 Coronet;}{\f157\fscript\fcharset0\fprq0 Script h;}{\f158\fscript\fcharset0\fprq0 Greek;}{\f159\froman\fcharset0\fprq0 Kana;}
{\f160\froman\fcharset0\fprq0 Hebrew;}{\f161\froman\fcharset0\fprq0 Roman s;}{\f162\froman\fcharset0\fprq0 Russian;}{\f163\froman\fcharset0\fprq0 Roman u;}{\f164\froman\fcharset0\fprq0 Roman v;}{\f165\froman\fcharset0\fprq0 Roman w;}
{\f166\fdecor\fcharset0\fprq0 Narrator;}{\f167\fdecor\fcharset0\fprq0 Emphasis;}{\f168\fdecor\fcharset0\fprq0 ZapfChancery;}{\f169\fdecor\fcharset0\fprq0 Decor d;}{\f170\fdecor\fcharset0\fprq0 Old English;}{\f171\fdecor\fcharset0\fprq0 Decor f;}
{\f172\fdecor\fcharset0\fprq0 Decor g;}{\f173\fdecor\fcharset0\fprq0 Cooper Black;}{\f174\fnil\fcharset0\fprq0 Math7;}{\f175\fnil\fcharset0\fprq0 Math8;}{\f176\fnil\fcharset0\fprq0 EAN;}{\f177\fnil\fcharset0\fprq0 PCline;}
{\f178\fnil\fcharset0\fprq0 Tech h;}{\f179\fmodern\fcharset0\fprq0 Courier Bold{\*\falt Courier};}{\f180\fmodern\fcharset0\fprq0 Courier Oblique{\*\falt Courier};}}{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;
\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;
\red128\green128\blue128;\red192\green192\blue192;}{\stylesheet{\f4\fs20 \snext0 Normal;}{\*\cs10 \additive Default Paragraph Font;}{\s15\tqc\tx4320\tqr\tx8640 \f4\fs20 \sbasedon0\snext15 header;}{\s16\tqc\tx4320\tqr\tx8640 \f4\fs20 \sbasedon0\snext16 
footer;}}{\info{\author Nicholas L. Pappas, Ph.D.}{\creatim\yr1910\mo2\dy1}{\revtim\yr1910\mo2\dy1}{\version1}{\edmins1}{\nofpages0}{\nofwords0}{\nofchars0}{\vern49203}}\margl1440\margr1152\margt720\margb720 
\facingp\ftnbj\aenddoc\ftnrestart\pgnstart217\notabind\noextrasprl\sprsspbf\brkfrm\hyphcaps0 \fet0\sectd \sbknone\pgnrestart\pgnstarts217\linex576\footery480\endnhere {\headerl \pard\plain \qj\li-1440\ri-1152\sl-240\slmult0 \f4\fs20 {\f3\fs24 
                                Computer Architecture and Design
\par }}{\headerr \pard\plain \qj\li-1440\ri-1152\sl-240\slmult0 \f4\fs20 {\f3\fs24                                 Computer Architecture and Design
\par }}{\footerl \pard\plain \qj\li-1440\ri-1152\sl-240\slmult0 \f4\fs20 {\f3\fs24  (C) Copyright 1991 Nicholas. L. Pappas, PhD.  910801          \chpgn 
\par }}{\footerr \pard\plain \qj\li-1440\ri-1152\sl-240\slmult0 \f4\fs20 {\f3\fs24  (C) Copyright 1991 Nicholas. L. Pappas, PhD.  910801          \chpgn 
\par }}{\*\pnseclvl1\pnucrm\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl2\pnucltr\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl3\pndec\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl4\pnlcltr\pnstart1\pnindent720\pnhang{\pntxta )}}
{\*\pnseclvl5\pndec\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl6\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl8
\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}\pard\plain \sl-240\slmult0 \f4\fs20 {\b\f3\fs24 2.4 From uI to User Data Path}{\f3\fs24 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 
A data path is some set of combinational circuit blocks and sequential circuit blocks interconnected by data buses.  The operands of the uI user instructions specify some of these blocks, the address modes require other blocks, and the uI register transfe
r statements specify the remainder.  In other words Table 2.1 essentially specifies the computer we intend to design.  In what follows we make explicit some theoretical inadequacies of computer design when we make arbitrary but practical decisions as we d
emonstrate that the data path (figure 2.11) implements the user instructon (uI) set.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 Bus:}{\f3\fs24 
  Earlier we arbitrarily selected a 32 bit word size for our computer.  Performance dictates that the 32 bits are available simultaneously when a word is read from any source.  In hardware terms this means 32 wires, one wire per bit, are required to conne
ct a source to a destination.  This collection of 32 wires is called a bus.  
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 The bus provides parallel access to all word bits.  For example, when the logical AND of t
wo words is to be calculated parallel access means the AND operation is performed on all bit pairs at the same time.  On the other hand use of two one wire busses implies one bit pair at a time processing.  A serial bus takes 32 times longer to calculate 
a result.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Parallel access to two sources requires two 32 wire source busses x, y.  One result requires one 32 wire destination bus z (figure 2.2).
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 Figure 2.2  Busses and a Memory Module (see note 1)}{\f3\fs24 
\par }\pard {\f3\fs24 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par }\pard \sl-240\slmult0 {\f3\fs24 Note 1: the schematic in figure 2.2 is incorrect because the outputs common to either source bus are shorted together.  The error is corrected by adding tri\_state drivers to isolate the outputs.  Tri\_
state drivers implement the multiplexing functions (figure 2.3) necessary to isolate outputs connected to the same bus and to connect outputs to the x and, or y source busses.
\par \page }{\b\f3\fs24 Figure 2.3  Tri-state Multiplexers
\par }\pard {\b\f3\fs24 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 \page Register File: }{\f3\fs24  The operands r}{\f3\fs24\dn60 x}{\f3\fs24 , r}{\f3\fs24\dn60 y}{\f3\fs24 
 are implemented by 32 bit registers.  This is consistent with our arbitrary decision to design a 32 bit machine.  
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 
The number of registers is not defined in Table 2.1 nor do we have a theoretical basis for picking a number.  A not very satisfactory yet practical rule of thumb is:  the more the better.  How-many-registers and the 32 bits decision are actually performan
ce questions (see section 1.5).  Nevertheless we need a number so we select 16 and move on.  
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 The uI ADD r}{\f3\fs24\dn60 x}{\f3\fs24  r}{\f3\fs24\dn60 y}{\f3\fs24  reads two registers r}{\f3\fs24\dn60 x}{\f3\fs24  and r}{\f3\fs24\dn60 y}{\f3\fs24 
 in parallel (at the same time), calculates the result, and writes one register r}{\f3\fs24\dn60 y}{\f3\fs24 
 at another time.  Therefore the register file has two output ports each connected to one of the two source buses to enable the reading of two registers at the same time.  And, the destination (result) bus is connected to the input port allowing writing o
f one register (figure 2.4).  Sixteen means parameters x and y range from 0 to F hex.  Four encoded register file control lines select r}{\f3\fs24\dn60 x}{\f3\fs24 , four encoded lines select r}{\f3\fs24\dn60 y}{\f3\fs24 , and t
wo load lines enable writes to the register file.  
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 Figure 2.4  Register File
\par }\pard {\b\f3\fs24 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 \page Memory: }{\f3\fs24 
 A memory is required for programs and their data.  The computer treats random access memory as a mass of registers.  Know that the price paid for a low cost per memory register is the limited ability to read or write only one memory register or word at a
 time.  
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Reading a memory fetches the contents of a word.  Reading requires an address to select the word.  The address is stored in what is called 
the memory address register (mar) in order to hold the address for the duration of a memory cycle.  
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Writing a memory requires data to store in addition to the address.  The data is stored in the memory buffer register (mbr) in order to hold the data during a memory write cycle (figure 2.5).
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 The typical design choice makes the mbr a memory input as well as a memory output register.  However uI execution is expedited if the mbr is bypassed when reading memory.  This becomes clear when the process for fetch
ing uI is explained in the microprogramming discussion.
\par }\pard {\f3\fs24 
\par 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 Figure 2.5  Memory Module 
\par }\pard {\b\f3\fs24 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 \page Program Counter and Instruction Register: }{\f3\fs24  Any user instruction uI must be fetched from memory, stored somewheres in the data path
, and executed.  Fetching requires knowing the address of every uI word in a program list.  The easiest way to manage the list of uI is to store the uI words and associated literals sequentially in memory.  The management process is as follows.  A countin
g register is loaded with the address of the first uI word in the program.  This stand alone counting register is called the (user) program counter or pc (figure 2.6).  The pc is incremented after each fetch of a uI or literal from the uI program list.  I
n other words the pc always points to the next item in the program list.  Fetched uI are stored in the instruction register (ir).  Fetched literals are used by other blocks in the data path.  
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 Figure 2.6  Program Counter (pc) and Instruction Register (ir)
\par }\pard {\b\f3\fs24 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 ALU and Shifter: }{\f3\fs24  Arithmetic and logical operator
s used by the uI are readily implemented by an arithmetic logic unit (alu).  A separate shifter is required because an alu does not implement shift operators.  One choice places the shifter at the alu output.  And, a shifter operation only shifts one bit 
per to the left or to the right (figure 2.7).
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 Figure 2.7  Arithmetic Logic Unit (alu) and Shifter
\par }\pard {\b\f3\fs24 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 \page Temporary Register:}{\f3\fs24   The uI EXCH r}{\f3\fs24\dn60 x}{\f3\fs24  r}{\f3\fs24\dn60 y}{\f3\fs24  exchanges the contents of r}{\f3\fs24\dn60 x}{\f3\fs24  and r}{\f3\fs24\dn60 y}{\f3\fs24 
.  The actual exchange requires a third register we call rtemp.
\par           rtemp <\_\_\_ r}{\f3\fs24\dn60 x}{\f3\fs24 
\par              r}{\f3\fs24\dn60 x}{\f3\fs24  <\_\_\_ r}{\f3\fs24\dn60 y}{\f3\fs24 
\par              r}{\f3\fs24\dn60 y}{\f3\fs24  <\_\_\_ rtemp
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 The exchange process shows there is a need for an rtemp holding intermediate results as uI execute (figure 2.8).
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 Figure 2.8  Temporary Register (rtemp or rt)
\par }\pard {\b\f3\fs24 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 Figure 2.9  Stack Pointer (sp), Status Register (st) and Logic
\par }\pard {\b\f3\fs24 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 \page Status: }{\f3\fs24 
Operator uI clear and set N C Z V status bits consistent with the results of operations.  Status logic inputs are the alu and shifter outputs.  Status logic implements equations whose outputs are the N C Z V status bit reports.  The status bits are stored
 in the status register.  The uI SETC and CLRC require set-carry and clear-carry lines.  The status bits are held in the status register until the next operator uI executes.  The status bits are inputs to the mcc logic.  The mcc logic implements the cc eq
uations (table 2.2).  Selection of an equation outputs the corresponding mcc_report.  Five encoded lines from mControl implement mcc_report selection (figure 2.9).
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 Stack Pointer: }{\f3\fs24  A stack needs a stack pointer that can be incremented and decremented (figure 2.9).  The stack concept is explained in section 2.12.2.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 Transfer: }{\f3\fs24 We use two source buses x, y so data can be delivered from two sources in parallel to the alu or other destinations.  Results are delivered via one destination bus z.  Direct connections 
from x to z, and y to z buses allow for faster data transfer for data that does not need processing by the alu (figure 2.10).
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Now that three outputs need to connect to the z bus a tri\_state multiplexer controlled by select lines saz, sxz, syz is needed (figures 2.9, 2.10).
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 Zero: }{\f3\fs24 The number zero is always needed.  ZERO is implemented with a hardwired register rzero (fig 2.10).  Rzero is also written as r0.  This r0 is }{\b\f3\fs24 not}{\f3\fs24  register file r}{\f3\fs24\dn60 0}{
\f3\fs24 .
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 User data path: }{\f3\fs24 The blocks for individual functions assembled together constitute the uData Path (figure 2.11).
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 Figure 2.10  Rzero (r0), Source to Destination Transfers
\par }\pard {\b\f3\fs24 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 \page Figure 2.11  CISC User Data Path
\par }\pard {\b\f3\fs24 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 \page Data Path Control Lines:}{\f3\fs24 
  The uData Path (figure 2.11) is controlled by the signal lines shown with each data path block. The signal lines originate in the microcontroller we call mControl (figure 2.13) which is explained later.  
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 
Groups of related control lines are called fields.  Fields arising from the user data path are listed in Table 2.4.  One possible encoding for the fields is shown in Table 2.5.  The names are taken from the uData Path figure 2.11.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 Figure 2.12  Programming Models
\par }\pard {\b\f3\fs24 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 \page Table 2.4  User Data Path Fields}{\f3\fs24 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Field     Function (figure 2.11)
\par \_\_\_\_\_     \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_---\_\_\_
\par           Read sources\_\_
\par r}{\f3\fs24\dn60 x}{\f3\fs24         4 encoded lines to select 1 of 16 r}{\f3\fs24\dn60 x}{\f3\fs24 
\par r}{\f3\fs24\dn60 y}{\f3\fs24         4 encoded lines to select 1 of 16 r}{\f3\fs24\dn60 y}{\f3\fs24  
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 selx      4 encoded lines to connect 1 of 8 register outputs to the
\par           x bus (nop, status, mem, r}{\f3\fs24\dn60 x}{\f3\fs24 , r}{\f3\fs24\dn60 y}{\f3\fs24 , rtemp, sp, pc, r0)
\par sely      4 encoded lines to connect 1 of 8 register outputs to the
\par           y bus (nop, status, mem, r}{\f3\fs24\dn60 x}{\f3\fs24 , r}{\f3\fs24\dn60 y}{\f3\fs24 , rtemp, sp, pc, r0)
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24           Source to destination\_\_
\par selz      2 lines to connect the alu/shifter output, x bus, y bus,
\par           to the z bus (nop, saz, sxz, syz)
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24           Write destination\_\_
\par ldz       4 encoded lines to load 1 of 9 registers from the z bus
\par           (nop, status, mar, mbr, r}{\f3\fs24\dn60 x}{\f3\fs24 , r}{\f3\fs24\dn60 y}{\f3\fs24 , rtemp, sp, pc, ir)
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24           Process data\_\_
\par sh        3 lines select shifter function
\par           (nop, rotl, sll, sra, srl)
\par aluop     8 lines select alu functions (Table 2.6)
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24           Program Control and Other\_\_
\par mcc       5 encoded lines to select cc equation for mcc_report
\par bop       3 encoded lines to select register operation.
\par           (nop, incpc, incsp, decsp, setc, clrc)
\par opc\tab \tab 2 encoded lines define mI opcodes
\par rw        2 encoded lines to select memory access operation.
\par           (nop, r, w) 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 Table 2.5  User Data Path Control Line Field Encoding}{\f3\fs24 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24              |\_\_\_\_\_\_\_\_|\_\_\_\_\_\_|\_\_\_\_\_|\_|\_\_\_|\_\_\_\_\_\_\_|\_\_\_\_|\_\_\_\_\_|\_\_\_\_\_|
\par Fields       | bop    |aluop |sh   | |rw | ldz   |selz|sely |selx |
\par              |\_\_\_\_\_\_\_\_|\_\_\_\_\_\_|\_\_\_\_\_|\_|\_\_\_|\_\_\_\_\_\_\_|\_\_\_\_|\_\_\_\_\_|\_\_\_\_\_|
\par 0000           nop     Table  nop     nop  nop    nop  nop   nop
\par 0001           incpc   2.6    rotl    r    ldst   saz  ssty  sstx
\par 0010           incsp          sll     w    ldmar  sxz  smemy smemx
\par 0011           decsp          sra          ldmbr  syz  sr0y  sr0x
\par 0100           setc           srl          ldrx        srxy  srxx
\par 0101           clrc                        ldry        sryy  sryx
\par 0110                                       ldsp        sspy  sspx
\par 0111                                       ldpc        spcy  spcx
\par 1000                                       ldrt        srty  srtx
\par 1001                                       ldir
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Notes:
\par 1. uI bits defining r}{\f3\fs24\dn60 x}{\f3\fs24 , r}{\f3\fs24\dn60 y}{\f3\fs24 , mcc are control line sources.
\par 2. Outputs from uDataPath are mcc_report, ir bits
\par }\pard {\f3\fs24 
\par 
\par }\pard \sl-240\slmult0 {\f3\fs24 \page }{\b\f3\fs24 2.5 Microinstructions}{\f3\fs24 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 
The name of the uI ADD rx *ry tells you what operator this uI executes.  If we use a generic name such as ALU we need to add an operand specifying the operator ADD such as in ALU add rx *ry.  Traditionally generic names are not used for uI.  This is why t
here are many uI in an instruction set.  However, we use generic names for the mI (microinstructions) limiting their
 number to four.  This decision means each mI is more complex because each mI must now have more operands in order to define it.  The use of names and operands for the mI creates a microassembly language.  This is analogous to the assembly languages creat
ed for the uI sets of various computers.  How do the uI and mI interact?
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Any user's program is a list of uI stored in the main memory.  The internal computer controls execution of the user's list of uI.  Control instructions cI fetch the first uI from memory and store }{\b\f3\fs24 it}{\f3\fs24 
 in the instruction register (ir).  [How the cI know where to find the first uI is discussed later.]  The }{\b\f3\fs24 it}{\f3\fs24 
 stored in the ir is the codeword representing the uI.  The uI instruction is in binary format because it was read from memory.  This is why codewords are known as machine language instructions.  The uI instruction codeword has three fields: opcode, r}{
\f3\fs24\dn60 y}{\f3\fs24 , r}{\f3\fs24\dn60 x}{\f3\fs24 .  The opcode field bits are connected as inputs to the internal computer(figure 2.13).  The register field bits are connected to the r}{\f3\fs24\dn60 x}{\f3\fs24 , r}{\f3\fs24\dn60 y}{\f3\fs24 
 register file inputs (figure 2.11).  In order to proceed we need more information about the internal computer's structure.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 In Chapter 1 we claimed that each uI is implemented by a microprogram which is a list of mI.  Executing an mI means executing its mI list.  The mI lists are storedin mROM as is explained in the nex
t section.  Each mI list in mROM has a start address.  Our generic name for the start address is mI_start.  mI_start is encoded into each uI's opcode field (section 2.2).  This is why the ir bit lines are inputs to mControl (figure 2.13).
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 
The cI are executing a program within the internal computer that is permanently stored in the mROM.  [How this is done is explained later.]  The first step in the internal program fetched the first uI and stored it in the ir.  Now that the mI_start addres
s is known for that uI the internal program branches to that mROM address and proceeds to execute the mI list implementing the uI stored in the ir.  How do mI implement uI?
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 
First, there is a one-to-one correspondence of machine language microinstructions and microassembly language mI.  This situation is analogous to the one-to-one correspondence of machine language instructions and assembly language uI.  This is why each mic
roinstruction is one binary mI_word.  We call them mI_words because they have nothing to do with the 32 bit words processed in the user data path.  How are the mI_words encoded?
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 \page 
Executing a uI requires manipulation of the user data path control lines.  [This is explained in great detail later.]  Manipulation means groups of lines are activated in some sequence.  Specifically each mI activates one group of lines.  The mI list act
ivates groups of lines in sequence.  In this way an mI list, a list of microinstructions, executes a uI.  This is why an mI list implements a uI.  This implies that each mI_word 
selects a group of control lines.  This leads us directly to the user data path fields listed in Table 2.4.  If the mI_words are assemblies of these fields the mI_words can select groups of user data path control lines.  The lines are listed in Table 2.5.
  Now we proceed to formulate the mI_words and the microassembly language for the four types of mI: mALU, mMOV, mBR, and mNOP.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 Operators:}{\f3\fs24   We build the microinstruction word for the operator mI from the fields of Table 2.4.  We name this microinstruction mALU.  A two bit field named opc (opcode) identifies the mI by type (e.g. mALU).

\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 fields:   opc aluop  sh  rw  ldz  selz  sely  selx   r}{\f3\fs24\dn60 y}{\f3\fs24       r}{\f3\fs24\dn60 x}{\f3\fs24 
\par # bits:   2   8      3   2   4    2     4     4      4       4
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 This is important.  The r}{\f3\fs24\dn60 x}{\f3\fs24 , r}{\f3\fs24\dn60 y}{\f3\fs24  fields are a problem because r}{\f3\fs24\dn60 x}{\f3\fs24  or r}{\f3\fs24\dn60 y}{\f3\fs24  can be any number from 0 to F hex.  The 256 r
}{\f3\fs24\dn60 x}{\f3\fs24 , r}{\f3\fs24\dn60 y}{\f3\fs24  combinations imply 256 different mALU words we would have to store in the mROM if mI_words used register numbers.  There is a better solution.  The better solution is delete the r}{\f3\fs24\dn60 
x}{\f3\fs24 , r}{\f3\fs24\dn60 y}{\f3\fs24  fields from the mALU mI word and somehow use the r}{\f3\fs24\dn60 x}{\f3\fs24 , r}{\f3\fs24\dn60 y}{\f3\fs24 
 fields that are in the uI word.  [This is explained in the next section.]  The resulting 32 bit mALU mI_word has the following format.  Pedagogically this 32 is an unfortunate coincidence.  This 32 is }{\b\f3\fs24 not }{\f3\fs24 
related to the 32 bit data path word.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 mALU fields:   opc aluop  sh  spare  rw  ldz  selz  sely  selx 
\par no. of bits:   2   8      3   3      2   4    2     4     4
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24  1                             1 0                             0
\par  F E D C B A 9 8 7 6 5 4 3 2 1 0 F E D C B A 9 8 7 6 5 4 3 2 1 0
\par |\_\_\_|\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_|\_\_\_\_\_|\_\_\_\_\_|\_\_\_|\_\_\_\_\_\_\_|\_\_\_|\_\_\_\_\_\_\_|\_\_\_\_\_\_\_|
\par |alu| aluop         |sh   |     |rw | ldz   selz|sely   |selx   |
\par |\_\_\_|\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_|\_\_\_\_\_|\_\_\_\_\_|\_\_\_|\_\_\_\_\_\_\_|\_\_\_|\_\_\_\_\_\_\_|\_\_\_\_\_\_\_|
\par }\pard {\f3\fs24 
\par 
\par }\pard \sl-240\slmult0 {\f3\fs24 The 3 spare bits are added in order to have a 32 bit mI_word total because chip words are usually multiples of 4.  We propose using the following mALU representation for microprogramming purposes (Table 2.7).
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24      mALU op sx sy dz rw
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 where mALU specifies the opc field,
\par \tab    op specifies the aluop, sh, and selz fields, 
\par \tab    sx specifies the selx field,
\par \tab    sy specifies the sely field,
\par \tab    dz specifies the ldz field, and
\par \tab    rw specifies the rw field.
\par \page Op is shorthand for aluop.  The mALU three address format allows the microprogrammer to specify the alu operator, sources x and y, destination z, and r or w or nop.  Taking names from Table 2.4 or Table 2.7 we create an example.
\par                              
\par      mALU +   r}{\f3\fs24\dn60 x}{\f3\fs24   mem mbr w
\par     (mALU op  sx  sy  dz  rw)
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 The m
I mALU moves data from sources sx and sy to the ALU inputs.  In turn the ALU performs the specified aluop.  The result is moved to destination dz.  In addition the ALU result word causes status bits to be set or cleared in the status register (section 2.3
).  
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 
The sequence of reading the two sources, performing the operation, setting up the status bits, and writing the result to the destination is performed in one computer cycle.  Performed in one computer cycle when the destination is always a register.  Readi
ng or writing memory registers may require additional computer cycles (see section 2.7).  
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 Moves:}{\f3\fs24   We take the fields (Table 2.4) used by uI move instructions and build the microinstruction word for the move mI.  We call this microinstruction mMOV.  We omit the r}{\f3\fs24\dn60 x}{\f3\fs24 , r}{
\f3\fs24\dn60 y}{\f3\fs24  fields from the mI_word for reasons given above.  mMOV does not modify status bits.  We retain the 32 bit mI_word size.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 mMOV fields:   opc not_used rw  ldz  selz  sely  selx 
\par no. of bits:   2   14       2   4    2     4     4
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24  1                             1 0                             0
\par  F E D C B A 9 8 7 6 5 4 3 2 1 0 F E D C B A 9 8 7 6 5 4 3 2 1 0
\par |\_\_\_|\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_|\_\_\_|\_\_\_\_\_\_\_|\_\_\_|\_\_\_\_\_\_\_|\_\_\_\_\_\_\_|
\par |mov| not_used                  |rw | ldz   selz|sely   |selx   |
\par |\_\_\_|\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_|\_\_\_|\_\_\_\_\_\_\_|\_\_\_|\_\_\_\_\_\_\_|\_\_\_\_\_\_\_|
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 We propose using the following mMOV representation for micro programming purposes where s means sx or sy.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24      mMOV s dz rw
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 where mMOV specifies the opc field,
\par \tab    s  specifies the selx or sely fields,
\par \tab    dz specifies the selz and ldz fields, and
\par \tab    rw specifies the rw field.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 mMOV copies the binary number n stored at source address s and writes n at destination address dz.  Writing n to dz overwrites whatever number was in dz but does not change
 n at the source.  Source address s and destination address dz are main memory addresses or computer register numbers (addresses).  In digital logic move operations do not move bits, they make copies.  The source information is not changed.  The mMOV inst
ruction reads the source and writes to the destination in one computer cycle.  One computer cycle is needed when the destination is a register.  Reading or writing memory registers requires additional computer cycles (see section 2.7).
\par \page }{\b\f3\fs24 Branches:}{\f3\fs24   Once more
 we take the fields (Table 2.4) used by uI branch instructions and try to build the microinstruction word for the branch mI.  We will explain in a moment why we say try.  We call this microinstruction mBR.  mBR does not modify status bits.  We retain the 
32 bit mI_word size.  
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 mBR fields:    opc  mcc  bop     other?
\par no. of bits:   2    5    3       22
\par  1                             1 0                             0
\par  F E D C B A 9 8 7 6 5 4 3 2 1 0 F E D C B A 9 8 7 6 5 4 3 2 1 0
\par |\_\_\_|\_\_\_\_\_\_\_\_\_|\_|\_\_\_\_\_\_\_\_\_|\_\_\_\_\_|\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_|
\par |br |         | |  mcc    | bop |          (other)              |
\par |\_\_\_|\_\_\_\_\_\_\_\_\_|\_|\_\_\_\_\_\_\_\_\_|\_\_\_\_\_|\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_|
\par                \'db\_\_(other)
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 What is other?  Since this is a branch mI part of "other" must be a relative or absolute branch address to another mI.  Clearly mBR does not only work in the user data path.  We need to leap ahead to understand "other".

\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 In section 2.6 the micro data path is developed (figure 2.13).  There two mBR fields moff and
 adr are used to calculate the address of the next mI to be executed in an mI list.  Returning to the mBR word we propose a 32 bit mI_word incorporating the adr and relative moff fields.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 mBR fields:    opc  not_used  mcc  bop  adr  moff
\par no. of bits:   2    5         5    3    1    16
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 We propose using the following mBR representation for micro programming purposes.  The moff and adr operands are explained in section 2.6.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24      mBR bop mcc moff adr
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 
The following reasoning leads to a simplified mBr without the adr operand.  The 2 by 1 mux selecting the mPC input (figure 2.13) defines two branch alternatives.  And, once these two alternatives are understood there is a third and simplifying alternative
.  
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 1. When adr = 1 the next address is mI_start.  That is to say when adr = 1 a branch to mI_start is taken independently of the mcc and moff operands.  The mBR mI operands are as follows.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24      mBR bop un  nop  1\tab \tab (adr = 1)
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 2. When adr = 0 to next address is mPC plus 1 or mPC plus moff.  Now the mBR operands are operative.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24      mBR bop mcc moff 0\tab \tab (adr = 0)
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 3. Note that mI_start is the only address used when adr = 1.  One simplification is to drop the adr operand and proceed as follows.
\par      mBR bop mcc moff\tab \tab (implies adr = 0, moff active)
\par      mBR bop un  mI_start\tab \tab (implies adr = 1, moff disabled)
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 \page }{\b\f3\fs24 2.6 Micro Data Path}{\f3\fs24 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 The user data path is activated to perform functions by various combinations of asserted control lines.  The micro data path (figure 2
.13) is the source of these control lines.  Specifically microinstruction fields are the source of these lines.  Some of the fields are encoded (Table 2.5).  These fields require decoding into individual lines. Combinational decoder circuits constitute th
e mDecoder where the prefix m indicates belonging to the micro data path (figure 1.2).
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Each mI executes in one computer cycle which includes several clock cycles.  The control lines must be stable over the computer cycle executing the current mI.  Therefor
e the mI_word which is the input to the mDecoder must be held in a register.  Since this register holds a micro instruction we call it the micro instruction register (mIR).  This is analogous to the instruction register (ir) holding a uI while it is being
 executed.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 
The mIR has inputs for receiving the next mI to be executed.  The source of the next mI is the permanent store of the mI lists representing the uI available to the user.  All the mI are stored in the computer in non volatile read only memory (ro
m) in order to be available when the power is turned on.  We call this memory the mROM.
\par  
\par The mROM has inputs for selecting the next mI to be executed.  The inputs are the mROM's address of the next mI.  The next address is also stored in a register in order to be stable over the computer cycle executing the mI.  Since this register selects th
e next mI in the }{\b\f3\fs24 mI program }{\f3\fs24 we call it the micro program counter (mPC).  In the }{\b\f3\fs24 user}{\f3\fs24  data path the pc points to the next uI but the mar addresses the memory.  This sep
aration of functions is necessary to allow for other memory address sources such as any r}{\f3\fs24\dn60 x}{\f3\fs24 
 or the stack pointer.  In the micro data path there is only one address source and so the mPC performs both functions of pointing (like the pc does), and addressing (like the mar does).
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 The mPC has inputs for receiving the next address.  The source of the next address is the next address calculator.  There are two basic sources for the next address.  
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 One source is the mI_word in the mIR.  This current mI word speci
fies which mI is next.  When a branch in the mI space is taken the address of the next mI may be the next in line mI at mPC+1 or some mI at mPC+moff.  Moff is the relative offset address.  When a conditional branch is being executed in the mI space the ch
oice of mPC+1 or mPC+moff is dictated by the mcc_report being false or true respectively.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 The second source is the most recently fetched uI.  The uI word, emphasis on uI, contains the address of the first mI in the mI list representing the uI.  This is the address we call mI_start.  
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 \page }{\b\f3\fs24 Figure 2.13  CISC mControl - the mData Path and mCTRL}{\f3\fs24 
\par }\pard {\f3\fs24 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par }\pard \sl-240\slmult0 {\f3\fs24 \page 
The mI_word is the selected source when adr = 0 (figure 2.13).  When adr = 0 mBR performs the operation bop and evaluates the mcc micro condition code simultaneously.  If mcc is false the next-in-line mI at the next address mPC+1 is executed.  If mcc is t
rue a jump to the mI at address mPC+moff occurs.  This is not a uI branch!  This is an mI branch.  Nevertheless, mBR is used to implement branch uI indirectly (section 2.12).
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 The mcc report cc code conditions are derived from the NCZV status bits which are also known as flags (Table 2.2).  Since only the mALU mI modify the status bits the mBR decision depends on the last mALU executed }{
\b\f3\fs24 before}{\f3\fs24  mBR executes.  
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 The bop field is not necessary to the branch process.  As will become clear branch mI are convenient places in a mI program to adjust the pc, the sp, and the alu carry.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 From the user and the micro data paths the list of fields relevant to mBR can be assembled.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 bop       3 encoded lines to select incpc, incsp, decsp, setc, clrc
\par mcc       5 encoded lines to select cc 
\par adr       1 line to select next address
\par moff      16 bit signed number\_\_the offset to the next }{\b\f3\fs24 mI}{\f3\fs24  address
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24  1                             1 0                             0
\par  F E D C B A 9 8 7 6 5 4 3 2 1 0 F E D C B A 9 8 7 6 5 4 3 2 1 0
\par |\_\_\_|\_\_\_\_\_\_\_\_\_|\_|\_\_\_\_\_\_\_\_\_|\_\_\_\_\_|\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_|
\par |br |         | |  mcc    | bop |     moff                      |
\par |\_\_\_|\_\_\_\_\_\_\_\_\_|\_|\_\_\_\_\_\_\_\_\_|\_\_\_\_\_|\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_|
\par                \'db\_\_adr
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 \page }{\b\f3\fs24 2.7 Micro Control}{\f3\fs24 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 
The computer wakes up when power is turned on because a program not accessible to the user is permanently stored in the memory (mROM) of the internal computer we call mControl.  This program is written in the mI microassembly language.  Emphasis:  this pr
ogram is NOT written in the uI assembly language.  What does this program do?  In a phrase this program implements the uI set.  This program reads a uI code word from main memory into the uData P
ath instruction register (ir), determines from the uI code where the corresponding mI list start address is in mROM, branches to the start address (mI_start) and starts executing the mI in the list representing the uI.  The last mI in the mI list is a bra
nch to the fetch\_the\_ next\_uI list of mI (these are mI disguised as cI).  The next uI is fetched and the cycle of events repeats to execute the next uI.  In due course the user's program is executed.  
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 The micro control computer mControl simply executes on
e mI after the other.  The mI sequence is determined by the sequence of uI that are fetched.  This internal computer may be awake however it needs a list of uI somewheres for mControl to execute and thereby take the main computer through the wake up proce
ss.  The somewheres is part of the uI main memory map occupied of necessity by rom.  Rom that permanently stores the wake up program written in uI language.  This is a firmware rom.  In some computers this is known as the rom bios or basic input/ouput sys
tem in rom.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 
When the power is turned on the main +5 volt lines powering the logic rise to +5 volts in say 300 milliseconds.  In the meantime the system reset line rises relatively slowly (in seconds) to +5 volts.  This is the case because an RC charging circuit, or e
quivalent, is used to delay reset rising from the L voltage region (reset asserted) to the H voltage region (reset not asserted) for several seconds.  While reset is asserted clocks and logic stabilize.  Specifically, the asserted reset asserts h
alt, clears the mPC to all zeros and presets the user's PC to the address of the first uI in the firmware rom.  The fetch uI mI list is placed at mROM address zero because the mPC is cleared to zero.  Now the stage is set for wakeup.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 When reset changes state from asserted to not asserted halt is changed to not\_
asserted and the mControl state machine starts executing mI one at a time.  mControl executes three fetch_uI mI to fetch the first uI.  Then mControl proceeds to execute the mI list for that uI.  And subsequently the entire wakeup program is executed. 

\par }\pard {\f3\fs24 
\par The state machine that makes all this happen is the mCtrl state machine in the mControl internal computer.  mCtrl supervises the sequential execution of mI in mControl.  We remind you that mCtrl is part of mControl (figure 1.2).  Here is what mCtrl does.

\par 
\par }\pard \sl-240\slmult0 {\f3\fs24 \page Two mCtrl control lines, ldmpc and ldmir, cycle the micro data path executing one mI per cycle (figure 2.13).  Another control line, mcc_report, from the user data path implements the mI branch decisi
ons.  The user data path instruction register (ir) bit lines are input lines providing values for mI_start and r}{\f3\fs24\dn60 x}{\f3\fs24 , r}{\f3\fs24\dn60 y}{\f3\fs24 
 to the micro data path.  Here is a description of the actual timing of a computer cycle executing one mI.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 A qualitative sequence of events in one mI cycle is as follows.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24      ldmpc loads address of next mI 
\par      mPC presents valid address to mRom
\par      valid data from mRom (the next mI) is presented to mIR
\par      ldmir loads the next mI from mRom into mIR
\par      mIR presents valid next mI_word to mDecode 
\par      mDecode presents valid control lines to user data path
\par      ldreg loads result on z bus into destination
\par      end
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 
This sequence of events is readily quantified and put into the form of a timing diagram (figure 2.14).  The driving events are the load commands.  The other events are consequences of the executed load commands.  In other words the other events are propag
ation times of signals from clock edge to register outputs or propagation times of signals proceeding through the combinational circuits mROM and mDecode.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 
mControl timing basics (figure 2.14) presumes the load commands are outputs of a synchronous state machine because the duration of any load command is essentially one clock period.  The load command waveform offset from the clock period is due to the cloc
k\_to\_ register\_output propagation time.  Three sequentially dependent load commands (ldmpc, ldmir, ldreg) dictate a minimum cycle time of three clock periods.  mControl timing basics (figure 2.14) uses an extra clock period, s}{\f3\fs24\dn60 2}{
\f3\fs24 , to allow for realistic propagation times for mDecode and uData Path paths. 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Here is a detailed review of events that take place in each clock period (figure 2.14).
\par }\pard {\f3\fs24 
\par 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 State s}{\b\f3\fs24\dn60 0}{\b\f3\fs24 :  }{\f3\fs24 Next mI address is the mPC input (figure 2.13).  During s}{\f3\fs24\dn60 0}{\f3\fs24 
 mCtrl outputs the ldmpc command.  Ldmpc loads the next mI address into the mPC on the clock edge at end of the s}{\f3\fs24\dn60 0}{\f3\fs24  clock period.  The new mPC outputs are a new mI address input to the mROM.
\par }\pard {\f3\fs24 
\par 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 State s}{\b\f3\fs24\dn60 1}{\b\f3\fs24 :  }{\f3\fs24 During s}{\f3\fs24\dn60 1}{\f3\fs24 
 time the mROM accesses the next mI.  In parallel mCtrl outputs the ldmir command.  Ldmir loads the next mI (from the mROM data outputs) into the mIR on the clock edge at end of the s}{\f3\fs24\dn60 1}{\f3\fs24  clock period.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 \page }{\b\f3\fs24 State s}{\b\f3\fs24\dn60 2}{\b\f3\fs24 :  }{\f3\fs24 During s}{\f3\fs24\dn60 2}{\f3\fs24 
 time the new mIR bits propagate through the mDecode circuits.  The mDecode outputs propagate into the uData Path circuits (figure 2.11) thereby preparing the uData Path to execute the mI.  For example, for the mI 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24      mALU op sx sy dz nop 
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 the selx and sely fields read source registers and their outputs are connected to the alu inputs via bus x and bus y.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 State s}{\b\f3\fs24\dn60 3}{\b\f3\fs24 :  }{\f3\fs24 During part of the s}{\f3\fs24\dn60 2}{\f3\fs24  and s}{\f3\fs24\dn60 3}{\f3\fs24 
 time periods signals propagate through the alu and shifter (for mALU mI) putting the result on the z bus.  Then in s}{\f3\fs24\dn60 3}{\f3\fs24 
 mCtrl outputs the ldreg command.  Ldreg loads the results on the z bus into the destination register on the clock edge at end of the s}{\f3\fs24\dn60 3}{\f3\fs24  clock period.  During s}{\f3\fs24\dn60 3}{\f3\fs24 
 time a memory access command may be issued by mCtrl.  Memory access commands initiate memory access cycles on the clock edge at end of the s}{\f3\fs24\dn60 3}{\f3\fs24  clock period (figure 2.15).  This ends one computer cycle.
\par }\pard {\f3\fs24 
\par 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 Figure 2.14  mControl Timing Basics}{\f3\fs24 
\par }\pard {\f3\fs24 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par }\pard \sl-240\slmult0 {\f3\fs24 \page Observe the mI is set up for execution during s}{\f3\fs24\dn60 0}{\f3\fs24  and s}{\f3\fs24\dn60 1}{\f3\fs24  time.  And, that there are three sequential phases to an mALU computer cycle which executes one mI in s}{
\f3\fs24\dn60 2}{\f3\fs24  and s}{\f3\fs24\dn60 3}{\f3\fs24  time:
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24      read sources sx, sy in parallel
\par      perform the ALU and, or shift operations (longest prop time)
\par      write the result to the destination dz
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Since each mI requires one computer cycle the time to execute a uI depends upon the number of mI in the mI list.  In turn the number of mI depends upon the address mode and the uI operand.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 A memory read or write command issued during s}{\f3\fs24\dn60 3}{\f3\fs24  starts a memory access cycle in the next s}{\f3\fs24\dn60 0}{\f3\fs24 
 time.  One question is:  do we wait for the access cycle to end before we start the next computer cycle or do we run memory access cycles and computer cycles in parallel?  Let us try to implement a parallel procedure simply becau
se this makes the computer faster.  
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 Data from register sources is available during the latter part of s}{\f3\fs24\dn60 2}{\f3\fs24  and during s}{\f3\fs24\dn60 3}{\f3\fs24  time of a computer cycle.  Memory access cycles start in s}{\f3\fs24\dn60 0}{
\f3\fs24  time.  If a memory read access cycle is less than the three clock periods corresponding to states s}{\f3\fs24\dn60 0}{\f3\fs24 , s}{\f3\fs24\dn60 1}{\f3\fs24 , and s}{\f3\fs24\dn60 2}{\f3\fs24 
 the memory can run in parallel (figure 2.15).  If the access time is longer the memory can still run in parallel if we prolong the computer cycle with wait states (figure 2.15).  In any event this procedure is faster t
han running computer and memory cycles in serial order.  And, the access command/wait handshake makes our design independent of the memory access time.  
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 Figure 2.15  Parallel mI Execution and Memory Access}{\f3\fs24 
\par }\pard {\f3\fs24 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par }\pard \sl-240\slmult0 {\f3\fs24 \page To show how the process works let us leap ahead and write the mI list of cI that fetch the next uI so that we can make a realistic timing diagram (figure 2.16).
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24\ul label\tab mI                   \tab RTL                         }{\f3\fs24 
\par fetch_uI  mMov pc mar r            mar <\_\_ pc   (and access)
\par           mMov mem ir nop          ir  <\_\_ mem  (uI to ir)
\par           mBR incpc un mI_start    mPC <\_\_ mI_start, pc <- pc+4
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\b\f3\fs24 Figure 2.16  Execution of mI Sequence for Fetch_uI}{\f3\fs24 
\par }\pard {\f3\fs24 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par }\pard \sl-240\slmult0 {\f3\fs24 \page We document the mCtrl state machine with an ASM chart (figure 2.17). Starting from s}{\f3\fs24\dn60 0}{\f3\fs24  the machine steps through states s}{\f3\fs24\dn60 0}{\f3\fs24 , s}{\f3\fs24\dn60 1}{\f3\fs24 , s}{
\f3\fs24\dn60 2}{\f3\fs24 , s}{\f3\fs24\dn60 3}{\f3\fs24 .  The machine dwells in state s}{\f3\fs24\dn60 3}{\f3\fs24  until wait goes false at the end of a memory access cycle initiated in state s}{\f3\fs24\dn60 3}{\f3\fs24 
 of the prior computer cycle.  The mDecode decodes the mI opcode so that one of the ASM inputs alu or mov or br are true unless the mI is a nop.  Here is what happens while the state machine is in state s}{\f3\fs24\dn60 3}{\f3\fs24 .
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 alu true: 
\par      while in s}{\f3\fs24\dn60 3}{\f3\fs24  with wait, mov, and br false 
\par      ldreg writes result data to the destination at the end of s}{\f3\fs24\dn60 3}{\f3\fs24 
\par      and, if a r or w bit in the mI rw field is true a memory
\par      access is requested at the end of s}{\f3\fs24\dn60 3}{\f3\fs24 .
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 mov true:
\par      while in s}{\f3\fs24\dn60 3}{\f3\fs24  with wait, alu, and br false 
\par      ldreg writes the data to the destination at the end of s}{\f3\fs24\dn60 3}{\f3\fs24 ,
\par      and, if a r or w bit in the mI rw field is true a memory
\par      access is requested at the end of s}{\f3\fs24\dn60 3}{\f3\fs24 .
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 br true:
\par      while in s3 with wait, alu, and mov false 
\par      bop is executed (it may be a nop)
\par      and, the next mI address is calculated by the mData Path.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 If the external halt line is false the state machine steps from s}{\f3\fs24\dn60 3}{\f3\fs24  to s}{\f3\fs24\dn60 0}{\f3\fs24  to start the next computer cycle.  If the halt line is true the state machine steps to s}{
\f3\fs24\dn60 4}{\f3\fs24  and dwells there until halt goes false.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 State s}{\f3\fs24\dn60 4}{\f3\fs24  does not appear in the timing diagrams because halt is assumed to be false in those diagrams.
\par }\pard {\f3\fs24 
\par }\pard \sl-240\slmult0 {\f3\fs24 \page }{\b\f3\fs24 Figure 2.17  Elementary CISC ASM Chart for mCTRL}{\f3\fs24 
\par }\pard {\f3\fs24 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par }}