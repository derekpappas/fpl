a vector is a collection of a set of signal values in an ordered list
The vectors are stored in a file. Each line of the file contains one
vector. The vector file is generated by a C++ simulator or driver
code. The cslc produces a vector writer C++ class which the user
instantiates in the user's  C++ simulator or driver. The vector writer
class first writes out the vector file header and then writes out each
individual vector to the vector file when an event is received

+--------------------+                         +--------------------------+
|    C++ simulator   |                         |        testbench         |
|                    |                         |                          |
|                    |                         |                          |
|     vectoro writer --------------------------+                          |
|                    |                         |                          |
|                    |                         |                          |
|                    |                         |                          |
|                    |                         |                          |
+--------------------+                         +--------------------------+

csl_vector v = {list_of_signals};
An ordered list of signals is assigned to the vector.

csl_signal a; // defaults to one bit
csl_signal b(3); // defaults to one bit
csl_signal c(4); // defaults to one bit
csl_signal d(3); // defaults to one bit
csl_signal e(2); // defaults to one bit
csl_signal f(5); // defaults to one bit

csl_vector v = {a,b,c,d,e,f}

The cslc will check that the connecvity objects in the vector are
all from the same pipestage. If the connectivity objects are not from
the same pipestage cslc will issue a warning or error.


The output vector format depedends on the width of the signal
and the radix selected for the vector. A three bit signal in binary is
represented by 3 digits from the set {0,1} producing a binary vector 
with the values of each signal in the following format:

<a[0:0]>_<b[2:0]>_<c[3:0]>_<d[2:0]>_<e[1:0]>_<f[4:0]>

Binary vector generation in ASCII is a foreach loop through the list of
signals in the vector.

String v;
foreach signal in signal_list {
   String b = convertToBinary(signal.getValue());
   v.+= b;
   v.+= "_";
}

A signal in hexidecimal is represented by 1 digit from the set {[0-9]A-F}. 
If the signal modulus 4 is not equal to zero then the bits have to be
packed together and the values have to be shifted and ored to produce the
vector output value.
             upper lower
             bit   bit 
width name   pos   pos
1     a[0:0] 17   16  left most signal
3     b[2:0] 16   14
4     c[3:0] 13   10
3     d[2:0]  9    7
2     e[1:0]  6    5
5     f[4:0]  4    0   right most signal

int v = 0;
v |= (a << a_shift) 
v |= (b << b_shift) 
v |= (c << c_shift) 
v |= (d << d_shift) 
v |= (e << e_shift) 
v |= (f << f_shift) 

// now v contains the signal value for a hexidecimal representation of
the vector 

To create the hexidecimal representation of the group of signals take
4 bits at a time and convert to hex.

foreach 4 bits in vectorInt {
   String h = convertToHex(4bits);
   v.+= h;
  // to make it easy to read put in an underscore every 4 or 8 hex digits
}

Example vector:

csl_vector v = {x,y,z,q};

x   y   z    q
01 01 111 0111 // binary signal values

01_01_111_0111 // binary vector output

01011110111    / concat the value bits together
010 1111 0111  // group in 4-bit chunks
  2    F    7  // coinvert 4 bit chunks to hex numbers
2F7            // create hexidecimal vector output 

----------------------------------------------------------------------------

set_id(43);
set_id() is used to set the vector id number for a specfic vector format
The vector id which is a numeric value appears in the first line of the file
the vector id is checked by an initial block in the testbench. cslc
will check if the id number has already been defined and if it has an duplicate id
number error will be generated.

set_name(bus_unit);
The vector has a vector name which is used to create the file name and
the vector write and reader names. set_name(bus_unit) will generate 
files with the anme: bus_unit.vec.


add_comment(string);
Adds a comment to the top of the vector file. The comment is ignored 
by the vector reader in the testbench.

set_max_number_of_vectors(numeric_expression);
The maximum number of vectors that will be produced by the vector
writer. This is used by the C++ vector writer to stop generating 
vectors after the maximum vector count is reached. The testbernch 
vector reader tracks the number of vectors that are read from the
vec tor input stream and when the vector count equals the max number 
of vectors on ths stimulus side not further vec tors are generated and
then done reading stimulus vectors flag is set and the testbench
prints a message taht says that the max number of stimulus vectos has
been read. If the vector is an expected vector then when the maximum
number of expected vectors is read the simulation stops.
                  
add_reset(signal_object_name);
Associate a reset signal with the vector. This command is used to control
when to start writing vectors. Start generating vectors after event
occurs. This command tells the vector generator to start writing
vectors after reset. The typical signal to usee for event is reset
which is the default start vector control signal. Many designs
generate garbage prior to reset and generating vectors prior to reset
is useless for comparison purposes.

start_vector_generation(event);
Overrides the control of start vector generation by reset. Instead
start generating vectors after event occurs. This command tells the vector
generator to start writing vectors. This command is used to control
when to start writing vectors. A typical signal to use for event is
reset which is the default start vector control signal. Many designs
generate garbage prior to reset and generating vectors prior to reset 
is useless for comparison purposes..

add_clock(signal_object_name);
The clock signal is associated with the vector and is used to generate 
vectors every cycle if the vector type is cycle accurate.
                  
set_max_mismatches(numeric_expression)
The comparator in the testbench counbts the number of mistmatches 
between the expected vector and the DUT generated vector. When the 
error count eqaual the max mismatch count then the simulation stops.

set_radix(binary|hexidecimal);
This option sets the radix for the vector format. 
The vector writer wiil write out the vector in radix specfied
If the vector radix is binary then the testbecnh will use the $readmemb function.
If the vector radix is hexidecimal then the testbecnh will use the $readmemh function.

set_module_name(bus);
sets the module name of the module that this vector is connected to.
This name is used to create prefix part of the vector filename.

set_instance_name(bus0);
sets the instance name for the module that this vector is connected to.
This name is used to create suffix part of the vector filename 

vector file naming convention
<module_name>_<instance_name>.vec;

set_model(cpp|tb);
cpp- the model that the vector is used by is a C++ simulator 
tb - the model that the vector is used by is a Verilog simulator

A cpp source will generate C++ code writer which the programmer
instantiates in a C++ simulator or BFM or driver and will create a 
Verilog module to read the vector file or socket in a testbench.

A tb source will generate Verilog vectormodule with a writer which 
is automatically instantiated in a Verilog module to generate the 
DUT output vector file.

add_event(clk|signal_expression);
clk - the vector is captured or compared on the rising edge of clock
signal_expression-the vector is captured or compared when the
expression is true

set_transaction_type(transaction|cycle_accurate);
Sets the transaction type for the vector if it is an expect vector
C++ default vector reader function name is the vector name plus "VectorReader"
C++ default vector writer function name is the vector name plus "VectorWriter"
Example:
If the name of the vector is "bus" 
C++ default vector reader function name is "busVectorReader"
C++ default vector writer function name is "busVectorWriter"

set_cpp_vector_reader_function_name("bus_reader");
set_cpp_vector_writer_function_name("bus_writer");
Overrides the default C++ function name

set_compare_trigger(event_object | clock_signal);
The comparison unit that compares vectors of this type uses either a
clock signal or an event object to perform the comparisons. If the
vector type is transaction accurate then an event based on
combinational signals is specified. If the vector type is cycle
accuarate then a clock signal triggers the comparison.

Instantiate vectors inside of units. The vector specification can use the unit
scoping to find signals.

============================================================
CSL Vector example

csl_vector bus_vec {
   csl_list l = bus.get_data_outputs();
   // l.remove("clk"); // remove the signal called list from the list
   // l contains the output ports from the unit bus
   set_model(cpp); // extract vector from C++ simulator
   set_name(bus_unit);
   add_comment("this is a vector");
}

Once a vector type has been created the type is used to create
instances of the vector.

{
   bus_vec bus_v0;
   bus_v0.set_id(43);
   bus_v0.set_instance_name(bus_tb);
}

Now create a vec tor to capture the vectore generated by the DUT in
the testbench.

csl_testbench {
   bus_vec bus_tb;
   bus_v0.set_id(43);
   bus_v0.set_instance(0);
   bus_tb.set_model(tb); // extract vector from Verilog testbench
}

============================================================
Vector file example

each vector file only contains one vector format

example vector file 
filename: bus_unit.vec.
// filename: bus_unit.vec.
22 // vector id number is 22
123_345_123123123_3
111_010_
123_345_123123123_3
123_345_123123123_3
123_345_123123123_3
123_345_123123123_3
123_345_123123123_3
123_345_123123123_3
123_345_123123123_3
123_345_123123123_3
123_345_123123123_3
123_345_123123123_3
123_345_123123123_3
123_345_123123123_3
123_345_123123123_3
123_345_123123123_3
123_345_123123123_3
123_345_123123123_3
123_345_123123123_3
123_345_123123123_3
123_345_123123123_3
123_345_123123123_3
123_345_123123123_3
123_345_123123123_3

============================================================
== CSL TESTBENCH ==
============================================================
csl_testbench name;

To add a module instance to the testbench instantitate a module
instance (unit instance) in the testbench. Testbench is derived from
csl_unit. Testbench is a built in type in the CSL language.

To add a vector to the testbench define a vector and instantiate the
vector in the testbench. Then use the CSL connect method to connect
the vector to the input or output interface of the DUT or other object.

set_testbench_verilog_filename(name);
The default name of the Verilog module and the filename for the testbench is
the name of the csl_testbench instance. set_testbench_verilog_filename(name) 
will override the default testbench name with name.

Use csl_include to add an include file containing Verilog code to the
Verilog testbench. 

add_logic(simulation_timeout_counter, numeric_expresion);
The testbench will stop the simulation if it reaches time
numeric_expression. This will add a counter which if it is still
running at numeric_expression will stop the simulation and print an
error message stating that the simulation did not finish by time 
numeric_expression.

add_logic(generate_waves, filename, type);
type = (fsdb | vsd)
fsdb-generate fsdb file format
vsd -generate vsd file format

add_logic(stall_injection);
Add stall injection logic to the testbench

=====================
= Signal generator: =
=====================

csl_signal_generator sign_patt_gen_name;
A csl_signal_generator is used in the testbench to generate a signal
pattern. The signal pattern drives a signal which is connected to
either a testbench DUT or another signal or module in the testbench.

set_generator_type(oscillator|clock|pwl);
oscillator - signal repeats and the signal type is wire.
clock      - sets the CSL signal type to clock and uses an oscillator
pwl        - a piecewise linear waveform

set_pattern({time[ps|ns|us|ms|s], value}+);
The param is composed by one or more pairs. The time base is optional 
and if not specified it uses the general timebase or the default one.
[Stefan] add the stuff here

set_signal_name(signal_object_name);
Sets the name of the signal that is driven by the pattern generator.

set_start_signal(signal_object_name);
This tells the pattern generator to start generating the signal. The
start signal activates the pattern generator.

set_default_value(number);
The default value is the value driven by the pattern generator when it
is inactive. for example, a reset signal may be low true so the
default value should be high (1).

set_duration(time_range|continuous);
time_range - the time range is the period that the pattern generator is
             active and is specified with a start time and an end time
continuous - the pattern generator is active during the entire
             simulation. Periodic signal default to a duration of continuous.

set_period(numeric_expression);
Used to set the period for an oscillator or a clock

set_timebase(ps|ns|us|ms|s);
If not set the default timebase is "us" (microseconds)

================================================================================
Example Testbench clock generator

csl_signal_generator clk {
  clk() {
    set_generator_type(clock);
    set_timebase(us);
    set_period(20);
    set_pattern({0,0}, {10,1}, {15,0}); //if more than 2 inflection
  points are detected an error should be thrown (the signal generator
  is not a clock anymore)
    set_signal_name("clock");
  }
}

csl_unit u1 {
  csl_signal clk;
  csl_include(verilog, "microengine_design.v");
}

csl_testbench tb {
  u1 u1_1; 
  clk clock_1;
  u1_1.clk.connect(clock);
}

================================================================================

==================
= CSL state data =
==================

csl_state_data state_data_object_name;

set_id(43);
set id is used to set the state data id number for a specfic state data format
The state data id which is a numeric value appears in the first line of the file
the state data id is checked by an iintial block in the testbench. cslc
will check if the id number has already and if it has an duplicate id
number error will be generated.

set_name(bus_unit);
The "state data" has a state data name which is used to create the file name and
the vector write and reader names. set_name(bus_unit) will generate 
files with the anme: bus_unit.vec.

add_comment(string);
Adds a comment to the top of the state data file. The comment is ignored 
by the state data reader in the testbench.

set_max_number_of_states(numeric_expression);
The maximum number of vectos taht will be produced by the state data
writer. This is used by the C++ state data writer to stop generating 
state datas after the maximum state data count is reached. The testbernch 
state data reader tracks the number of state datas that are read from the
vec tor input stream and when the state data count equals the max number 
of state datas on ths stimulus side not further vec tors are generated and
then done reading stimulus state datas flag is set and the testbench
prints a message taht says that the max number of stimulus vectos has
been read. If the state data is an expected state data then whent he maximum
number of expected state datas is read then the simulation stops.
                                    
add_reset(signal_object_name);
Associate a reset signal with the state data. This command is used to control
when to start writing state datas. Start generating state datas after event
occurs. This command tells the state data generator to start writing
state datas after reset. The typical signal to usee for event is reset
which is the default start state data control signal. Many designs
generate garbage prior to reset and generating state datas prior to reset
is useless for comparison purposes.

start_state data_generation(event);
Overrides the control of start state data generation by reset. Instead
start generating state datas after event occurs. This command tells the state data
generator to start writing state datas. This command is used to control
when to start writing state datas. A typical signal to use for event is
reset which is the default start state data control signal.
Many designs generate garbage prior to reset and generating
state datas prior to reset is useless for comparison purposes.

add_clock(signal_object_name);
The clock signal is associated with the state data and is used to generate 
state datas every cycle if the state data type is cycle accurate.

set_max_mismatches(numeric_expression)
The comparator in the testbench counbts the number of mistmatches 
between the expected state data and the DUT generated state data. When the 
error count eqaual the max mismatch count then the simulation stops.

set_radix(binary|hexidecimal);
This option sets the radix for the state data format. 
The state data writer wiil write out the state data in radix specfied
If the state data radix is binary then the testbecnh will use the $readmemb function.
If the state data radix is hexidecimal then the testbecnh will use the $readmemh function.

set_module_name(bus);
sets the module name to the module that this state data is connected to.
This name is used to create prefix part of the state data filename. 

set_instance_name(bus0);
sets the instance name to the module that this state data is connected to
This name is used to create suffix part of the state data filename 

Note: This is the state data file naming convention:
<module_name>_<instance_name>.vec;

set_model(cpp|tb);
cpp - the model that the state data is used by is a C++ simulator 
tb  - the model that the state data is used by is a Verilog simulator

A cpp source will generate C++ code writer which the programmer
instantiates in a C++ simulator or BFM or driver and will create a 
Verilog module to read the state data file or socket in a testbench.

A tb source will generate Verilog state datamodule with a writer which 
is automatically instantiated in a Verilog module to generate the 
DUT output state data file.

add_event(clk|signal_expression);
clk-the state data is captured or compared on the rising edge of clock
signal_expression-the state data is captured or compared when the
expression is true

set_transaction_type(transaction|cycle_accurate);
Sets the transaction type for the state data if it is an expect state data
C++ default state data reader function name is the state data name plus "State DataReader"
C++ default state data writer function name is the state data name plus "State DataWriter"
Example:
If the name of the state data is "bus" 
C++ default state data reader function name is "busState DataReader"
C++ default state data writer function name is "busState DataWriter"

set_cpp_state data_reader_function_name("bus_reader"); -> needs
further explanations (I don't understand it)
set_cpp_state data_writer_function_name("bus_writer"); -> needs
further explanations (I don't understand it)
Overrides the default C++ function name

set_compare_trigger(event_object | clock_signal);
The comparison unit that compares state datas of this type uses either a
clock signal or an event object to perform the comparisons. If the
state data type is transaction accurate then an event based on
combinational signals is specified. If the state data type is cycle
accurate then a clock signal triggers the comparison.

Instantiate state datas inside of units. The state data specification can use the unit
scoping to find signals.

set_dut_mem(dut_name[,mem_cell_list][,radix]);
The name of the DUT memory that the state data will be extracted from.
?? What if there is more than one DUT ??

set_dut_mem_init(binary_value | hex_value);
The value to initialize the memory with. If this method is not used
then the memory is no initialized
?? What if there is more than one DUT ??

set_dut_mem_init_file(filename);
The filename to initialize the memory with. If this method is not used
then the memory is no initialized.

================================================================================
