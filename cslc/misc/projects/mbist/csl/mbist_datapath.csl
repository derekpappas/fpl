
/*  MBIST processor data path  */


// instruction bitrange
csl_bitrange br_i(0,15);

// data bitrange  
csl_bitrange br_d(0,15);

// half data bitrange
csl_bitrange br_hd(0,7);

// operation selection bitrange

csl_bitrange br_sop(0,2);

// register address bitrange
csl_bitrange br_ra(0,3);

// instruction address bitrange
csl_bitrange br_addr(0,15);

// rom address bitrange
csl_bitrange br_rom(0,7);


// Datapath units

// program counter
/*
csl_register r_pc { // for the moment not available program counter register or bidirectional counter
  r_pc(){
    set_type(counter);
    add_logic(count_direction,up);
    set_width(16);
  }
};
*/
csl_unit r_pc{
  csl_port p_clock(input);
  csl_port p_reset(input);
  csl_port p_enable(input);
  csl_port p_br_addr(input,br_i);
  csl_port p_sel(input);
  csl_port p_addr_out(output,br_i);
  csl_include(file_verilog,"pc_logic.v");
  r_pc(){
  }
};
// sram address counter
/*csl_register r_ac {
  r_ac(){
    set_type(counter);
    add_logic(count_direction,up);
    set_width(16);
  }
  };*/

csl_unit r_caddr{
  csl_port p_clock(input);
  csl_port p_reset(input);
  csl_port p_enable(input);
  csl_port p_direction(input);
  csl_port p_br_addr(input,br_i);
  csl_port p_sel(input);
  csl_port p_addr_out(output,br_i);
  csl_include(file_verilog,"caddr_logic.v");
  r_caddr(){
  }
};
// instruction memory

csl_memory m_im {
  //csl_unit m_im{ // declared as a unit as not yet clear which are csl_memory ports
  //csl_port rd_address(input,br_addr);
  //csl_port rd_data(output,br_d);
  //csl_port rd_en(input);
  //csl_include(file_verilog,"m_im_logic.v");
  m_im(){
        set_width(16);
        set_depth(65536);
  }
};

// register file
//csl_register_file rf{ 
csl_unit rf{ // declared as unit as register file not yet with two read ports
  csl_port clock(input); 
  csl_port reset(input);
  csl_port data_in(input,br_d); 
  csl_port data_out1(output,br_d);
  csl_port data_out2(output,br_d);
  csl_port wr_addr(input,br_ra);
  csl_port rd_addr1(input,br_ra);
  csl_port rd_addr2(input,br_ra);
  csl_port wr_en(input);
  csl_port rd_en1(input);
  csl_port rd_en2(input);
  csl_include(file_verilog,"rf_logic.v");
  rf() {
    //    set_width(16);
    // set_depth(16);
  }
};

//rom memory
csl_memory m_rom {
//csl_unit m_rom { // declared as unit as not yet clear which are csl_memory ports
//  csl_port rd_address(input,br_rom);
//  csl_port rd_data(output,br_d);
//  csl_port rd_en(input);
//  csl_include(file_verilog,"m_rom_logic.v");
  m_rom(){
        set_width(16);
        set_depth(256);
  }
};

// sign extension unit
csl_unit u_es{
  csl_port p_c(input,br_hd);
  csl_port p_ec(output,br_d);
  csl_include(file_verilog,"u_es_logic.v");
  u_es(){
  }
};

// instruction register
csl_unit u_ir{
  csl_port p_clock(input);
  csl_port p_i(input,br_i);
  csl_port p_opcode(output,0,3);
  csl_port p_rdst(output,br_ra);
  csl_port p_op1(output,br_ra), p_op2(output,br_ra);
  csl_port p_c(output);
  csl_port p_braddr(output,11);
  csl_port p_sha(output,4);
  csl_port p_const8(output,br_hd);
  csl_port p_romaddr(output,br_hd);
  csl_port p_d(output);
  csl_include(file_verilog,"ir_logic.v");
  u_ir(){
    /*    p_opcode=p_i[15:12];
    p_rdst=p_i[11:8];
    p_op1=p_i[7:4];
    p_op2=p_i[3:0];
    p_c=p_i[11];
    p_braddr=p_i[10:0];
    p_sha=p_i[7:4];
    p_const8=p_i[7:0];
    p_romaddr=p_i[7:0];
    p_d=p_i[11];*/
  }
};

// ALU unit
csl_unit u_alu{
  csl_port p_op1(input,br_d);
  csl_port p_op2(input,br_d);
  csl_port p_opsel(input,br_sop);
  csl_port p_cin(input);
  csl_port p_res(output,br_d);
  csl_port p_cout(output);
  csl_include(file_verilog,"u_alu_logic.v");
  u_alu(){
  }
};

// define high address register
csl_register r_ha{
  r_ha(){
    set_type(register);
    set_width(16);
    add_logic(reset);
  }
};

// status register   cz - sram addr compare 0, s - sign, c - carry, z - zero
// 5  4  3  2  1  0  9  8  7  6  5  4  3  2  1  0
// x  x  x  x  x  x  x  x  x  x  x  cz x  s  c  z
csl_register r_status{
  r_status(){
    set_type(register);
    set_width(16);
    add_logic(reset);
  }
};
   
//define control unit 
csl_unit u_control {
  csl_port p_opcode(input,0,3);
  csl_port p_status(input,br_d); // is should be only the used bits
  csl_port p_direction(input);
  csl_port p_cond(input);

  csl_port p_br_sel(output);
  csl_port p_sreg_sel(output);
  csl_port p_rf_wr_en(output);
  csl_port p_rf_rd1_en(output);
  csl_port p_rf_rd2_en(output);
  csl_port p_rom_en(output);
  csl_port p_sram_wr(output);
  csl_port p_sram_en(output);
  csl_port p_mem_sel(output,3);
  csl_port p_caddr_dir(output);
  csl_port p_caddr_en(output);
  csl_port p_caddr_ld(output);
  csl_port p_haddr_en(output);
  csl_port p_haddr_ld(output);
  csl_port p_sh_sel(output);
  csl_port p_rf_alu_sel(output);

  csl_signal s_opcode_dec(16); // output signal of the opcode decoder
  // this should be generated from opcode enum in ISA
  //begin
  csl_signal s_add, s_sub, s_or, s_and, s_cmp, s_sh, s_not, s_swp, s_mov, s_movr, s_movc, s_movrs, s_mramrs, s_br, s_incr, s_decr; // opcode decoder named outputs
  //end
  csl_signal s_direction_dec(2); // output signal of the direction decoder
  csl_signal sr2r, r2sr; // direction decoder named outputs

  csl_signal s_opcode_alumem_dec(2); // output signal of the alu/memory operation decoder
  csl_signal s_opcode_alu, s_opcode_mem; // alu/memory operation decoder named outputs

 
  u_control(){
  

    // alu/memory operation decoder
    // s_opcode_alu_mem_dec= 1<< p_opcode[3];

    // opcode decoder
    // s_opcode_dec = 1 <<p_opcode;
  
    // transfer direction decoder
    // s_direction_dec=1<<p_direction;  

   r2sr=s_direction_dec[0];
   sr2r=s_direction_dec[1];

  
   //this should be generated from enum in ISA 
   //begin
   s_add= s_opcode[0]; 
   s_sub=s_opcode[1]; 
   s_or=s_opcode[2];
   s_and=s_opcode[3];
   s_cmp=s_opcode[4];
   s_sh=s_opcode[5]; 
   s_not=s_opcode[6]; 
   s_swp=s_opcode[7]; 
   s_mov=s_opcode[8];
   s_movr=s_opcode[9]; 
   s_movc=s_opcode[10]; 
   s_movrs=s_opcode[11]; 
   s_mramrs=s_opcode[12]; 
   s_br=s_opcode[13]; 
   s_incr=s_opcode[14]; 
   s_decr=s_opcode[15];
   //end
   // or shorter when concatenation will work
   //{s_add, s_sub, s_or, s_and, s_cmp, s_sh, s_not, s_swp, s_mov, s_movr, s_movc, s_movrs, s_mramrs, s_br, s_incr, s_decr}=s_opcode;
   

   //s_z=p_status[0];  // zero flag

    //control signal equations
   p_br_sel    =s_br & (p_cond==!s_z);
   p_sreg_sel  = s_opcode_mem & s_movrs;
   p_rf_wr_en  = s_opcode_alu | s_mov | s_movr |s_movc | s_sr2r & (s_movrs | s_mramrs);
   p_rf_rd1_en =s_add | s_sub | s_or | s_and | s_cmp;
   p_rf_rd2_en =s_opcode_alu | s_mov | rs2r & (s_movrs | mramrs);
   p_rom_en    = s_movr;
   p_sram_wr   = s_mramrs & r2sr;
   p_sram_en   = s_mramrs & sr2r;
   // !!! part select not recognized in lhs of assingment
   //s_mem_sel[2] =s_movrs & sr2r;
   //s_mem_sel[1]= s_movr | (s_mramrs & sr2r);
   //s_mem_sel[0]= s_movr | s_movc;
   p_caddr_dir= s_decr ;
   p_caddr_en = s_incr & s_decr ;
   p_caddr_ld = s_movrs & r2sr ;  
   p_haddr_en = s_movrs & r2sr ;
   p_haddr_ld = s_movrs & r2sr ;
   p_sh_sel = s_sh   ;
   p_rf_alu_sel= s_mov;
   
  }     
};      

// define mbist controler unit  

csl_unit u_mbist {
  // ports
  csl_port p_clock(input);
  csl_port p_reset(input);
  csl_port p_enable(input);
  csl_port p_sram_addr(output,br_addr); // memory under test address port
  csl_port p_sram_din(output,br_d);     // memory under test data input port
  csl_port p_sram_dout(input,br_d);     // memory under test data output port
  csl_port p_sram_rd_en(output);        // memory under test read enable port
  csl_port p_sram_wr_en(output);        // memory under test write enable port

  //signals
  csl_signal s_pc_im(br_addr);   // pc to im signal
  csl_signal s_opcode(0,3);      // opcode signal
  csl_signal s_reg_dest(br_ra);  // register destination address signal      
  csl_signal s_op1(br_ra), s_op2(br_ra); // operand 1 and 2 address signals
  csl_signal s_cond; // branch condition signal
  csl_signal s_branch_addr(0,10);   // 10 bit branch address
  csl_signal s_branch_addr_e(br_i); // branch address extended to 16 bits
  csl_signal s_br_sel; // branch control signal
  csl_signal s_shift_ammount(0,3); // shift ammount signal
  csl_signal s_const_val(br_hd); // constant value signal
  csl_signal s_rom_addr(br_rom); // rom address signal
  csl_signal s_direction; // transfer direction signal 
  csl_signal s_mux_shift(br_d); // output of shift/operand mux
  csl_signal s_sh_sel; // control of shift/operand mux
  csl_signal s_mem_mux(br_d); // output of memory mux
  csl_signal s_mem_sel(0,2); // control of memory mux
  csl_signal s_rf_alu_mux(br_d); // output from rf/alu mux
  csl_signal s_rf_alu_sel; // control of rf/alu mux
  csl_signal s_status(br_d); // output from status register
  csl_signal s_status_in(br_d); // input to status register 
  csl_signal s_rf_mux(br_d); // rf to mux bus
  csl_signal s_es_mux(br_d); // es to mux bus
  csl_signal s_alu_mux(br_d); // alu to mux bus
  csl_signal s_rom_mux(br_d); // rom to mux bus
  csl_signal s_rf_haddr(br_d); // rf to highest addres register bus
  csl_signal s_rf_caddr(br_d); // rf to address counter bus
  csl_signal s_haddr_cmp(br_i); // highest address to comparator bus
  csl_signal s_caddr_cmp(br_i); // address counter to comparator bus
  csl_signal s_sram_addr(br_i); // address counter to sram address port
  csl_signal s_cz_f, s_f, s_c_f, s_z_f; // compare zero, sign, carry and zero flag signals
  csl_signal s_ir_im(br_i); // 
  csl_signal s_rf_alu(br_d);  // rf to alu bus
  csl_signal s_caddr_ld; // address counter load signal
  csl_signal s_caddr_en; // address counter enable signal
  csl_signal s_caddr_dir; // address counter direction counter signal
  csl_signal s_haddr_en; // highest address register enable signal 
  csl_signal s_haddr_ld; // higest address registger load signal
  csl_signal s_rf_rd1_en; // rf read port 1 enable signal
  csl_signal s_rf_rd2_en; // rf read port 2 enable signal
  csl_signal s_rf_wr_en; //rf write enable signal
  csl_signal s_rom_en; // rom enable signal
  csl_signal s_sreg_sel; // special register select
  csl_signal s_sreg_mux(br_d); // output of special register mux
 
  
  // instantiate modules in the controler

  //  instruction memory
  m_im im0(.rd0.en(p_enable), 
           .rd0.address(s_pc_im), 
           .rd0.data(s_ir_im));
    

  // program counter
  r_pc r_pc0(.p_clock(p_clock),
             .p_reset(p_reset),
             .p_enable(p_enable),
             .p_br_addr(s_branch_addr_e),
             .p_addr_out(s_pc_im), 
             .p_sel(s_br_sel));
  
  // instruction register
  u_ir ir0( .p_clock(p_clock), 
            .p_i(s_ir_im), 
            .p_opcode(s_opcode), 
            .p_rdst(s_reg_dest), 
            .p_op1(s_op1), 
            .p_op2(s_op2), 
            .p_c(s_cond), 
            .p_braddr(s_branch_addr), 
            .p_sha(s_shift_ammount), 
            .p_const8(s_const_val), 
            .p_romaddr(s_rom_addr),     
            .p_d(s_direction));
   

  // alu/shift/compare unit
  u_alu alu0(.p_op1(s_mux_shift),
             .p_op2(s_rf_alu), 
             .p_cin(s_status[1]), 
             .p_opsel(s_opcode[2:0]), 
             .p_res(s_alu_mux), 
             .p_cout(s_c_f));

  //register file
  rf rf0(.clock(p_clock),
         .reset(p_reset), 
         .data_in(s_mem_mux), 
         .data_out1(s_rf_mux),
         .data_out2(s_rf_alu),
         .wr_addr(s_reg_dest), 
         .rd_addr1(s_op1), 
         .rd_addr2(s_op2), 
         .wr_en(s_rf_wr_en),
         .rd_en1(s_rf_rd1_en), 
         .rd_en2(s_rf_rd2_en));

  // rom memory containing test paterns
  m_rom pattern_rom(.rd0.en(p_enable), 
                    .rd0.address(s_rom_addr), 
                    .rd0.data(s_rom_mux));
  
  // sign extension unit
  u_es es0(.p_c(s_const_val),
           .p_ec(s_es_mux));
  
  // sram address counter
  r_caddr caddr(.p_reset(p_reset), 
                .p_clock(p_clock),
                .p_enable(s_caddr_en),
                .p_direction(s_caddr_dir),
                .p_br_addr(s_rf_alu), 
                .p_addr_out(p_sram_addr), 
                .p_sel(s_caddr_ld));

  // highest address register
  r_ha haddr(.reset_(p_reset),
             .clock(p_clock),
             .enable(s_haddr_en), 
             .reg_in(s_rf_alu), 
             .reg_out(s_haddr_cmp));

  // status register 
  r_status status(.reset_(p_reset),
                  .clock(p_clock),
                  .enable(p_enable),
                  .reg_in(s_status_in),
                  .reg_out(s_status));
  
  // control unit
  u_control control(
                    .p_opcode(s_opcode),
                    .p_status(s_status), 
                    .p_direction(s_direction),
                    .p_cond(s_cond),
                    .p_br_sel(s_br_sel),
                    .p_sreg_sel(s_sreg_sel),
                    .p_rf_wr_en(s_rf_wr_en),
                    .p_rf_rd1_en(s_rf_rd1_en),
                    .p_rf_rd2_en(s_rf_rd2_en),
                    .p_rom_en(s_rom_en),
                    .p_sram_wr(p_sram_wr_en),
                    .p_sram_en(p_sram_rd_en),
                    .p_mem_sel(s_mem_sel),
                    .p_caddr_dir(s_caddr_dir),
                    .p_caddr_en(s_caddr_en),
                    .p_caddr_ld(s_caddr_ld),
                    .p_haddr_en(s_haddr_en),
                    .p_haddr_ld(s_haddr_ld),
                    .p_sh_sel(s_sh_sel),
                    .p_rf_alu_sel(s_rf_alu_sel));
   
  u_mbist(){
    /*
// branch address extension
s_branch_address_e={6'b0,s_branch_address};


    // shift multiplexor
    s_mux_shift= s_sh_sel ? s_rf_mux: {12'b0,s_shift_ammount};

   //sets the CZ bit in status register
    cz_f= | (s_haddr_cmp ^ p_sram_addr); 
    
    // sets the S (sign) flag in status register
    s_s_f= & s_alu_mux[15];
    
     
    // sets the Z (zero) flag in status register 
    s_z_f= | (s_alu_mux);
    
   // sets the status flags
    s_status_in = {11'b0, s_cz_f, 1'b0, s_s_f, s_c_f, s_z_f};
    
    // memory select multiplexor
    always @(mem_sel,s_rom_mux,s_es_mux,s_sram_mux,s_alu_mux)
       case (s_mem_sel)
             3'b000: s_mem_mux=s_rom_mux;
             3'b001: s_mem_mux=s_es_mux;
             3'b010: s_mem_mux=s_sram_mux;
             3'b011: s_mem_mux=rf_alu_mux;
             3'b100: s_mem_mux=s_sreg_mux;
      endcase

      //or
      s_mem_mux= s_mem_sel[3] ? s_sreg_mux:(s_mem_sel[0] ? (s_mem_sel[0] ? s_rom_mux: s_es_mux) : (s_mem_sel[0] ? s_ram_mux: s_rf_alu_mux));

   // register file alu multiplexor
   rf_alu_mux= rf_alu_sel ? rf0.data_out2 : alu0.res;

    */
  }
};
