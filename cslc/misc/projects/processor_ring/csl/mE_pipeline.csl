//Monica
//MicroEngine pipeline for Processor Ring

// enum items are used for set the widths for register/memories
csl_enum e{
    B_OPCODE=6,
    B_DATA=32,
    B_ADDR_IM=10,
    B_ADDR_RF=5,
    B_STATUS=4,
    B_INSTR=32,
    B_ADDR_DM=32,
    B_IMM=16
    };
// enum items are used for alu operations select
csl_enum op_sel{
    ADD_OP,
    SUB_OP,
    EQUAL_OP,
    ORI_OP,
    STW_OP
    };
//enum items are the branch conditions sent to cc_logic by control unit
csl_enum br{
  LT,
  GE,
  LE,
  GT,
  EQ,
  NE,
  P,
  N,
  NN,
  Z,
  NZ,
  C,
  NC,
  V,
  NV
    };

csl_bitrange br_pc(B_ADDR_IM);
csl_bitrange br_instr(B_INSTR);
csl_bitrange br_data(B_DATA);
csl_bitrange br_addr(B_ADDR_DM);
csl_bitrange br_rf(B_ADDR_RF);
csl_bitrange br_op(B_OPCODE);
csl_bitrange br_imm(B_IMM);
//csl_bitrange br_status(B_STATUS);
csl_bitrange br_length(4);

 csl_field n(1);
 csl_field c(1);
 csl_field z(1);
 csl_field v(1);
 
 csl_field nczv {
  n N;
  c C;
  z Z;
  v V;
 };
csl_field br_status{
  nczv nczv;
};
//Program counter
/*csl_unit mux{
  csl_port in0(input,br_pc),in1(input,br_pc);
  csl_port sel(input);
  csl_port mux_out(output,br_pc);
  mux(){
    mux_out =(sel) ? in1 : in0;
  }};

csl_unit adder{
  csl_port op1(input,br_pc), op2(input,br_pc);
  csl_port rez(output,br_pc);
  adder(){
    rez= op1 + op2;
    }};*/

csl_register ff_reg{
  ff_reg(){
    set_type(register);
    set_width(B_ADDR_IM);
  }};

csl_unit pc{
  //ports
  csl_port reset(input);
  csl_port br_cond(input);                 //branch condition
  csl_port br_id4(input);                  // unconditioned branch
  csl_port bro(input,br_pc);               //branch relativ offset
  csl_port id_br_addr(input,br_pc);        //branche address from ID pipestage
  csl_port pc_im_addr_pc1(output,br_pc);   //pc address for IM
  csl_port im_rd_en(output);               //read enable for IM
  csl_port enable(input),clk(input);
  //signals
  csl_signal next_pc_0(br_pc);
  csl_signal sel1_0;
  csl_signal constant_0(br_pc);
  csl_signal op1(br_pc),op2(br_pc);       //operend for adder 
  csl_signal rez(br_pc);                  //result of adder  
  csl_signal ff_in(br_pc),ff_out(br_pc);  //input and output  signal to/from ff_reg

   // csl_signal  add_mux_pc_0(br_pc);
  //instantiations
  /* mux mux1(.in0(constant_0),
           .in1(bro),
           .sel(sel1_0),
           .mux_out(adder.op1));
  mux mux2(.in0(add_mux_pc_0),
           .in1(id_br_addr),
           .sel(br_id4),
           .mux_out(ff.reg_in));
 adder adder(.op1(next_pc_0),
             .op2(mux1.mux_out),
             .rez(add_mux_pc_0));
  ff_reg ff(.reg_in(mux2.mux_out),
            .reg_out(next_pc_0),
            .reset_(reset),
            .enable(enable),
            .clock(clk)) ;*/
  ff_reg ff;

  pc(){
    sel1_0=br_cond & br_id4;               //and gate between br_cond and br_id4
    constant_0=1;                          // +1 if is not br instr
    op1=(sel1_0)? bro : constant_0;        //mux1
    op2=next_pc_0;
    rez=op1+op2;                           //adder
    ff_in=(br_id)? id_br_addr : rez;       //mux2
    next_pc_0=ff_out;
    pc_im_addr_pc1=ff_out;
    im_rd_en=1;

    ff.reg_in.connect(ff_in);
    ff.reg_out.connect(ff_out);
    ff.reset_.connect(reset);
    ff.enable.connect(enable);
    ff.clock.connect(clk);    
    
   clk.set_attr(clock);
}
};

   
//Instruction Memory
csl_memory IM{

  IM(){
    
    set_width(B_DATA);
    set_depth(1<<B_ADDR_IM);
  }};

//Instruction Register
csl_register IR{
  IR(){
      set_type(register);
      set_width(B_DATA);
  }};

//Instruction Decoder
csl_unit ID{
 
  csl_port p_clock(input);          //clock port 
  csl_port p_i(input,br_instr);     //instructions port
  csl_port p_opcode(output,br_op);  //opcode port
  csl_port p_bb(output);            //burst bit port
  csl_port p_src(output);           //  
  csl_port p_id(output);            //  three bits which select type of registers
  csl_port p_dst(output);           //
  csl_port p_br_len(output,br_length);   //burst length port
  csl_port p_dstreg(output,br_rf);      //address of destination register
  // csl_port p_idreg(output,br_rf); same field with srcreg2
  csl_port p_srcreg1(output,br_rf);    //address of first source register
  csl_port p_srcreg2(output,br_rf);   //address of second source register
  // csl_port p_null(output,br_rf); same field with srcreg2
  csl_port p_immed(output,br_imm);    //immediate value
 
  csl_include(file_verilog,"id_logic.v"); //processor_ring/verilog
  ID(){
   
}
};

//Register file
csl_register_file RF{

  RF(){
    set_width(B_DATA);        //32 bits data
    set_depth(1<<B_ADDR_RF);  // 5 bits addr
  }
};

// Arithmetic Logic Unit
csl_unit ALU{
  csl_port op1(input,br_data),op2(input,br_data);
  csl_port op_sel(input,3),ci(input);
  csl_port alu_rez(output,reg,br_data),co(output,reg);

  csl_include(file_verilog,"alu_logic.v");     //processor_ring/verilog
  ALU(){ 
    /*always @ (op_sel, op1, op2, ci)
  case (op_sel)
    `E_OP_SEL_ADD_OP: {co,alu_rez} = op1 + op2 + ci;      // add
    `E_OP_SEL_SUB_OP: alu_rez = op1 - op2;                // substract
    `E_OP_SEL_EQUAL_OP: alu_rez=(op1 == op2);             //equal
    `E_OP_SEL_ORI_OP: alu_rez=op1 | op2;                 //ori  
    `E_OP_SEL_STW_OP: alu_rez={op1,op2};                //stw
    
default: co=1'b0;
endcase */
 }
};

//Data Memory
csl_memory DM{
  DM(){
    set_width(B_DATA);
    set_depth(1<<B_ADDR_IM); // 10 bits addr
  }};

// status register :C=carry, N=negativ, Z= zero, V =overflow
//   3  2  1  0
//   C  N  Z  V
/*csl_register r_status{
  r_status(){
    set_type(register);
    set_width(B_STATUS);
 
  }
  };*/

// conditions control logic
csl_unit cc_logic{
  csl_port cc_in(input,br_status); //from status register
  csl_port id_br_cond5(input,4); //condition for branch, from control
  csl_port br_cond(output);    //enable conditional branch
  csl_port nzv(output,3);

  csl_signal c,n,z,v;

  cc_logic(){


    //cc_logic.v  

    /*  c=cc_in[0];
        n=cc_in[1];
        z=cc_in[2];
        v=cc_in[3];
        nzv=cc_in[2:0];
    
    always @* begin
  case (id_br_cond)
      `E_BR_LT : br_cond=((n &(~v)) | ((~n)&v));
      `E_BR_GE : br_cond=((n & v ) | ((~n)&(~v)));
      `E_BR_LE : br_cond=((n &(~v)) | ((~n)&v) | z);
      `E_BR_GT : br_cond=((n & v ) | ((~n)&(~v))&(~z));
      `E_BR_EQ : br_cond=z;
      `E_BR_NE : br_cond=(~z);
      `E_BR_P  : br_cond=(~n) & (~z);
      `E_BR_N  : br_cond=n;
      `E_BR_NN : br_cond=~n;
      `E_BR_Z  : br_cond=z;
      `E_BR_NZ : br_cond=~z;
      `E_BR_C  : br_cond=c;
      `E_BR_NC : br_cond=~c;
      `E_BR_V  : br_cond=v;
      `E_BR_NV : br_cond=~v;
      default  : br_cond=0; 
  endcase
  end*/

    
  }};

// Control unit
csl_unit control{
        

  csl_port  p_opcode(input,br_op);   //operation selection
  csl_port  p_immed(input,br_imm);  //immediate value from ID
  csl_port  p_op_sel(output,reg,3); //operation selection for ALU
  csl_port  p_dst_sel(output);        // rf mux selection
  csl_port  p_rf_wr_en(output);      //rf write enable
  csl_port  p_rf_rd0_en(output);      //rf read enable for first output
  csl_port  p_rf_rd1_en(output);      //rf read enable for second output
  csl_port  p_dm_wr_en(output);       //dm write enable
  csl_port  p_dm_rd_en(output);       //dm read enable
  csl_port  p_op1_sel(output);       //alu mux selection
  csl_port  p_id_br_cond(output,3);   //branch condition code for cc_logic
  csl_port  p_br_id4(output);        //enable unconditional branch
  csl_port  p_bb(output);            //burst bit
  csl_port  p_src(output);           //bit for select the type of register (from cl or from pr)
  csl_port  p_dst(output);           //bit for select the type of register (from cl or from pr)
  csl_port  p_id(output);           //bit for select the type of register (from cl or from pr)
  csl_port  p_br_length(output,br_length);  //burst length

 
  // signals used  for control outputs
  csl_signal s_read32req(reg);
  csl_signal s_write32(reg);
  csl_signal s_read32resp(reg);
  csl_signal s_write64(reg);
  csl_signal s_read64resp(reg);
  csl_signal s_read32DMAreq(reg);
  csl_signal s_write32DMA(reg);
  csl_signal s_read64DMAreq(reg);
  csl_signal s_write64DMA(reg);
  csl_signal s_add(reg);
  csl_signal s_sub(reg);
  csl_signal s_equal(reg);
  csl_signal s_movhi(reg);
  csl_signal s_movi(reg);
  csl_signal s_ori(reg);
  csl_signal s_ldw(reg);
  csl_signal s_stw(reg); 
  csl_signal s_brlt(reg);
  csl_signal s_brge(reg);
  csl_signal s_brle(reg);
  csl_signal s_brgt(reg);
  csl_signal s_breq(reg);
  csl_signal s_brne(reg);
  csl_signal s_brp(reg);
  csl_signal s_brn(reg);
  csl_signal s_brnn(reg);
  csl_signal s_brz(reg);
  csl_signal s_brnz(reg);
  csl_signal s_brc(reg);
  csl_signal s_brnc(reg);
  csl_signal s_brv(reg);
  csl_signal s_brnv(reg);
 

  csl_signal s_alu,s_dma,s_rd_wr;
  csl_signal s_dst_sel,s_immed(16);
  csl_signal s_branch;
  csl_signal s_not;
  csl_signal s_id_br_cond(br_status); //branch condition

  csl_include(file_verilog,"control_logic.v");

  control(){
      s_alu = s_add | s_sub | s_equal | s_ori ;
      s_dma = s_read32DMAreq | s_write32DMA | s_read64DMAreq | s_write64DMA;
      s_branch =s_brlt | s_brge |s_brle|s_brgt|s_breq|s_brne|s_brp|s_brn|s_brnn|s_brz|s_brnz|s_brc|s_brnc|s_brv|s_brnv;
      s_rd_wr = ~s_read32req & ~s_write32 & ~s_read32resp ;
      p_dst_sel = s_dma | s_ldw | s_rd_wr  | s_movhi | s_movi| ~s_alu;
      s_immed = p_immed;
      p_rf_wr_en = s_alu | s_movi | s_movhi | s_ldw | s_rd_wr | s_dma ;
      p_rf_rd0_en = s_alu | s_read32req | s_dma | s_ori | s_stw|s_branch;
      p_rf_rd1_en = s_alu | s_ori | s_stw |s_branch;
      p_dm_rd_en = s_read32req | s_read32resp | s_read64resp | s_read32DMAreq | s_read64DMAreq;
      p_dm_wr_en = s_write32 | s_write64 | s_write32DMA | s_write64DMA;
      s_not =  s_movi | s_stw | s_ldw;
      p_op1_sel = s_alu & ~s_not;
      
      p_br_id4=s_branch;
      // p_br_id4=0;
    /*case(p_opcode)

`E_E_OPCODE_READ32REQ : s_read32req=1;   
                     
`E_E_OPCODE_WRITE32 : s_write32=1;
             
`E_E_OPCODE_READ32RESP :s_read32resp=1;
             
`E_E_OPCODE_WRITE64 : s_write64=1;
             
`E_E_OPCODE_READ64RESP : s_read64resp=1;
             
`E_E_OPCODE_READ32DMAREQ  : s_read32DMAreq=1;
             
`E_E_OPCODE_WRITE32DMA :  s_write32DMA=1;
            
`E_E_OPCODE_READ64DMAREQ : s_read64DMAreq=1;
             
`E_E_OPCODE_WRITE64DMA : s_write64DMA=1;
             
`E_E_OPCODE_ADD :s_add=1;
             
`E_E_OPCODE_SUB :  s_sub=1;
             
`E_E_OPCODE_EQUAL : s_equal=1;
            
`E_E_OPCODE_BRANCH_:s_branch=1;
              
`E_E_OPCODE_MOVHI : s_movhi=1;
              
`E_E_OPCODE_MOVI :s_movi=1;
            
`E_E_OPCODE_ORI : s_ori=1;
           
`E_E_OPCODE_LDW : s_ldw=1;
              
`E_E_OPCODE_STW : s_stw=1;

`E_E_OPCODE_BRLT : s_brlt=1;

`E_E_OPCODE_BRGE : s_brge=1;
             
`E_E_OPCODE_BRLE : s_brle=1;

`E_E_OPCODE_BRGT : s_brgt=1;
             
`E_E_OPCODE_BREQ : s_breq=1;

`E_E_OPCODE_BRNE : s_brne=1;

`E_E_OPCODE_BRP : s_brp=1;

`E_E_OPCODE_BRN : s_brn=1;

`E_E_OPCODE_BRNN : s_brnn=1;

`E_E_OPCODE_BRZ : s_brz=1;  

`E_E_OPCODE_BRNZ : s_brnz=1;

`E_E_OPCODE_BRC : s_brc=1;
           
`E_E_OPCODE_BRNC : s_brnc=1;

`E_E_OPCODE_BRV : s_brnv=1;

`E_E_OPCODE_BRNV : s_brnv=1;
           
default : begin
              s_read32req=0;              
              s_write32=0;
              s_read32resp=0;
              s_write64=0;
              s_read64resp=0;
              s_read32DMAreq=0;
              s_write32DMA=0;
              s_read64DMAreq=0;
              s_write64DMA=0;
              s_add=0;
              s_sub=0;
              s_equal=0;
              s_movhi=0;
              s_movi=0;
              s_ori=0;
              s_ldw=0;
              s_stw=0; 
              s_brlt=0;
              s_brge=0;
              s_brle=0;
              s_brgt=0;
              s_breq=0;
              s_brne=0;
              s_brp=0;
              s_brn=0;
              s_brnn=0;
              s_brz=0;
              s_brnz=0;
              s_brc=0;
              s_brnc=0;
              s_brv=0;
              s_brnv=0;      
          end
endcase
 end

always @(posedge clk) begin
    case(p_opcode)

`E_E_OPCODE_ADD : p_op_sel=`E_OP_SEL_ADD_OP;
`E_E_OPCODE_SUB : p_op_sel=`E_OP_SEL_SUB_OP;
`E_E_OPCODE_EQUAL : p_op_sel=`E_OP_SEL_EQUAL_OP;
`E_E_OPCODE_ORI : p_op_sel=`E_OP_SEL_ORI_OP;
`E_E_OPCODE_STW : p_op_sel=`E_OP_SEL_STW_OP;

default : p_op_sel=3'bxxx;
endcase
             
 */ 
}     
};      

csl_unit mux_{
  csl_port in0(input,br_data),in1(input,br_data);
  csl_port sel(input);
  csl_port mux_out(output,br_data);
  mux_(){
    mux_out =(sel) ? in1 : in0;
  }};

csl_unit microEngine{
 
  csl_signal  ir_id_instr_ir3(br_instr);   //signal from ir to id. Contains the instruction which will be decoded
  csl_signal  id_rf_src0_rf4(br_rf);       //decoded signal which select the first operand  address 
  csl_signal  id_rf_src1_rf4(br_rf);      //decoded signal which select the second operand  address 
  csl_signal  alu_rf_alu6(br_data);       //signal from alu to rf which contains the write data for rf
  csl_signal  rf0_alu_rf4(br_data);       //first operand for alu from rf
  csl_signal  rf1_alu_rf4(br_data);      //second operand for alu from rf
  csl_signal  alu_dm_dm7(br_addr);        //operation result 
  csl_signal  br_id4;            //conditional branch -stage 6
  csl_signal  rf_in4(br_data);           //output of rf_mux signal
  csl_signal  op1_5(br_data);             //output ofalu_mux signal
  csl_signal  op1_sel5(3);                //operatin selector
  csl_signal clear;                    //clear signal for rf 
  csl_signal valid_4;                 //valid signal for rf
  csl_signal dst_sel_4;               //select signal for rf_mux
  csl_signal cntl_alu_id0(br_data);   // 10 bits signal for dm addr
  
  // interface with DM and IM
  csl_port enable(input);          
  csl_port clk(input);
  csl_port reset(input);
  csl_port im_data_in(input,br_instr);
  csl_port dm_data_in(input,br_data);
  csl_port im_wr_addr(output,br_pc); 
  csl_port im_rd_addr(output,br_pc); 
  csl_port dm_data_out(output,br_data);
  csl_port im_rd_en(output);
  csl_port im_wr_en(output);
  csl_port dm_rd_addr(output,br_pc);
  csl_port dm_wr_addr(output,br_pc);
  csl_port dm_rd_en(output);
  csl_port dm_wr_en(output);

   pc pc(.br_cond(cc_logic.br_cond),
        .br_id4(control.p_br_id4),
        .bro(id.p_immed[9:0]),                      //branch address = [9:0] bits from immediate value
        .id_br_addr(id.p_immed[9:0]),
        .pc_im_addr_pc1(im_rd_addr),
        .im_rd_en(im_rd_en),
        .reset(reset),
        .clk(clk),
        .enable(enable));

  IR ir(.clock(clk),
        .reg_in(im_data_in),
        .reg_out(ir_id_instr_ir3),
        .reset_(reset),
        .enable(enable));
  ID id(.p_br_len(control.p_br_length),
        .p_clock(clk),
        .p_dstreg(rf.wr_addr),
        .p_i(ir_id_instr_ir3),
        .p_immed(control.p_immed),
        .p_opcode(control.p_opcode),
        .p_bb(control.p_bb),
        .p_src(control.p_src),
        .p_id(control.p_id),
        .p_dst(control.p_dst),
        .p_srcreg1(id_rf_src0_rf4),
        .p_srcreg2(id_rf_src1_rf4));
  RF rf(.clear(clear),
        .clock(clk),
        .data_in(rf_in4),
        .data_out0(rf0_alu_rf4),
        .data_out1(rf1_alu_rf4),
        .wr_addr(id.p_dstreg),
        .rd_addr0(id_rf_src0_rf4),
        .rd_addr1(id_rf_src1_rf4),
        .rd_en0(control.p_rf_rd0_en),
        .rd_en1(control.p_rf_rd1_en),
        .reset(reset),
        .valid(valid_4),
        .wr_en(control.p_rf_wr_en));
  ALU alu(.alu_rez(alu_dm_dm7),
          .ci(c),                  //C field
          .co(c),                  //C field
          .op1(mux_in_alu.mux_out),
          .op2(rf1_alu_rf4),
          .op_sel(control.p_op_sel));
 
  /*  r_status status(.clock(clk),
                  .enable(enable),
                  .reg_in({alu.co,cc_logic.nzv}),
                  .reg_out(cc_logic.cc_in),
                  .reset_(reset));*/
  cc_logic cc_logic(.br_cond(pc.br_cond),
                    .cc_in(br_status),          //status field
                    .id_br_cond(control.p_id_br_cond),
                    .nzv(br_satus[2:0]));                
  control control(.p_opcode(id.p_opcode),
                  .p_immed(id.p_immed),
                  .p_op_sel(alu.op_sel),
                  .p_dst_sel(dst_sel_4),
                  .p_rf_wr_en(rf.wr_en),
                  .p_rf_rd0_en(rf.rd_en0),
                  .p_rf_rd1_en(rf.rd_en1),
                  .p_dm_wr_en(dm_wr_en),
                  .p_dm_rd_en(dm_rd_en),
                  .p_op1_sel(op1_sel_5),
                  .p_id_br_cond(cc_logic.id_br_cond),
                  .p_br_id4(pc.br_id4),
                  .p_bb(id.p_bb),
                  .p_src(id.p_src),
                  .p_id(id.p_id),
                  .p_dst(id.p_dst),
                  .p_br_length(id.p_br_len),
                  .clk(clk));

  mux_ mux_in_rf(.in0(alu_rf_alu6),
                 .in1(dm_data_in),
                 .mux_out(rf_in4),
                 .sel(dst_sel_4));
  mux_ mux_in_alu(.in0(cntl_alu_id0),
                  .in1(rf1_alu_rf4),
                  .mux_out(op1_5),
                  .sel(op1_sel_5));

  csl_include(file_verilog,"mE_logic");  //processor_ring/verilog

  microEngine(){
    /*
  cntl_alu_id0={{16{1'b0}},control.p_immed};  // 16b immediate value, concat with zero 
  dm_rd_addr=alu_dm_dm7[9:0];                  // 10 bits read address for DM
  dm_wr_addr=alu_dm_dm7[9:0];
  dm_data_out=rf1_alu_rf4;                    // write data for DM , from RF second output
    */
    clk.set_attr(clock);
}
};

csl_unit pr{
  csl_port load_data_im(input,br_instr);
  csl_port enable(input), reset(input), clk(input);

 
 IM im(.rd0_address(mE.im_rd_addr),
        .rd0_data(mE.im_data_in),
        .rd0_en(mE.im_rd_en),
        .wr0_address(mE.im_wr_addr),
        .wr0_data(load_data_im),
        .wr0_en(mE.im_wr_en));
  DM dm(.rd0_address(mE.dm_rd_addr),
        .rd0_data(mE.dm_data_in),
        .rd0_en(mE.dm_rd_en),
        .wr0_address(mE.dm_wr_addr),
        .wr0_data(mE.dm_data_out),
        .wr0_en(mE.dm_wr_en));
  microEngine mE(    .enable(enable),
                     .clk(clk),
                     .reset(reset),
                     .im_data_in(im.rd0_data),
                     .im_wr_addr(im.wr0_address),
                     .im_rd_addr(im.rd0_address),
                     .im_rd_en(im.rd0_en),
                     .im_wr_en(im.wr0_en),
                     .dm_data_in(dm.rd0_data),
                     .dm_data_out(dm.wr0_data),
                     .dm_rd_addr(dm.rd0_address),
                     .dm_wr_addr(dm.wr0_address),
                     .dm_rd_en(dm.rd0_en),
                     .dm_wr_en(dm.wr0_en)); 

  pr(){}
};
