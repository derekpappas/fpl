
//Copyright 2005, Cypress Semiconductor Corporation
/*****************************************************************************/
//This software is owned by Cypress Semiconductor Corporation (Cypress) and is
//protected by United States copyright laws and international treaty provisions.
//Cypress hereby grants to Licensee a personal, non-exclusive, non-transferable
//license to copy, use, modify, create derivative works of, and compile the
//Cypress Source Code and derivative works for the sole purpose of creating
//custom software in support of Licensee product ("Licensee Product") to be
//used only in conjunction with a Cypress integrated circuit. Any reproduction,
//modification, translation, compilation, or representation of this software
//except as specified above is prohibited without the express written permission
//of Cypress.


//Disclaimer: Cypress makes no warranty of any kind, express or implied, with
//regard to this material, including, but not limited to, the implied warranties
//of merchantability and fitness for a particular purpose. Cypress reserves the
//right to make changes without further notice to the materials described
//herein. Cypress does not assume any liability arising out of the application
//or use of any product or circuit described herein. Cypress products described
// herein are not authorized for use as components in life-support devices.
//This software is protected by and subject to worldwide patent coverage,
//including U.S. and foreign patents. Use may be limited by and subject to
//the Cypress Software License Agreement.
/*****************************************************************************/

//Source File Information Header Template
// *******************************************************************
// File           : fullflex72s18_addracc.v
// Author         :
// Author's Email :
// Date           : 23 MAR 2005
// Revision       : 1.0
// *******************************************************************
// Description : Address Access Logic Block. 
//               This block will generate address for read and
//               write operations from the memory.
//               This blcok is also responsible for all the burst
//               counter and mask register operations
// *******************************************************************


module fullflex72s18_addracc(iport,
	              inmsg,
		      iwmsg,
		      iemsg,
                      inreset,
                      iclk,
                      iclk_n,
                      incntmsk,
                      inads,
                      incnten,
                      inret,
                      incntrst,
                      iddron,
                      iftsel,
                      inwrp,
                      ibusy_addr,
                      inbusy,
                      addr_o,
		      addr_present_pipeline,
                      oreadback_ind,
                      oncntint,
                      ioaddr
                     );

   // User Selectable parameter
   parameter CYP_ADDRWIDTH =18;

   // Input/Putput definitions
   input                      iport;                 // Port identifier
   input                      inmsg;                 // NOTE message ON input
   input                      iwmsg;                 // WARNING message ON input
   input                      iemsg;                 // ERROR message ON input
   input                      inreset;               // Global reset generated by reset logic
   input                      iclk;                  // Input clk
   input                      iclk_n;                // Input clk with 180 phase shift
   input                      incntmsk;              // counter mask input active low
   input                      inads;                 // Port counter address strobe input 
   input                      incnten;               // COunter is enabled
   input                      incntrst;              // counter reset
   input                      inret;                 // retransmit is enabled
   input                      iddron;                // device configuration (DDR mode) 
   input                      iftsel;                // read latency
   input                      inbusy;                // Busy signal from arbitration logic
   input                      inwrp;                 // Port counter Wrap input
   input  [CYP_ADDRWIDTH-1:0] ibusy_addr;            // Busy address input from Arbitration
   output [CYP_ADDRWIDTH-1:0] addr_o;                // Address out
   output [CYP_ADDRWIDTH-1:0] addr_present_pipeline; // pipeline stage present address
   output                     oreadback_ind;         // readback indication to i/o control logic
   output                     oncntint;              // counter interrupt

   inout [CYP_ADDRWIDTH-1:0]  ioaddr;                // Address I/O

   // Internal wire and register declaration 
   integer                 i;
   wire                    bc_unmasked_mirror_reset;
   wire                    mask_reset;
   wire                    load_bc_and_mirror_in_addr;
   wire                    load_mask_reg_with_addr;
   wire                    load_bc_with_mirror_reg;
   wire                    bc_inc;
   wire                    bc_hold;
   wire                    readback_bc;
   wire                    readback_mask_reg;
   wire                    readback_last_busy_addr;

   reg [CYP_ADDRWIDTH-1:0] burst_counter;
   reg [CYP_ADDRWIDTH-1:0] burst_counter_prev;
   reg [CYP_ADDRWIDTH-1:0] mask_reg;
   reg [CYP_ADDRWIDTH-1:0] mirror_reg;
   reg [CYP_ADDRWIDTH-1:0] last_busy_addr;
   reg [CYP_ADDRWIDTH-1:0] addr_present_pipeline;
   reg                     trigger_2;
   reg                     trigger_25;
   reg                     trigger_1;
   reg [2:0]               count;
   reg [CYP_ADDRWIDTH-1:0] addr_o;
   reg [CYP_ADDRWIDTH-1:0] addr_o_temp;
   reg                     readback_int;
   reg [CYP_ADDRWIDTH-1:0] addr_io;
   reg                     cntint_n;
   wire [9:0]              signals;
   wire                    cntint_deactive;
   reg [CYP_ADDRWIDTH-1:0] busy_addr;
   reg [CYP_ADDRWIDTH-1:0] busy_addr1;
   reg                     readback;
   reg                     unknown_bit_load;
   reg			   busy_addr_latch_en;
   
   realtime                clock_event_time;
   realtime                clock_period;
   realtime                tCA;
   realtime                tAC;
   realtime                tSCINT;
   realtime                tRCINT;
   integer                 mask_change_bit;

   reg [CYP_ADDRWIDTH-1:0] ibusy_addr_1delay;
   reg			   inbusy_1delay;
   
   wire [CYP_ADDRWIDTH-1:0] maximum_count =  mask_reg | burst_counter;
   wire [CYP_ADDRWIDTH-1:0] burst_roll    = burst_counter & (~mask_reg);


   // Register initialization
   initial 
   begin
     readback = 1'b0;
     cntint_n = 1'b1;
     busy_addr_latch_en = 1'b1;
   end

   
   // Input clock period calculation
   always @(posedge inreset)
   begin
     if($realtime >0)
     begin
        @ (posedge iclk);
        clock_event_time = $realtime;
        @ (posedge iclk);
        clock_period = $realtime - clock_event_time;
     end
   end

   // Find the port independent timing parameters
   always@(inreset)
   begin 
      if(iport == 1'b1)
       begin 
          tSCINT = TP.tSCINT_l;
          tRCINT = TP.tRCINT_l;
          tCA    = TP.tCA_l;
          tAC    = TP.tAC_l;
       end
      else
       begin 
          tSCINT = TP.tSCINT_r;
          tRCINT = TP.tRCINT_r;
          tCA    = TP.tCA_r;
          tAC    = TP.tAC_r;
       end
   end

   // Delay Busy address by one clock period
   always @(ibusy_addr)
   begin
	ibusy_addr_1delay <= #(clock_period) ibusy_addr;
   end

   // Delay Busy signal by one clock period
   always @(inbusy)
   begin
	inbusy_1delay <= #(clock_period) inbusy;
   end

   // Concatenation all the counter control signals
   assign signals = {bc_unmasked_mirror_reset,mask_reset,
                     load_bc_and_mirror_in_addr,
                     bc_inc,bc_hold,load_mask_reg_with_addr,
                     load_bc_with_mirror_reg,readback_bc,
                     readback_mask_reg,readback_last_busy_addr
                    };

   // Generate the control signal used for the internal register operations 
   assign bc_unmasked_mirror_reset   = inreset & !incntrst & incntmsk;

   assign mask_reset                 = inreset & !incntrst & !incntmsk;

   assign load_bc_and_mirror_in_addr = inreset & incntrst & incntmsk & 
                                       !incnten & !inads;

   assign load_mask_reg_with_addr    = inreset & incntrst & !incntmsk & 
                                       !incnten & !inads;

   assign load_bc_with_mirror_reg    = inreset & incntrst & incntmsk & 
                                       !incnten & inads & !inret;

   assign bc_inc                     = inreset & incntrst & incntmsk & 
	                               !incnten & inads & inret;

   assign bc_hold                    = inreset & incntrst & incntmsk & 
	                               incnten & inads & inret;

   assign readback_bc                = inreset & incntrst & incntmsk & 
	                               incnten & !inads & inret;

   assign readback_mask_reg          = inreset & incntrst & !incntmsk & 
                                       incnten & !inads & inret;

   assign readback_last_busy_addr    = inreset & incntrst & !incntmsk & 
                                       incnten  & inads & !inret;

   //readback indicator for internal use of this chip
   assign oreadback_ind              = readback;

   // Generate address output
   assign ioaddr                     = (readback ==1'b1) ? 
	                               addr_io : {CYP_ADDRWIDTH {1'bz}};

   // Assign the conter interrupt
   assign oncntint                   = ~inreset ? 1'b1 : cntint_n;

   // Counter/ Mask update operation
   always@(posedge iclk or negedge inreset)
   begin : block1
     // RESET operation
     if(inreset==1'b0)
     begin 
        burst_counter         = {CYP_ADDRWIDTH{1'b0}};
        busy_addr1            = {CYP_ADDRWIDTH{1'b0}};
        busy_addr             = {CYP_ADDRWIDTH{1'b0}};
        mask_reg              = {CYP_ADDRWIDTH{1'b1}};
        last_busy_addr        = 0;
        count                 = 3'b0;
        mirror_reg            = 0;
        readback_int          = 0;
        addr_o_temp           = {CYP_ADDRWIDTH{1'bz}};
        addr_o                = {CYP_ADDRWIDTH{1'bz}};
	busy_addr_latch_en    = 1'b1;
     end
     else 
     begin
        // Counter / mask update operation
	
        if((iddron == 1'b1) || (iddron == 1'b0 && iftsel == 1'b1))
	begin
	  addr_o = addr_o_temp;
        end
 
        // Counter interrupt de-assertion
	if(cntint_deactive)
        begin
           cntint_n <= #(tRCINT + clock_period) 1'b1;
	end

        case(signals)
            10'b1000000000 :  //  unmasked portion of burst cnt and mirror reg 
                              //  will be resetred
            begin      
                readback_int           = 1'b0;

                for(i=0;i<CYP_ADDRWIDTH;i=i+1)
                begin 
                   if(mask_reg[i] )
                   begin 
                      burst_counter[i] = 1'b0;
                   end
                end
		addr_o_temp            = burst_counter;
		mirror_reg             = burst_counter;
            end
						   	
            10'b0100000000  : 
            begin   //mask reg reset 
                readback_int =  1'b0;
                mask_reg     = {CYP_ADDRWIDTH{1'b1}};
		addr_o_temp  = burst_counter;
            end
	    
            10'b0010000000 : //load burst cnt and mirror reg 
            begin
		unknown_bit_load = 1'b0;

	        for(i=0;i<CYP_ADDRWIDTH;i=i+1)
                begin
                   if((ioaddr[i]===1'bX) || (ioaddr[i]===1'bZ))
		       unknown_bit_load = 1'b1;
	        end
               
		if(unknown_bit_load == 1'b0)
		begin
                   burst_counter = ioaddr;
                   mirror_reg    = ioaddr;
	        end
	        else
	        begin
		   if(iport == 1'b1) 
		   begin
		     if(iemsg == 1'b1) 
		     begin
		       $display($realtime, "ERROR: Unknown value in the left address bus");
		       $display("Counter load operation Failed");
	             end
	           end
		   else
		   begin
		     if(iemsg == 1'b1) 
		     begin
		       $display($realtime, "ERROR: Unknown value in the right address bus");
		       $display("Counter load operation Failed");
	             end
	           end
	        end
                readback_int = 1'b0;
		addr_o_temp  = burst_counter;
            end
	    
            10'b0001000000 : // Burst counter increment 
            begin 
                readback_int = 1'b0;
	        burst_counter_prev = burst_counter;

                if(burst_counter < maximum_count)
                begin
                  case(mask_reg[1:0])
                     2'b11 : burst_counter=burst_counter+'d1;
                     2'b10 : burst_counter=burst_counter+'d2;
                     2'b00 : burst_counter=burst_counter+'d4;
                     default: 
		     begin
			if(iport == 1'b1)
			  if(iemsg == 1'b1) 
		            $display("Left Port Counter Increment ERROR, Illegal value in the Mask Register");
		        else
		          if(iemsg == 1'b1) 
		            $display("Right Port Counter Increment ERROR, Illegal value in the Mask Register");
		     end
                  endcase
                end
                else if (inwrp ==1'b1)
                  burst_counter = mirror_reg;
                else 
                  burst_counter = burst_roll;

                // CONTER INTERRUPT ASSERTION
		if (inreset == 1'b0 || burst_counter_prev >= maximum_count)
                   cntint_n = 1'b1;
                else if(!cntint_deactive)
                begin
                   case (mask_reg[1:0])
                     2'b11 : 
                     begin
                        if((burst_counter+2 == maximum_count))
                           cntint_n <= #(tSCINT + clock_period) 1'b0;
                        else 
                           cntint_n <= #(tRCINT + clock_period) 1'b1;
                     end 
                     2'b10 : 
                     begin
                        if(burst_counter+4 == maximum_count)
	                begin   
	                   cntint_n <= #(tSCINT + clock_period) 1'b0;
                        end 
                        else 
                           cntint_n <= #(tRCINT + clock_period) 1'b1;
                     end 
                     2'b00 : 
                     begin
                       if(burst_counter+'d8 == maximum_count)
	                  cntint_n  <= #(tSCINT + clock_period) 1'b0;
                       else 
                          cntint_n  <= #(tRCINT + clock_period) 1'b1;
                     end 
                     default :
                     begin 
                       cntint_n     <= #(tSCINT + clock_period) 1'b1;
	             end
                   endcase
                end
                else
		begin	
                   cntint_n         <= #(tRCINT + clock_period) 1'b1;
		end
		addr_o_temp  = burst_counter;
            end
	    
            10'b0000100000 : // Burst counter hold
            begin
                readback_int = 1'b0;
	        addr_o_temp  = burst_counter;	
            end
	    
            10'b0000010000 : // load_mask_reg_with_addr
            begin
                readback_int     = 1'b0;
                unknown_bit_load = 1'b0;
		mask_change_bit  = 0;

	        for(i=0;i<CYP_ADDRWIDTH;i=i+1)
                begin
                   if((ioaddr[i]===1'bX) || (ioaddr[i]===1'bZ))
		       unknown_bit_load = 1'b1;
	        end
			
                for(i=0; i<CYP_ADDRWIDTH-1; i=i+1)
                begin 
                   if((ioaddr[i]==1'b0) && (ioaddr[i+1] ==1'b1))
		   begin
                      count           = count+1;
		      mask_change_bit = i + 1;
	           end
                end 
		
                if((((ioaddr[0] == 1'b0 && count < 'd2 && mask_change_bit <= 2) || 
		     (ioaddr[0] == 1'b1 && count < 'd1)
	            ) && (unknown_bit_load == 1'b0)
		   ) || (ioaddr == {CYP_ADDRWIDTH{1'b0}})
		  )
                begin
                   mask_reg   = ioaddr;
                   count      = 3'b0;
                end 
                else
		begin
		  if(iport == 1'b1)
		  begin	  
		     if(iemsg == 1'b1) 
		     begin
			$display($realtime, "\n ERROR :Illegal input to load left mask register, ");
                        $display("\n Mask load operation Failed");
		     end
	          end
		  else
		  begin
		     if(iemsg == 1'b1) 
		     begin
		       $display($realtime, "\n ERROR :Illegal input to load right mask register, ");
                       $display("\n Mask load operation Failed ");
	             end
	          end  
		  count=3'b0;
                end
		addr_o_temp   = burst_counter;
            end
	    
            10'b0000001000 : // load_bc_with_mirror_reg
            begin
                readback_int  = 1'b0; 
                burst_counter = mirror_reg;
		addr_o_temp   = burst_counter;
            end
	    
            10'b0000000100 : // Readback burst counter 
            begin 
                addr_io          <= #tAC {CYP_ADDRWIDTH{1'bZ}};
                case(1'b1)
                  trigger_25 : 
                  begin
                     addr_io     <= #(tCA+clock_period) burst_counter;
                     readback_int = 1'b1;
                  end
                  trigger_2  :
                  begin
                     addr_io     <= #(tCA+clock_period) burst_counter;
                     readback_int = 1'b1;
                  end
		  trigger_1  :
		  begin
                     addr_io     <= #(tCA) burst_counter;
                     readback_int = 1'b1;
                  end
                endcase	
            end
	    
            10'b0000000010 : // Read back mask register 
            begin 
                addr_io          <= #tAC {CYP_ADDRWIDTH{1'bZ}};
                case(1'b1)
                  trigger_25:
                  begin
                     addr_io     <= #(tCA+clock_period) mask_reg;
                     readback_int = 1'b1;
                  end 
                  trigger_2 : 
                  begin
                     addr_io     <= #(tCA+clock_period) mask_reg;
                     readback_int = 1'b1;
                  end
		  trigger_1 : 
                  begin
                     addr_io     <= #(tCA) mask_reg;
                     readback_int = 1'b1;
                  end
                endcase
            end
            10'b0000000001 : // read back last busy address 
            begin
                addr_io          <= #tAC {CYP_ADDRWIDTH{1'bZ}};
                case((1'b1))
                  trigger_25:
                  begin
                     addr_io     <= #(tCA+clock_period) busy_addr;
                     readback_int = 1'b1;
                  end 
                  trigger_2 : 
                  begin
                     addr_io     <= #(tCA+clock_period) busy_addr;
                     readback_int = 1'b1;
                  end 
		  trigger_1 : 
                  begin
                     addr_io     <= #(tCA) busy_addr;
                     readback_int = 1'b1;
                  end
                endcase
		busy_addr_latch_en    = 1'b1;
            end
            default :
	    begin
              if(iport == 1'b1)
	      begin	  
	        if(iwmsg == 1'b1) 
		   $display($realtime, "\n WARNING :Undefined combination of left port counter/mask control pins ");
	      end
	      else
	      begin
	        if(iwmsg == 1'b1) 
		    $display($realtime, "\n WARNING :Undefined combination of right port counter/mask control pins ");
	      end  
	    end 
        endcase // end of case signals

	
        if(!((iddron == 1'b1) || (iddron == 1'b0 && iftsel == 1'b1)))
        begin
           addr_o = addr_o_temp;
        end

        addr_present_pipeline = addr_o_temp;  

        if(signals === 10'b0000000001 && inbusy_1delay == 1'b0)
	begin
	   busy_addr = ibusy_addr_1delay;
	   busy_addr_latch_en = 1'b0;
	end
	else if(busy_addr_latch_en == 1'b1 && inbusy_1delay == 1'b0)
	begin
	   busy_addr = ibusy_addr_1delay;
	   busy_addr_latch_en = 1'b0;
	end
            
     end //end of reset if
   end // end of always

   assign cntint_deactive    = bc_unmasked_mirror_reset | mask_reset |
                               load_bc_and_mirror_in_addr | load_mask_reg_with_addr |
                               load_bc_with_mirror_reg;
   // Readback delay adjustment               
   always@(readback_int)
   begin
     case((1'b1))
       trigger_25: 
       begin
	  if(readback_int == 1'b1)
             readback <= #(clock_period +tCA) readback_int;
          else
             readback <= #(clock_period +tAC) readback_int;
       end
       
       trigger_2 : 
       begin
	  if(readback_int == 1'b1)
             readback <= #(clock_period +tCA) readback_int;
          else
             readback <= #(clock_period +tAC) readback_int;
       end
       
       trigger_1 : 
       begin
	  if(readback_int == 1'b1)
             readback <= #(tCA) readback_int;
          else
             readback <= #(tAC) readback_int;
       end
     endcase
   end


   // Delay calculation for the readback operation
   // as per the control input 
   always @(inreset)
   begin 
      case({iddron,iftsel})
        2'b10 :
        begin 
          trigger_2  =1'b0;
          trigger_25 =1'b1; 
          trigger_1 = 1'b0;
        end
        2'b00 :
        begin 
          trigger_2  =1'b0;
          trigger_25 =1'b0; 
          trigger_1 = 1'b1;
        end

        2'b11 :
        begin 
          trigger_2  =1'b0;
          trigger_25 =1'b1;
          trigger_1 = 1'b0;
        end

        2'b01 :
        begin 
          trigger_2  =1'b1;
          trigger_25 =1'b0;
          trigger_1 = 1'b0;
        end

        default:
        begin
           if($realtime > 1 && iport == 1'b1)
	   begin 
	      if(iwmsg == 1'b1)
	      begin
		 $display($realtime, "ERROR: Unknown value in Left Port DDRON or FTSEL# pin");
	      end
	   end
           else if($realtime > 1 && iport == 1'b0)
	   begin
	      if(iwmsg == 1'b1)
	      begin
		 $display($realtime, "ERROR: Unknown value in Right Port DDRON or FTSEL# pin");
	      end
	   end
           trigger_2  =1'b1;
           trigger_25 =1'b0;
           trigger_1 = 1'b0;
        end
      endcase
   end

endmodule






