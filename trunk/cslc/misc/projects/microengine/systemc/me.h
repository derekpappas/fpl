#ifndef INC_GUARD_me_h
#define INC_GUARD_me_h

#include "systemc.h"
#include <stdio.h>
#include "me_config.h"
#include "im.h"
#include "rf.h"
#include "eu.h"
#include "MeInstructionDecoder.h"

SC_MODULE(me) {
	sc_in<bool> clk;
	sc_in<bool> reset_;
	sc_in<bool> enable;


	T_DATA_sc_signal eu_rf_wr_data;
	sc_signal<sc_uint<microengine::RF_ADDR_WIDTH> > eu_rf_wr_addr;
	sc_signal<bool> pc_im_v   ; 
	sc_signal<bool> im_rf_v   ; 
	sc_signal<bool> rf_eu_v   ; 
	sc_signal<bool> eu_rf_wren; 

	T_PC_sc_signal  pc_0;
	T_PC_sc_signal npc_2;
	T_PC_sc_signal npc_3;
	T_PC_sc_signal npc_4;

	sc_signal<bool> eu_branch; // branch signal generated by the eu branch operation
 
	sc_signal<sc_uint<32> > ir_rf_3;
	sc_signal<sc_uint<32> > ir_eu_4;

	unsigned int pcx;

	// im
	sc_signal<bool>    im_clock     ;
	sc_signal<bool>    im_RnW       ;   // ReadNotWrite
	sc_signal<TUInt >  pc_im_address;
	sc_signal<TUInt >  im_data      ;

	// rf
	sc_signal<sc_uint<microengine::RF_ADDR_WIDTH> > rf_wr_addr ;
	T_DATA_sc_signal rf_wr_data ;
	sc_signal<bool>  rf_wren    ; 

	//	sc_signal<sc_uint<microengine::RF_ADDR_WIDTH> > rf_rd_addr_a ;
	//	sc_signal<bool>         rf_rden_a    ; 
	T_DATA_sc_signal rf_rd_data_a ;

	//	sc_signal<sc_uint<microengine::RF_ADDR_WIDTH> > rf_rd_addr_b ;
	//	sc_signal<bool>         rf_rden_b    ; 
	T_DATA_sc_signal rf_rd_data_b ;

	//	sc_signal<bool>         pipeline_cancellation   ; 

	TUInt cycleCount;

    im<TUInt, microengine::IM_NUM_WORDS> *im_;
	rf *rf_;
	eu *eu_;

	NSOpcode::MeInstructionDecoder * id;

	void loadInstructionMemory  (string binaryFileName, bool ldTest = false) {
		im_->loadInstructionMemory(binaryFileName, ldTest);
	}

	void init() {
		//		rf_->init();
	}

	void debug() {
		std::cout << "reset_ = " << reset_.read() << std::endl;
		std::cout << "enable = " << enable.read() << std::endl;
		std::cout << "eu_branch = " << eu_branch.read() << std::endl;
		std::cout << " pc_im_v   = " << pc_im_v.read() << std::endl;
		std::cout << " im_rf_v   = " << im_rf_v.read() << std::endl;
		std::cout << " rf_eu_v   = " << rf_eu_v.read() << std::endl;
		std::cout << " eu_rf_wren= " << eu_rf_wren.read() << std::endl;
		std::cout << "pc_im_address = " << hex << pc_im_address.read() << std::endl;
		std::cout << "im.data = " << hex << im_data.read() << std::endl;
		std::cout << "npc_2 = " << hex << npc_2 << std::endl;
		std::cout << "npc_3 = " << hex << npc_3 << std::endl;
		std::cout << "npc_4 = " << hex << npc_4 << std::endl;
		std::cout << "pc_im_v = " << pc_im_v  << " im_RnW = " << im_RnW.read() << " pc_im_address = " << pc_im_address.read() << "  im_1 = " << im_data.read() << std::endl;
		std::cout << "im_data = " << im_data.read() << std::endl;
		std::cout << "ir_rf_3 = " << ir_rf_3 << std::endl;
		std::cout << "ir_eu_4 = " << ir_eu_4 << std::endl;

		std::cout << " eu_branch.read() = " << !eu_branch.read() << std::endl;
		std::cout << " pc_im_v   = " << pc_im_v.read() << std::endl;
		std::cout << " im_rf_v   = " << im_rf_v.read() << std::endl;
		std::cout << " rf_eu_v   = " << rf_eu_v.read() << std::endl;
		std::cout << " eu_rf_wren = " <<  eu_rf_wren << endl;
		std::cout << " eu_rf_wr_data  = " <<  eu_rf_wr_data << endl;
		std::cout << " eu_rf_wr_addr  = " <<  eu_rf_wr_addr << endl;

		std::cout << " rf_rd_addr_a = " << rf_->im_rf_instructionDecoder->getOperandA( )<< endl;
		std::cout << " rf_rd_addr_b = " << rf_->im_rf_instructionDecoder->getOperandB( )<< endl;
		std::cout << " rf_dest_addr = " << rf_->im_rf_instructionDecoder->getDestination( )<< endl;

		std::cout << " rf_rd_data_a = " <<  rf_rd_data_a << endl;
		std::cout << " rf_rd_data_b = " <<  rf_rd_data_b << endl;
		std::cout << " im_rf_v   = " <<  im_rf_v   << endl;
		std::cout << " rf_eu_v = " <<  rf_eu_v << endl;

	}

	void assign_pc_im_v() {
		pc_im_v.write(!eu_branch.read() && enable.read() );
	}
 
	void register_pc_0() {
		if (! reset_.read()) {
			pc_im_address.write(0);
			std::cout << "not pcx = " << pcx << std::endl;
		} 
		else if (enable.read()) {
			unsigned int pc_inc = pc_im_address.read() + 1;
			unsigned int n3     = npc_3.read(); 
			pcx    = eu_branch ? n3 : pc_inc;	
			pc_im_address.write(pcx);
		
			std::cout << " eu_branch = " << eu_branch.read() << " pcx = " << pcx   << " pc_inc = " << pc_inc  << std::endl;
		}
	    
		im_RnW.write(!eu_branch.read());
	}

	void register_rf_2() {
		id->setInstructionReg(im_data.read());

		npc_2.write(id->getBrAddress());

		ir_rf_3.write(im_data.read());    
	}

	void register_ex_3() {
		rf_rd_data_a.read();
		rf_rd_data_b.read();

		ir_eu_4.write(ir_rf_3.read());    
        npc_3.write(npc_2.read());
    }
 
    SC_CTOR(me) {
		std::cout << "unit me instance name = " << name() << std::endl;

		cycleCount = 0;

		im_ = new  im<TUInt, microengine::IM_NUM_WORDS>("instruction_memory");   // int,    16 locations, debug on
		im_->clk  (clk  );
		im_->reset_(reset_);
		im_->enable(enable);
		im_->eu_branch( eu_branch   );
		im_->RnW    (im_RnW    );
		im_->pc_im_v  (pc_im_v   );
		im_->pc_im_address(pc_im_address);
		im_->im_rf_v  (im_rf_v   );
		im_->data   (im_data   );

 
		rf_ = new rf("rf0_");
		rf_->clk(clk);
		rf_->reset_(reset_);
		rf_->enable(enable);
		rf_->eu_branch( eu_branch   );
		rf_->im_rf_ir(im_data);
		rf_->eu_rf_wren(eu_rf_wren);
		rf_->eu_rf_ir(ir_eu_4);
		rf_->eu_rf_wr_data (eu_rf_wr_data );
		rf_->eu_rf_wr_addr (eu_rf_wr_addr );
		rf_->rd_data_a(rf_rd_data_a);
		rf_->rd_data_b(rf_rd_data_b);
		rf_->im_rf_v  (im_rf_v   );
		rf_->rf_eu_v(rf_eu_v);

		//		rf_->wren(rf_wren);
		//		rf_->wr_addr (rf_wr_addr );
		//		rf_->wr_data (rf_wr_data );

		eu_ = new eu("eu0_");
		eu_->clk(clk);
		eu_->reset_(reset_);
		eu_->enable(enable);
		eu_->eu_branch( eu_branch   );
		eu_->rf_eu_v(rf_eu_v);
		eu_->rf_eu_ir(ir_rf_3);
		eu_->src_a(rf_rd_data_a);
		eu_->src_b(rf_rd_data_b);
		eu_->eu_rf_wr_data(eu_rf_wr_data);
		eu_->eu_rf_wr_addr(eu_rf_wr_addr);
		eu_->eu_rf_wren(eu_rf_wren);


		SC_METHOD(assign_pc_im_v);
		sensitive << pc_im_v << enable;

		SC_METHOD(debug);
		sensitive << clk.pos();

		SC_METHOD(register_pc_0);
		sensitive << clk.pos();
		
		SC_METHOD(register_rf_2);
		sensitive << clk.pos();

		SC_METHOD(register_ex_3);
		sensitive << clk.pos();

		id = new NSOpcode::MeInstructionDecoder();

		dont_initialize();
	}
};

#endif
