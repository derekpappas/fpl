Subject:   	Processor ring node documentation from California
From:   	"Derek Pappas" <dpappas@fastpathlogic.ro>
Date:   	Wed, March 7, 2007 00:10
------------------------------------------------------------

[Oana/Mihai]
-Please make the fixes to the draw documents
-Please add the truth tables and bus transactions below to the text document

[Catalin]
-Please fix the CSL/Verilog to match the new specs.

-dp


NID – node ID

Bus Signals
Valid - 1
Age – 1
Burst – 1 (ignore for now)
SrcNID – 4
DstNID – 4
Command – 4
Byte Enables – 4
Address - 24
Data – 32

The originating NID clears the age bit when sending the fabric
transaction. A predetermined node (or a single stage node without a
processor) is responsible for setting the age bit on all transactions
that pass through. If the age bit is set on a transaction that is
received by the designated node, then the designated node clears the
valid bit.

The address field is in bytes, but the address is expected to be
word-aligned (i.e. the two low-order bits should be set to zero and
can be ignored by the receiver).

When in burst mode, the Command, Byte Enables, Address, and Data
signals combine to make a 64-bit data signal. However, we should skip
Burst Mode for now due to the added complexity.


1. Read from Message Queue
-each processor has a queue manager that is responsible for receiving
and queuing messages from the fabric
-asynchronous read returns immediately (0 indicates no message waiting)
-synchronous read waits for a message in the queue

2. Send Message to Another Processor's Message Queue (NID, Queue)
-local processor is stalled until the message is sent on the fabric
-the remote processor does not have to be waiting for a message, the
queue manager is always running
-if the remote queue is full, the remote queue manager is responsible
for sending a message back indicating that the message was not
received
-there are a few special message types that do not get a response even
if the message queue is full: broacast message and queue full message

3. Read from Remote Processor (NID, Address)
-single word mode

4. Write to Remote Processor (NID, Address)
-single word mode

Special Considerations:
Each node has a fabric addressable register that has the running/reset
mode. This allows each node to be enabled/disabled via the fabric.

Within the Queue Manager on each node, there needs to be some
configuration capability to set the following properties:
Queue number for deflected transactions (i.e. where to send the
negative response when a received message is destined for a queue that
is full)

Ring NID
0 reserved
1 ring_node_1
2 ring_node_2
3 ring_node_3
4 ring_node_4
5 ring_node_5
6 ring_node_6
7 ring_node_7
8 ring_node_8
9 ring_node_9
15 broadcast (all nodes)

Note: ring_node_id[3:0] (width is configurable)

Within the address field, each node has a memory map. By convention,
the address map has processor instruction memory, processor data
memory, and registers, which include the queue manager. Using the
high-order bits to determine the address unit will work for now.

Unit Address Unit
0 instruction memory
1 data memory
2 registers
3 queue manager

Note: unit_address[2:0] (width is configurable)

Individual Unit Memory maps are addressed with the address[17:0] bus
line which is forwarded to all units. A unit eneable signal is
generated by the ring node address decoder.

====================================\
Bus commands
read single
read burst
write single
write burst

single read
cmd : read
data : xxxx
addr : 0x__
burst: off
valid: 1
rn_id: 0-9
u_id : 0-4

single write
cmd : write
data : xxxx
addr : 0x__
burst: off
valid: 1
rn_id: 0-9
u_id : 0-4

single rn_unit_select
cmd : rn_unit_select
data : xxxx
addr : 0x__ (ring node and unit ids)
burst: off
valid: 1
rn_id: 0-9
u_id : xxx

x = dont_care
d = data value
0x__ = a hex address
off = 0 for burst mode
on = 1 for burst mode

Example NIOS2 custom logic cmds and bus transactions
========================================
To execute a write from one processor to another the following process
takes place:

1. The program running on the processor executes a custom instruction
to write the destination NID and byte enables to registers in the
custom logic. Then the program executes another custom instruction
perform the write and specify the address and data.

2. The receiver ring node is selected by the rn_unit_select bus 
transaction.

3. The receiver ring node receives the bus write transaction and writes the
data to the appropriate address. This happens in hardware without the
processor being notified.
