`include "tst_inc.h"
`include "inc.h"
`timescale 1ns / 100ps


//*******************************************************************************
//  S Y N T H E S I Z A B L E      S D R A M     C O N T R O L L E R    C O R E
//
//  This core adheres to the GNU Public License  
// 
//  This is a synthesizable Synchronous DRAM controller Core.  As it stands,
//  it is ready to work with 8Mbyte SDRAMs, organized as 2M x 32 at 100MHz
//  and 125MHz. For example: Samsung KM432S2030CT,  Fujitsu MB81F643242B.
//
//  The core has been carefully coded so as to be "platform-independent".  
//  It has been successfully compiled and simulated under three separate
//  FPGA/CPLD platforms:
//      Xilinx Foundation Base Express V2.1i
//      Altera Max+PlusII V9.21
//      Lattice ispExpert V7.0
//  
//  The interface to the host (i.e. microprocessor, DSP, etc) is synchronous
//  and supports ony one transfer at a time.  That is, burst-mode transfers
//  are not yet supported.  In may ways, the interface to this core is much
//  like that of a typical SRAM.  The hand-shaking between the host and the 
//  SDRAM core is done through the "sdram_busy_l" signal generated by the 
//  core.  Whenever this signal is active low, the host must hold the address,
//  data (if doing a write), size and the controls (cs, rd/wr).  
//
//  Connection Diagram:
//  SDRAM side:
//  sd_wr_l                     connect to -WR pin of SDRAM
//  sd_cs_l                     connect to -CS pin of SDRAM
//  sd_ras_l                    connect to -RAS pin of SDRAM
//  sd_cas_l                    connect to -CAS pin of SDRAM
//  sd_dqm[3:0]                 connect to the DQM3,DQM2,DQM1,DQM0 pins
//  sd_addx[10:0]               connect to the Address bus [10:0]
//  sd_data[31:0]               connect to the data bus [31:0]
//  sd_ba[1:0]                  connect to BA1, BA0 pins of SDRAM
//   
//  HOST side:
//  mp_addx[22:0]               connect to the address bus of the host. 
//                              23 bit address bus give access to 8Mbyte
//                              of the SDRAM, as byte, half-word (16bit)
//                              or word (32bit)
//  mp_data_in[31:0]            Unidirectional bus connected to the data out
//                              of the host. To use this, enable 
//                              "databus_is_unidirectional" in INC.H
//  mp_data_out[31:0]           Unidirectional bus connected to the data in 
//                              of the host.  To use this, enable
//                              "databus_is_unidirectional" in INC.H
//  mp_data[31:0]               Bi-directional bus connected to the host's
//                              data bus.  To use the bi-directionla bus,
//                              disable "databus_is_unidirectional" in INC.H
//  mp_rd_l                     Connect to the -RD output of the host
//  mp_wr_l                     Connect to the -WR output of the host
//  mp_cs_l                     Connect to the -CS of the host
//  mp_size[1:0]                Connect to the size output of the host
//                              if there is one.  When set to 0
//                              all trasnfers are 32 bits, when set to 1
//                              all transfers are 8 bits, and when set to
//                              2 all xfers are 16 bits.  If you want the
//                              data to be lower order aligned, turn on
//                              "align_data_bus" option in INC.H
//  sdram_busy_l                Connect this to the wait or hold equivalent
//                              input of the host.  The host, must hold the
//                              bus if it samples this signal as low.
//  sdram_mode_set_l            When a write occurs with this set low,
//                              the SDRAM's mode set register will be programmed
//                              with the data supplied on the data_bus[10:0].
//
//
//  Author:  Jeung Joon Lee  joon.lee@quantum.com,  cmosexod@ix.netcom.com
//  
//*******************************************************************************
//
//  Hierarchy:
//
//  SDRAM.V         Top Level Module
//  HOSTCONT.V      Controls the interfacing between the micro and the SDRAM
//  SDRAMCNT.V      This is the SDRAM controller.  All data passed to and from
//                  is with the HOSTCONT.
//  optional
//  MICRO.V         This is the built in SDRAM tester.  This module generates 
//                  a number of test logics which is used to test the SDRAM
//                  It is basically a Micro bus generator. 
//  
//  MICRO.V
//  Synthesiable Microprocessor bus emulator.  It is used in conjuction with
//  SDRAM controller to issue a series of write + read commands.
//  The output "data_is_correct" is an active high signal.  When data read
//  from the SDRAM at a specified address matches the expected value,
//  this signal is set high.  Therefore in a typical test, this signal 
//  should be high at all times.  If it goes low, then either the data 
//  written to the SDRAM was incorrect, or the read process from the SDRAM
//  is invalid.
//

module micro(
                // system connections
                sys_clk,
                sys_rst_l,

                // Connections to the HOSTCONT.V
                sdram_busy_l,
                mp_addx,
                mp_data_out,
                mp_data_in,
                mp_wr_l,
                mp_rd_l,
                mp_cs_l,
                mp_size,
                next_state,
                data_is_correct,
                sdram_mode_set_l,           

                // debug
                top_state                
);


// ****************************************
//
//   I/O  DEFINITION
//
// ****************************************
// system connections
input           sys_clk;            // main system clock
input           sys_rst_l;          // main system reset

// connections to the SDRAM CONTROLLER
input           sdram_busy_l;       
output  [22:0]  mp_addx;
output          mp_wr_l;
output          mp_rd_l;
output          mp_cs_l;
output  [1:0]   mp_size;
input   [3:0]   next_state;
output  [31:0]  mp_data_out;        // data bus to the SDRAM controller
input   [31:0]  mp_data_in;         // data bus from the SDRAM controller
output          data_is_correct;
output          sdram_mode_set_l;

// debug
output  [3:0]   top_state;

// Intermodule connections
wire    [7:0]   bus_state;
wire            data_ena;
wire    [31:0]  mp_data_out;
wire    [31:0]  mp_data_in;

// Memory element definitions
reg     [3:0]   top_state;
reg             mp_cs_l;
reg             mp_wr_l;
reg             mp_rd_l;
reg     [31:0]  reg_mp_data_out;
reg     [22:0]  reg_mp_addx;
reg     [22:0]  reg_byte_counter;
reg             data_is_correct;
reg             sdram_mode_set_l;
reg     [1:0]   mp_size;
reg     [22:0]  MP_ADDX_DELTA;
reg     [31:0]  MP_DATA_DELTA;
reg     [31:0]  data_from_SDRAM;
reg     [31:0]  data_expected;  
reg     [10:0]  reg_modeset;

/*
** SINGLE WRITE FOLLOWED BY GAP THEN FOLLOWED BY SINGLE READ TEST
**
*/
`ifdef do_read_write_test
`endif


/*
** BURST WRITE FOLLOWED BY GAP THEN FOLLOWED BY BURST READ TEST
**
*/
`ifdef do_burst_write_read_test

`endif


// ***************************************************************
//
// Comprehensive Tester
//
// This test will do the following:
//      1. Issue a MRS (mode register set) to program the
//            MRS with 0x030 or 0x020 (CAS LAT = 3/2)
//      2. Do RW_COUNT number of Long-Word writes to the
//         SDRAM Controller, starting from address 0, at
//         4byte increment
//      3. Do RW_COUNT number of Long-Word read from the 
//         SDRAM Controller, starting from address 0, at
//         4byte increment
//      4. Do RW_COUNT number of Word writes to the SDRAM
//         Controller, starting at address 0, at 2byte 
//         increment.
//      5. Do RW_COUNT number of Word reads from the SDRAM
//         Controller, strating at address 0, at 2byte
//         increment.
//      6. Do RW_COUNT number of Byte writes to the SDRAM
//         Controller, starting at address 0, at 1byte
//         increment.
//      7. Do RW_COUNT number of Byte reads from the SDRAM
//         Controller, starting at address 0, at 1byte
//         increment.
//      8. goto step 1
//
// ***************************************************************

`ifdef do_single_burst_write_read_test

// the number of  write/read in the test
`define     RW_COUNT           23'h00008
// number of clock ticks between the reads.
`define     GAP_DELAY          23'h00008   


// Micro Simulator State Machine State Definitions
`define         powerup_delay            4'h0
`define         burst_write_cs           4'h1
`define         burst_write_assert_wr    4'h2
`define         burst_write_wait_4_busy  4'h3
`define         burst_write_deassert_wr  4'h4
`define         burst_wr_rd_delay        4'h5
`define         burst_read_cs            4'h6
`define         burst_read_assert_rd     4'h7
`define         burst_read_wait_4_busy   4'h8
`define         burst_read_deassert_rd   4'h9
`define         request_modereg_cs       4'ha
`define         request_modereg_assert_wr   4'hb
`define         request_modereg_wait_4_busy 4'hc
`define         request_modereg_deassert_wr 4'hd



`define         SIZE_IS_BYTE        2'b01
`define         SIZE_IS_WORD        2'b10
`define         SIZE_IS_LW          2'b00


assign  mp_addx      = reg_mp_addx;
assign  mp_data_out  = reg_mp_data_out;

always @(posedge sys_clk or negedge sys_rst_l)
  if (~sys_rst_l) begin
     top_state          <= `powerup_delay;      // initialze state
     mp_cs_l <= `HI;
     mp_wr_l <= `HI;
     mp_rd_l <= `HI;     
     reg_mp_addx        <= 23'h000000;          // reset address counter
     reg_mp_data_out    <= 32'h00000000;        // reset data counter
     reg_byte_counter   <= 23'h000000;          // clear byte counter
     data_is_correct    <= `HI;                 // correct by default
     sdram_mode_set_l   <= `HI;                 // do not issue mode reg change by default
     mp_size            <= 2'b00;
     reg_modeset        <= 11'h030;             // CAS LAT = 3
  end
  else case (top_state)   

     // Wait until the SDRAM has completed its power-up sequences
     `powerup_delay:  begin
          sdram_mode_set_l <= `HI;
          if (next_state==`state_idle) 
            top_state <= `request_modereg_cs;// go and do burst write
          else
            top_state <= `powerup_delay;
      end

     // *************************************** 
     //
     //  MODE REGISTER SETTING 
     //
     // *************************************** 
     // toggle the CAS latency from 2 to 3 
     // and 3 to 2.
     `request_modereg_cs: begin
         mp_cs_l          <= `LO;
         sdram_mode_set_l <= `LO;
         top_state        <= `request_modereg_assert_wr;
      end

     `request_modereg_assert_wr: begin
         mp_wr_l         <= `LO;
         reg_mp_data_out <= reg_modeset;
         reg_modeset     <= reg_modeset ^ 11'h010; // change between 020 <-> 030    
         top_state       <= `request_modereg_wait_4_busy;
      end

     `request_modereg_wait_4_busy: begin
         if (~sdram_busy_l)
            top_state <= `request_modereg_wait_4_busy;
         else 
            top_state <= `request_modereg_deassert_wr;
      end
       
     `request_modereg_deassert_wr: begin
         mp_cs_l          <= `HI;
         mp_wr_l          <= `HI;
         sdram_mode_set_l <= `HI;
         top_state        <= `burst_write_cs;
         reg_mp_data_out  <= 0;
      end

     // *************************************** 
     //
     //  MICRO-PROCESSOR WRITE BUS CYCLE
     //
     // *************************************** 
     // Assert MP CS to begin the write
     `burst_write_cs:  begin
         mp_cs_l  <= `LO;
         top_state   <= `burst_write_assert_wr;
     end

    // Assert MP WR 
    `burst_write_assert_wr: begin
         mp_wr_l <= `LO;
         top_state <= `burst_write_wait_4_busy;
    end
        
    // Wait until the SDRAM controller is no longer busy
    `burst_write_wait_4_busy:
         if (~sdram_busy_l)
            top_state <= `burst_write_wait_4_busy;
         else 
            top_state <= `burst_write_deassert_wr;

    // Deassert the WR, and check to see if it has completed all writes     
    `burst_write_deassert_wr:  begin
        mp_wr_l   <= `HI;       // deassert WR
        if (reg_byte_counter == `RW_COUNT) begin
            reg_mp_addx <= 0;
            reg_mp_data_out <= 0;
            reg_byte_counter <= 0;              // reset the counter
            mp_cs_l <= `HI;
            top_state <= `burst_wr_rd_delay;
        end else begin
            reg_mp_addx      <= reg_mp_addx      + MP_ADDX_DELTA;
            reg_mp_data_out  <= reg_mp_data_out  + MP_DATA_DELTA;
            reg_byte_counter <= reg_byte_counter + 1;       // one IO done
            top_state <= `burst_write_assert_wr;
        end
    end 
    
    // Wait here and kill GAP_DELAY number of cycles
    `burst_wr_rd_delay:  
        if (reg_byte_counter != `GAP_DELAY) begin
            reg_byte_counter <= reg_byte_counter + 1;
            top_state <= `burst_wr_rd_delay;
        end else begin
            reg_byte_counter <= 23'h000000;
            top_state <= `burst_read_cs;
        end


     // *************************************** 
     //
     //  MICRO-PROCESSOR READ BUS CYCLE
     //
     // *************************************** 
     // Assert MP CS to prepare for reads
     `burst_read_cs: begin
        mp_cs_l <= `LO;     // assert CS
        top_state <= `burst_read_assert_rd;
      end
      
      // Assert MP RD
     `burst_read_assert_rd: begin
        mp_rd_l <= `LO;
        top_state <= `burst_read_wait_4_busy;
     end

     // Wait until the SDRAM Controller is no longer busy
     `burst_read_wait_4_busy: 
        if (~sdram_busy_l)
            top_state <= `burst_read_wait_4_busy;
        else
            top_state <= `burst_read_deassert_rd;

            
     // Deassert MP RD and Prepare for the next resd, 
     `burst_read_deassert_rd: begin  
        if (data_from_SDRAM != data_expected)  begin
            data_is_correct <= `LO;
        end 
        mp_rd_l   <= `HI;       // deassert RD
        if (reg_byte_counter == `RW_COUNT) begin
            reg_mp_addx <= 0;
            reg_mp_data_out <= 0;
            reg_byte_counter <= 0;              // reset the counter
            mp_cs_l <= `HI;
            // change to next size count
            // 2'b00 -> 2'b01 -? 2'b10 -> 2'b00 ... etc
            // LW       BYTE     WD       LW
            if (mp_size == 2'b10) begin
               mp_size <= 2'b00;
               top_state <= `request_modereg_cs;
            end else begin
               mp_size <= mp_size + 1;
               top_state <= `burst_write_cs;
            end
        end else begin
            reg_mp_addx      <= reg_mp_addx      + MP_ADDX_DELTA;  // increment addx
            reg_mp_data_out  <= reg_mp_data_out  + MP_DATA_DELTA;  // increment data expected
            reg_byte_counter <= reg_byte_counter + 1;       // one IO done
            top_state <= `burst_read_assert_rd;         
        end
     end



  endcase


  // Select mp_addx change amount based on 
  // mp_size. 
  always @(mp_size)
    case (mp_size)
      `SIZE_IS_LW:    begin 
           MP_ADDX_DELTA = 23'h00000004; // access 4 bytes at a time
           MP_DATA_DELTA = 32'h11111111;
       end
      `SIZE_IS_WORD:  begin
           MP_ADDX_DELTA = 23'h00000002;
           MP_DATA_DELTA = 32'h03030303;
       end
      `SIZE_IS_BYTE:  begin
           MP_ADDX_DELTA = 23'h00000001;
           MP_DATA_DELTA = 32'h05050505;
       end
       default:       begin
           MP_ADDX_DELTA = 23'hxxxxxxxx;
           MP_DATA_DELTA = 32'hxxxxxxxx;
       end
    endcase


  // Select the data source and the data to be matched
  always @(mp_size or mp_addx or mp_data_in or reg_mp_data_out)
    case (mp_size)
      `SIZE_IS_LW: begin
            data_from_SDRAM = mp_data_in;
            data_expected   = reg_mp_data_out;
       end
      `SIZE_IS_WORD: begin
            case(mp_addx[1])
              // lower word
              1'b0: begin
                data_from_SDRAM = {16'hxxxx,mp_data_in[15:0]};
                data_expected   = {16'hxxxx,reg_mp_data_out[15:0]};
              end
              // upper word
              1'b1: begin
                data_from_SDRAM = {mp_data_in[31:16],16'hxxxx};
                data_expected   = {16'hxxxx,reg_mp_data_out[31:16],16'hxxxx};
              end
            endcase
       end
      `SIZE_IS_BYTE: begin
            case (mp_addx[1:0])
              // byte 0
              2'b00: begin
                data_from_SDRAM = {24'hxxxxxx,mp_data_in[7:0]};
                data_expected   = {24'hxxxxxx,reg_mp_data_out[7:0]};
              end
              // byte 1
              2'b01: begin
                data_from_SDRAM = {16'hxxxx,mp_data_in[15:8],8'hxx};
                data_expected   = {16'hxxxx,reg_mp_data_out[15:8],8'hxx};
              end
              // byte 2
              2'b10: begin
                data_from_SDRAM = {8'hxx,mp_data_in[23:16],16'hxxxx};
                data_expected   = {8'hxx,reg_mp_data_out[23:16],16'hxxxx};
              end
              // byte 3
              2'b11: begin
                data_from_SDRAM = {mp_data_in[31:24],24'hxxxxxx};
                data_expected   = {reg_mp_data_out[31:24],24'hxxxxxx};
              end
            endcase
       end
      `SIZE_IS_LW: begin
            data_from_SDRAM = 32'hxxxxxxxx;
            data_expected   = 32'hxxxxxxxx;
       end
    endcase

`endif


endmodule

