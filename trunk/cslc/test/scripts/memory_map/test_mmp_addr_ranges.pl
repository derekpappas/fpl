#!/usr/bin/perl

use Switch;               # the switch/case command
use File::Find;           # traversing the directory tree
use File::Basename;       # retrieving the basename of a directory
use File::Path;           # mkpath command

use strict;

#const for the test name
my $MEMMAPPAGE        = "mmp";
my $SETMMPRANGE       = "_setadd_";
my $SETMMPRESV        = "_addresv_";
my $ADDOBJ            = "_addobj_";
my $RANGE_OBL         = "_obl";
my $RANGE_OVL         = "_ovl";
my $RANGE_IB          = "_ib";
my $RANGE_OVU         = "_ovu";
my $RANGE_OBU         = "_obu";
my $ONE               = "_1rf_";
my $TWO               = "_2rf_";


#var used in tests
my $classMemoryMap     = "csl_memory_map";
my $memoryMapName      = "mem";
my $classMemoryMapPage = "csl_memory_map_page";
my $memoryMapPageName  = "mempage";
my $addAdrRange        = "add_address_range";
my $addAdrRangeResv    = "add_reserved_address_range";
my $addObject          = "add";
my $setUnit            = "set_unit_name";
my $classRegisterFile  = "csl_register_file";
my $registerFileName1  = "reg1";
my $registerFileName2  = "reg2";
my $classUnit          = "csl_unit";
my $unitName           = "u";

my $memAdrRange        = " 128,1024";
my $memAdrRangeResv1   = " 128,1024";
my $memAdrRangeResv2   = " 256, 512";
my $memAccessAdrRange  = " 128: 256";
my $rfRange1           = " 200";

my @mmpAddressRangeUpperArray    = (10, 16, 20, 32, 40, 48, 60, 64, 80, 96,100,112,128,130,144);
my @mmpAddressReservedRangeArray = ( 0, 16, 32, 48, 64, 80, 96,112,128,144);
my @rfDepthArray                 = ( 2,  4,  6,  8, 10, 12, 14, 16, 18, 20, 32, 48, 64, 80, 96, 112, 128, 144);
my @accessRangeType              = ($RANGE_OBL, $RANGE_OVL, $RANGE_IB, $RANGE_OVU, $RANGE_OBU);


#legend
my %access_range_description_map ;
   $access_range_description_map{$RANGE_OBL} = "//the given base address is completely out of bounds lower address compared to the csl_memory_map_page address range";
   $access_range_description_map{$RANGE_OVL} = "//the given base address is overlaping lower address compared to the csl_memory_map_page address range";
   $access_range_description_map{$RANGE_IB } = "//the given base address is in bounds compared to the csl_memory_map_page address range";
   $access_range_description_map{$RANGE_OVU} = "//the given base address is overlaping upper address compared to the csl_memory_map_page address range";                
   $access_range_description_map{$RANGE_OBU} = "//the given base address is completely out of bounds upper address compared to the csl_memory_map_page address range";  
                  

my $test_name = "";
my $test_date = `date "+%d/%m/%G, %T"`;
my @test_list = ();


#subroutine called
&generate_memory_map_tests;

#subroutine to make directories
sub mkDir {
    my($dirName) = @_;
    unless(-e "$dirName")  { `mkdir $dirName`; }
}

#subroutine to print in the generated file the legend
sub print_legend {
    my $range_type = $_[0];
    my $type       = $_[1];

    #print "print_legend\n";
    print FH "        $access_range_description_map{$range_type}\n";
    if ($type eq "_addresv") { print FH " reserved\n"; }
}

#subroutine to print in the generated file the header
sub print_header {
    my $test_name = $_[0];
    my $type      = $_[1];

    my $path="$ENV{WORK}/test/csl_cc_gen/";
    &mkDir("$path/mmp_addr_ranges_valid/");
    &mkDir("$path/mmp_addr_ranges_invalid/");

    if ( $type eq "valid") { 
        open (FH, ">$path/mmp_addr_ranges_valid/$test_name");   
    }
    else {
        open (FH, ">$path/mmp_addr_ranges_invalid/$test_name");   
    }

    #print "print_header\n";
    print FH "//Test generated by Ines\n";
    print FH "//Test name: $test_name\n";
    print FH "//Date: $test_date\n";
    print FH "//1 csl_register_file, 1 csl_unit, 1 csl_memory_map & 1 csl_memory_map_page are created\n";
    print FH "//the csl_memory_map_page has the folowing commands: add_address_range(), add_reserved_address_range() & addObject() under test\n";
}

#gen tests name
sub generate_memory_map_tests {
    
    #print "generate_memory_map_tests\n";

    #foreach my $mmpAddressRangeUpper (@mmpAddressRangeUpperArray) {
    #    foreach my $rfDepth (@rfDepthArray) {
    #        my $i;
    #        for ( $i = -3*$rfDepth ; $i <= 3*$rfDepth ; $i = $i + $rfDepth/2 ) {
    #            my $range;
    #            my $add;
    #            if ( $i >= 0 && ($i + $rfDepth) <= $mmpAddressRangeUpper ) {                
    #                $range = $RANGE_IB;
    #                $add = $i;
    #            }
    #            if ( $i < 0 && ($i + $rfDepth) <= 0 ) {    
    #                $range = $RANGE_OBL;
    #                $add = "m" . abs($i);
    #            }
    #            if ( $i < 0 && ($i +$rfDepth) > 0 ) {                
    #                $range = $RANGE_OVL;
    #                $add = "m" . abs($i);
    #            }
    #            if ( $i < $mmpAddressRangeUpper && ($i +$rfDepth) > $mmpAddressRangeUpper ) {                
    #                $range = $RANGE_OVU;
    #                $add = $i;
    #            }
    #            if ( $i >= $mmpAddressRangeUpper ) {                
    #                $range = $RANGE_OBU;
    #                $add = $i;
    #            }   
    #            
    #            if ( $range eq $RANGE_IB ) {
    #                $test_name = $MEMMAPPAGE . $SETMMPRANGE . "0-" . $mmpAddressRangeUpper . $ADDOBJ . $add . $ONE . $rfDepth . $range . "_valid.csl" ; 
    #                #print "inbounds " . $test_name . " " . $add . " " . $range . "\n" ;
    #            }
    #            else {
    #                $test_name = $MEMMAPPAGE . $SETMMPRANGE . "0-" . $mmpAddressRangeUpper . $ADDOBJ . $add . $ONE . $rfDepth . $range . "_invalid.csl" ; 
    #                #print "notinbounds " . $test_name . " " . $add . " " . $range . "\n" ;
    #            }
    #
    #            &print_header($test_name);
    #            print FH "\n";
    #         
    #            #csl_register
    #            print FH "$classRegisterFile $registerFileName1 {\n";
    #            print FH "    $registerFileName1() {\n";
    #            print FH "        set_width(2);\n";
    #            print FH "        set_depth($rfDepth);\n";
    #            print FH "    }\n";
    #            print FH "};\n\n";
    #         
    #            #csl_unit
    #            print FH "$classUnit $unitName {\n";
    #            print FH "    $registerFileName1 $registerFileName1;\n";
    #            print FH "    $unitName() {\n";
    #            print FH "    }\n";
    #            print FH "};\n\n";
    #         
    #            #csl_memory_map_page
    #            print FH "$classMemoryMapPage $memoryMapPageName { \n";
    #            print FH "    $memoryMapPageName() { \n";
    #            print FH "        $setUnit($unitName);\n";
    #            print FH "        $addAdrRange(0, $mmpAddressRangeUpper);\n";
    #            #print FH "        //the given address range is reserved in the csl_memory_map_page, then it is accessed for processing\n";
    #            print FH "        $addObject($unitName.$registerFileName1, \"$registerFileName1\", $i);\n";
    #            &print_legend($range); 
    #            print FH "    }\n";
    #            print FH "};\n\n";
    #         
    #            #csl_memory_map
    #            print FH "$classMemoryMap $memoryMapName { \n";
    #            # print FH "    $memoryMapPageName $memoryMapPageName; \n";
    #            # the mem_map_page has auto generated instance
    #            print FH "    $memoryMapName() { \n";
    #            print FH "        set_type(hierarchical);\n";
    #            print FH "    }\n";
    #            print FH "};\n";
    #        }
    #    }
    #}
    #close(FH);

    foreach my $mmpAddressRange1 (@mmpAddressRangeUpperArray) {
        foreach my $mmpAddressRange2 (@mmpAddressRangeUpperArray) {
            foreach my $mmpAddressRange3 (@mmpAddressRangeUpperArray) {
                if ( $mmpAddressRange1 <= $mmpAddressRange2 && $mmpAddressRange2 < $mmpAddressRange3) {
                    my $mmpAddrRange2;
                    foreach my $rfDepth (@rfDepthArray) {
                        my $i;
                        for ( $i = -3*$rfDepth ; $i <= 3*$rfDepth ; $i = $i + $rfDepth/2 ) {
                            my $range_type;
                            my $add;
                            if ( $mmpAddressRange1 eq $mmpAddressRange2) {
                                if ( ($i >= 0 && ($i + $rfDepth) <= $mmpAddressRange3) ) {                
                                    $range_type = $RANGE_IB;
                                    $add = $i;
                                }
                                if ( ($i < 0 && ($i + $rfDepth) <= 0) ) {    
                                    $range_type = $RANGE_OBL;
                                    $add = "m" . abs($i);
                                }
                                if ( $i < 0 && ($i + $rfDepth) > 0 ) {                
                                    $range_type = $RANGE_OVL;
                                    $add = "m" . abs($i);
                                }
                                if ( $i >= 0 && $i < $mmpAddressRange3 && ($i +$rfDepth) > $mmpAddressRange3 ) {                
                                    $range_type = $RANGE_OVU;
                                    $add = $i;
                                }
                                if ( $i >= $mmpAddressRange3) {                
                                    $range_type = $RANGE_OBU;
                                    $add = $i;
                                }    
                                $mmpAddrRange2 = $mmpAddressRange2 + 1;
                            }
                            else {
                                if ( ($i >= 0                 && ($i + $rfDepth) <= $mmpAddressRange1) || 
                                     ($i >= $mmpAddressRange2 && ($i + $rfDepth) <= $mmpAddressRange3) ) {                
                                    $range_type = $RANGE_IB;
                                    $add = $i;
                                }
                                if ( ($i < 0                 && ($i + $rfDepth) <= 0) || 
                                     ($i < $mmpAddressRange2 && ($i + $rfDepth) <= $mmpAddressRange2) ) {    
                                    $range_type = $RANGE_OBL;
                                    $add = "m" . abs($i);
                                }
                                if ( ($i < 0                 && ($i + $rfDepth) > 0) || 
                                     ($i < $mmpAddressRange2 && ($i + $rfDepth) > $mmpAddressRange2) ) {                
                                    $range_type = $RANGE_OVL;
                                    $add = "m" . abs($i);
                                }
                                if ( ($i >= 0 && $i < $mmpAddressRange1 && ($i +$rfDepth) > $mmpAddressRange1) || 
                                     ($i >= 0 && $i < $mmpAddressRange3 && ($i +$rfDepth) > $mmpAddressRange3 ) ) {                
                                    $range_type = $RANGE_OVU;
                                    $add = $i;
                                }
                                if ( $i >= $mmpAddressRange1 || $i >= $mmpAddressRange3) {                
                                    $range_type = $RANGE_OBU;
                                    $add = $i;
                                }  
                                $mmpAddrRange2 = $mmpAddressRange2;
                            }
                            
                            if ( $range_type eq $RANGE_IB ) {
                                $test_name = $MEMMAPPAGE . $SETMMPRANGE . "0_" . $mmpAddressRange1 . "_" . $mmpAddrRange2 . "_" . $mmpAddressRange3 . 
                                    $ADDOBJ . $add . $ONE . $rfDepth . $range_type . "_valid.csl" ; 
                                #print "inbounds " . $test_name . " " . $add . " " . $range . "\n" ;
                                &print_header($test_name, "valid");
                            }
                            else {
                                $test_name = $MEMMAPPAGE . $SETMMPRANGE . "0_" . $mmpAddressRange1 . "_" . $mmpAddrRange2 . "_" . $mmpAddressRange3 . 
                                    $ADDOBJ . $add . $ONE . $rfDepth . $range_type . "_invalid.csl" ; 
                                #print "notinbounds " . $test_name . " " . $add . " " . $range . "\n" ;
                                &print_header($test_name, "invalid");
                            }
                    
                            print FH "\n";
                            
                            #csl_register
                            print FH "$classRegisterFile $registerFileName1 {\n";
                            print FH "    $registerFileName1() {\n";
                            print FH "        set_width(2);\n";
                            print FH "        set_depth($rfDepth);\n";
                            print FH "    }\n";
                            print FH "};\n\n";
                            
                            #csl_unit
                            print FH "$classUnit $unitName {\n";
                            print FH "    $registerFileName1 $registerFileName1;\n";
                            print FH "    $unitName() {\n";
                            print FH "    }\n";
                            print FH "};\n\n";
                            
                            #csl_memory_map_page
                            print FH "$classMemoryMapPage $memoryMapPageName { \n";
                            print FH "    $memoryMapPageName() { \n";
                            print FH "        $setUnit($unitName);\n";
                            print FH "        $addAdrRange(0, $mmpAddressRange1);\n";
                            print FH "        $addAdrRange($mmpAddrRange2, $mmpAddressRange3);\n";
                            #print FH "        //the given address range is reserved in the csl_memory_map_page, then it is accessed for processing\n";
                            print FH "        $addObject($unitName.$registerFileName1, \"$registerFileName1\", $i);\n";
                            &print_legend($range_type); 
                            print FH "    }\n";
                            print FH "};\n\n";
                            
                            #csl_memory_map
                            print FH "$classMemoryMap $memoryMapName { \n";
                            # print FH "    $memoryMapPageName $memoryMapPageName; \n";
                            # the mem_map_page has auto generated instance
                            print FH "    $memoryMapName() { \n";
                            print FH "        set_type(hierarchical);\n";
                            print FH "    }\n";
                            print FH "};\n";
                        }
                    }

                    #print "range1 = $mmpAddressRange1 range2 = $mmpAddrRange2 range3 = $mmpAddressRange3 \n";
                }
            }
        }
    }
    close(FH);

    print "[INFO]Done\n";
}

