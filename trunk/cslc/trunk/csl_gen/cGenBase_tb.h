//---------------------------------------------------------------------
// Copyright (C) 2005, 2006, 2007 Fastpath Logic
// All Rights Reserved.
// This is UNPUBLISHED PROPRIETARY SOURCE CODE of Fastpathlogic;
// the contents of this file may not be disclosed to third parties,
// copied or duplicated in any form, in whole or in part, without the prior
// written permission of Fastpathlogic.
//
// RESTRICTED RIGHTS LEGEND:
// Use, duplication or disclosure by the Government is subject to
// restrictions as set forth in subdivision (c)(1)(ii) of the Rights in
// Technical Data and Computer Software clause at DFARS 252.227-7013,
// and/or in similar or succesor clauses in the FAR, DOD or NASA FAR Supplement.
// Unpublished rights reserved under the Copyright Laws of the United States
//----------------------------------------------------------------------

/* Usage:
   - make sure that the environment variable WORK stores the path where the
     repository is on the current machine (e.g. WORK = /storage/users/tharet/svn)
   - the syntax for executing the test generators is <generator_name> [<chapter>]
     (<chapter> = fifo | interconnect | isa | language | memory | memory_map | register | register_file | testbench | verification_components)
   - the previously generated tests are automatically deleted
   - the tests are created in the repository directory WORK/misc/test/csl
   - the directories where the tests are generated have in their names
     a "code"(number) that tells whichs test generator is responsible for those tests:
         0 - the declaration tests (cGenDecl_tb)
         1 - the instance declaration tests (cGenInstDecl_tb)
         2 - the command call tests (cGenCmds_tb)
         3 - the command call through instance tests (cGenInstCmds_tb)

     e.g.: csl_fifo_cg0_invalid means that the tests inside that directory are
           related to the fifo chapter, are generated by 0(see above) and all
           those tests are invalid

   - each of those directories have inside a "regression_control" which states
     whether the tests are valid or invalid
 */

/*list of all objects in CSL
 */
// csl_bitrange
// csl_enum
// csl_event
// csl_field
// csl_fifo
// csl_interface
// csl_isa_field
// csl_memory
// csl_memory_map
// csl_memory_map_page
// csl_multi_dim_bitrange
// csl_port
// csl_register
// csl_register_file
// csl_signal
// csl_signal_group
// csl_state_data
// csl_testbench
// csl_unit
// csl_vector

/*list of all csl commands
 */
// add
// add_address_range
// add_allowed_range
// add_equation
// add_logic
// add_reserved_address_range
// add_to_memory_map
// auto_gen_memory_map
// concat
// connect
// create_rtl_module
// exclusion_list
// gen_decoder
// generate_individual_rtl_signals
// get_address_increment
// get_alignment
// get_attr
// get_attributes
// get_bitrange
// get_clock_name
// get_cnt_dir_signal
// get_data_word_width
// get_depth
// get_dim_bitrange
// get_dim_lower
// get_dim_offset
// get_dim_upper
// get_dim_width
// get_empty_name
// get_endianess
// get_enum
// get_enum_item
// get_full_name
// get_lower
// get_lower_bound
// get_lower_index
// get_mnemonic
// get_next_address
// get_offset
// get_output_filename
// get_pop_name
// get_prefix
// get_push_name
// get_radix
// get_rd_addr_name
// get_rd_clock_name
// get_rd_data_name
// get_rd_en_name
// get_reset_name
// get_signal_prefix
// get_signal_prefix_local
// get_simulation_timeout_count
// get_suffix
// get_symbol_length
// get_type
// get_unit_prefix
// get_upper
// get_upper_bound
// get_upper_index
// get_valid_name
// get_value
// get_vc_capture_edge_type
// get_vc_clock
// get_vc_compare_trigger
// get_vc_cpp_rd_name
// get_vc_cpp_wr_name
// get_vc_end_generation_trigger
// get_vc_header_comment
// get_vc_id
// get_vc_max_number_of_capture_events
// get_vc_max_number_of_mismatches
// get_vc_max_num_states
// get_vc_module
// get_vc_name
// get_vc_reset
// get_vc_stall
// get_vc_start_generation_trigger
// get_vc_timeout
// get_width
// get_wr_addr_name
// get_wr_clock_name
// get_wr_data_name
// get_wr_en_name
// include_only
// merge
// print
// reverse
// set_access_rights
// set_access_rights_enum
// set_address_increment
// set_alignment
// set_attr
// set_attributes
// set_bitrange
// set_clk_divider
// set_clk_multiplier
// set_clock_name
// set_const_value
// set_data_word_width
// set_decoder_name
// set_decoder_out_name_prefix
// set_decoder_out_name_suffix
// set_default_value
// set_depth
// set_dim_bitrange
// set_dim_offset
// set_dim_range
// set_dim_width
// set_direction
// set_duration
// set_empty_name
// set_endianess
// set_enum
// set_enum_item
// set_field
// set_field_position
// set_full_name
// set_generator_type
// set_instance_alteration_bit
// set_mem_instance_name
// set_mnemonic
// set_module_name
// set_name
// set_next
// set_next_address
// set_number_of_dimensions
// set_offset
// set_pattern
// set_period
// set_phase_difference
// set_physical_implementation
// set_pop_name
// set_prefix
// set_previous
// set_push_name
// set_radix
// set_range
// set_rd_addr_name
// set_rd_clock_name
// set_rd_data_name
// set_rd_en_name
// set_reset
// set_reset_name
// set_signal_name
// set_signal_prefix_local
// set_start_signal
// set_suffix
// set_symbol_max_length
// set_testbench_verilog_filename
// set_timebase
// set_top_unit
// set_type
// set_unit_prefix
// set_value
// set_valid_name
// set_vc_capture_edge_type
// set_vc_clock
// set_vc_compare_trigger
// set_vc_cpp_rd_name
// set_vc_cpp_wr_name
// set_vc_end_generation_trigger
// set_vc_header_comment
// set_vc_id
// set_vc_max_number_of_capture_events
// set_vc_max_number_of_mismatches
// set_vc_max_num_of_transaction_events
// set_vc_max_num_states
// set_vc_name
// set_vc_output_filename
// set_vc_reset
// set_vc_stall
// set_vc_start_generation_trigger
// set_vc_timeout
// set_version
// set_width
// set_wr_addr_name
// set_wr_clock_name
// set_wr_data_name
// set_wr_en_name

/* The legal declarations in CSL:
  - CSL_FIELD: CSL_FIELD
  - CSL_FIFO: 
  - CSL_INTERFACE: CSL_PORT
  - CSL_ISA_FIELD: CSL_ISA_FIELD
  - CSL_MEMORY: 
  - CSL_MEMORY_MAP: 
  - CSL_MEMORY_MAP_PAGE: 
  - CSL_REGISTER: CSL_FIELD, 
  - CSL_REGISTER_FILE: 
  - CSL_SIGNAL_GROUP: CSL_BITRANGE, CSL_MULTI_DIM_BITRANGE, CSL_SIGNAL
  - CSL_TESTBENCH: CSL_BITRANGE, CSL_MULTI_DIM_BITRANGE, CSL_SIGNAL, CSL_PORT, CSL_VECTOR
  - CSL_UNIT: CSL_BITRANGE, CSL_FIELD, CSL_MULTI_DIM_BITRANGE, CSL_SIGNAL, CSL_PORT
*/

/* The legal instantiations in CSL:
  - CSL_FIELD: CSL_FIELD
  - CSL_INTERFACE: CSL_INTERFACE
  - CSL_ISA_FIELD: CSL_ISA_FIELD
  - CSL_MEMORY_MAP: CSL_MEMORY_MAP_PAGE
  - CSL_MEMORY_MAP_PAGE: CSL_MEMORY_MAP_PAGE
  - CSL_REGISTER: CSL_FIELD
  - CSL_SIGNAL_GROUP: CSL_SIGNAL_GROUP
  - CSL_UNIT: CSL_FIELD, CSL_FIFO, CSL_INTERFACE, CSL_MEMORY, CSL_REGISTER, CSL_REGISTER_FILE, CSL_SIGNAL_GROUP, CSL_UNIT
 */

#ifndef _CGEN_BASE_H_
#define _CGEN_BASE_H_

#include "cGenDecl_tb.h"
#include "cGenInstDecl_tb.h"
#include "cGenCmds_tb.h"
#include "cGenInstCmds_tb.h"

//-----------------------------------stuff-----------------------------------//
extern unsigned long                                                    TEST_COUNTER;

extern string                                                           FILE_HEADER;

//-----------------------------------containers-----------------------------------//
extern ECSLClassStringMap                                               cslGenericName;
extern ECSLClassStringMap                                               cslTypeName;
extern ECSLClassStringMap                                               cslObjName;
extern ECSLClassStringMap                                               cslObj1Name;
extern ECSLClassStringMap                                               cslObj2Name;
extern ECSLClassStringMap                                               cslParamName;
extern ECSLClassStringMap                                               cslInst1Name;

extern ECSLCmdStringMap                                                 cslCmdName;

extern CSLClassPointVect                                                cslClasses;

extern CSLCmdPointVect                                                  cslCmds;

//-----------------------------------chapters-----------------------------------//
extern string                                                           cFifo;
extern string                                                           cInterconnect;
extern string                                                           cIsa;
extern string                                                           cLanguage;
extern string                                                           cMemory;
extern string                                                           cMemMap;
extern string                                                           cRegister;
extern string                                                           cRegisterFile;
extern string                                                           cTestbench;
extern string                                                           cVerifComp;

//-----------------------------------global functions-----------------------------------//
template<class T1, class T2>
  string getName(map<T1, string> mapType, T1 index);

string intToString(int val);

string getTime();
void getTime(unsigned long& storeTo);

void buildGenericNames();
void buildClassNames();
void buildObjNames();
void buildDeclVectors();
void buildCmdNames();
void buildContainers();

void addCmd(ECSLClass cls,
            ECSLCmdType cmdType,
            bool canCallFromGlobalScope,
            bool canCallFromInstance,
            bool returnValue,
            CSLParamPointVect paramVect = CSLParamPointVect(),
            CSLCmdPointVect preCmdVect = CSLCmdPointVect(),
            CSLClassPointVect preDeclVect = CSLClassPointVect());

void buildBitrange();
void buildEnum();
void buildEvent();
void buildField();
void buildFifo();
void buildInterface();
void buildIsaField();
void buildMemory();
void buildMemMap();
void buildMemMapPage();
void buildMultiDimBitrange();
void buildPort();
void buildRegister();
void buildRegFile();
void buildSignal();
void buildSigGroup();
void buildStateData();
void buildTestbench();
void buildUnit();
void buildVector();

bool isValidChapter(string chapter);

void createRegressionCtrl(string path,
                          bool valid);

bool checkMainArgs(int argc,
                   char** argv);

bool checkRepositoryPath();

bool checkPath(string path);

bool getAbsoluteTestPath();

bool makeDir(const char* path,
             const char* dirName,
             bool isValid);

void buildValidInvalidDirs(string path,
                           string name);

void buildDirName(string &storeTo,
                  string path,
                  string name,
                  ETestGen tgType);

void executeClean(string mask);

void buildMakeDirs(ETestGen tgType);

EError runChecks(int argc,
                char** argv);

bool belongsToChapter(CSLClassPoint cls);

string determineDir(CSLClassPoint cls);

void buildHeader(char* binaryFileName);

void createReport(char* binaryFileName,
                  ETestGen tgType);

EError runTestGen(ETestGen tgType,
                 int argc,
                 char** argv,
                 void (*f)());

void printScopeBegin(ostream& output,
                     CSLClassPoint cls,
                     ECSLClassStringMap nameBase,
                     string alignment = ALIGN_NONE);

void printScopeEnd(ostream& output,
                   string alignment = ALIGN_NONE);

void printScopeConstrBegin(ostream& output,
                           CSLClassPoint cls,
                           ECSLClassStringMap nameBase,
                           string alignment = ALIGN_NONE);

void printScopeConstrEnd(ostream& output,
                         string alignment = ALIGN_NONE);

void printScopeCall(ostream& output,
                    CSLCmdPoint cmd,
                    string alignment = ALIGN_NONE);

void printScopeCallVect(ostream& output,
                        CSLCmdPointVect cmdVect,
                        string alignment = ALIGN_NONE);

void printCallParam(ostream& output,
                    CSLParamPointVect paramVect,
                    unsigned objCount = OBJ_COUNT_ZERO);

void printPlainDecl(ostream& output,
                    CSLClassPoint cls,
                    ECSLClassStringMap nameBase,
                    CSLParamPointVect paramVect = CSLParamPointVect(),
                    string alignment = ALIGN_NONE);

void printPlainDeclVect(ostream& output,
                        CSLClassPointCSLParamVectPointPairVect preDeclVect,
                        ECSLClassStringMap nameBase,
                        string alignment = ALIGN_NONE);

void printParamDecl(ostream& output,
                    ECSLParamDecl declType,
                    CSLParamPointVect paramVect = CSLParamPointVect(),
                    unsigned objCount = OBJ_COUNT_ZERO,
                    string alignment = ALIGN_NONE);

void printParamDeclVect(ostream& output,
                        ECSLParamDecl declType,
                        CSLClassPointCSLParamVectPointPairVect preDeclVect,
                        string alignment = ALIGN_NONE);

void printPlainCall(ostream& output,
                    CSLClassPoint cls,
                    ECSLClassStringMap nameBase,
                    CSLCmdPoint cmd,
                    string alignment = ALIGN_NONE);

void printPlainHidCall(ostream& output,
                       string scopeHID,
                       CSLClassPoint cls,
                       ECSLClassStringMap nameBase,
                       CSLCmdPoint cmd,
                       string alignment = ALIGN_NONE);

void printPlainCallVect(ostream& output,
                        CSLClassPoint cls,
                        ECSLClassStringMap nameBase,
                        CSLCmdPointVect cmdVect,
                        string alignment = ALIGN_NONE);

void printInstDecl(ostream& output,
                   CSLClassPoint cls,
                   ECSLClassStringMap nameBase,
                   string alignment = ALIGN_NONE);

void openFile(ofstream& output,
              string fileName);

void closeFile(ofstream& output,
              string fileName,
              string fileHeader);

CSLClassPointCSLParamVectPointPairVectVect createPreDeclVectOrder(CSLClassPointVect preDecl);

/* DEBUG
 */
void test();
/*~DEBUG
 */

CSLEnumItemPoint castToEnumItem(CSLParamPoint param);

CSLClassPointVect getPreDeclVect(CSLParamPoint param);
CSLClassPointCSLParamVectPointPairVectVect getPreDeclVectOrder(CSLParamPointVect paramVect);

string appendStrings(CSLClassPoint cls,
                     string dirSuffix,
                     unsigned count,
                     CSLCmdPoint cmd);

string appendStrings(CSLClassPoint cls,
                     CSLClassPoint obj,
                     string dirSuffix,
                     unsigned count,
                     CSLCmdPoint cmd);

void determineFileName(CSLClassPoint cls,
                       string& fileName,
                       string& fileHeader,
                       bool valid,
                       string comment,
                       CSLCmdPoint cmd = NULL);

void determineFileName(CSLClassPoint cls,
                       CSLClassPoint obj,
                       string& fileName,
                       string& fileHeader,
                       bool valid,
                       string comment,
                       CSLCmdPoint cmd = NULL);

//******************************************************************************//
// CSLChapter class                                                             //
//******************************************************************************//
class CSLChapter {
  private:
    ECSLChapter                                         m_chapter;
    unsigned                                            m_illegalCounter;
    unsigned                                            m_legalCounter;

  public:
    CSLChapter(ECSLChapter cpt = CPT_ALL);

    unsigned incIllegalCounter();
    unsigned incLegalCounter();

    ECSLChapter getChapter() const;
};

//******************************************************************************//
// CSLClass class                                                               //
//******************************************************************************//
class CSLClass {
  private:
    CSLChapterPoint                                     m_chapter;
    ECSLClass                                           m_cslClass;
    bool                                                m_isScopeHolder;
    CSLCmdPointVect                                     m_mandatoryCmds;
    CSLClassPointVect                                   m_mandatoryObjs;
    CSLClassPointVect                                   m_legalDecl;
    CSLClassPointVect                                   m_legalInst;
    CSLParamPointVectVect                               m_declParam;
    StringStringPair                                    m_specialDeclChars;
    unsigned                                            m_objCount;

  public:
    CSLClass(CSLChapterPoint cpt,
             ECSLClass cslClass,
             bool isScopeHolder,
             StringStringPair specialDeclChars = StringStringPair());

    CSLClass(const CSLClass& other,
             unsigned objCount = OBJ_COUNT_ZERO);

    ~CSLClass();

    void addMandatoryCmd(CSLCmdPoint cmd);
    void addMandatoryObj(CSLClassPoint obj);
    void addLegalDecl(CSLClassPoint cls);
    void addLegalInst(CSLClassPoint cls);
    void addDeclParamVect(CSLParamPointVect paramVect);

    unsigned incIllegalCounter();
    unsigned incLegalCounter();

    ECSLChapter getChapter() const;
    CSLChapterPoint getChapterPoint() const;
    bool isScopeHolder() const;
    bool isPlainDecl() const;
    ECSLClass getClass() const;
    CSLCmdPointVect getMandatoryCmds() const;
    CSLClassPointVect getMandatoryObjs() const;
    CSLClassPointVect getLegalDecl() const;
    CSLClassPoint getObjDecl(CSLClassPoint obj) const;
    CSLClassPointVect getLegalInst() const;
    CSLParamPointVectVect getParams() const;
    CSLParamPointVectVectPoint getParamsPoint() const;
    StringStringPair getSpecialDeclChars() const;
    unsigned getObjCount() const;

    bool isLegalDecl(ECSLClass obj) const;
    bool isLegalInst(ECSLClass obj) const;

    void print(ostream& output,
               ECSLClassStringMap nameBase,
               string alignment);

    void print(ostream& output,
               ECSLClassStringMap nameBase);
};

//******************************************************************************//
// CSLCmd class                                                                 //
//******************************************************************************//
class CSLCmd {
  private:
    ECSLCmdType                                         m_cmdType;
    ECSLClassVector                                     m_callerVect;
    CSLParamPointVect                                   m_paramVect;
    CSLCmdPointVect                                     m_preCmdVect;
    bool                                                m_canCallFromGlobalScope;
    bool                                                m_canCallFromInstance;
    bool                                                m_returnValue;

  public:
    CSLCmd(ECSLCmdType cmdType,
           bool canCallFromGlobalScope = true,
           bool canCallFromInstance = false,
           bool returnValue = false,
           CSLParamPointVect paramVect = CSLParamPointVect());

    CSLCmd(const CSLCmd& other);

    ~CSLCmd();

    void addParam(CSLParamPoint cslParam);
    void addParamVect(CSLParamPointVect paramVect);
    void addCaller(ECSLClass cslClass);
    void addPreCmd(CSLCmdPoint preCmd);
    void addPreCmdVect(CSLCmdPointVect preCmdVect);

    ECSLCmdType getCmdType() const;
    ECSLClassVector getCallerVect() const;
    CSLParamPointVect getParamVect() const;
    CSLCmdPointVect getPreCmdVect() const;
    bool getCanCallFromGlobalScope() const;
    bool getCanCallFromInstance() const;
    bool getReturnValue() const;

    bool isCaller(ECSLClass cls) const;
    bool operator==(const CSLCmd& other) const;

    void print(ostream& output, string alignment = ALIGN_NONE);
};

//******************************************************************************//
// CSLParam class                                                               //
//******************************************************************************//
class CSLParam {
  private:
    ECSLParamType                                       m_paramType;

  protected:
    CSLParam(ECSLParamType paramType);

  public:
    virtual ~CSLParam();

    bool isKeyWordParam() const;
    bool isObjDeclParam() const;
    bool isConstParam() const;

    ECSLParamType getParamType() const;

    virtual void print(ostream& output) = 0;
    virtual bool operator==(const CSLParam& other) const = 0;
    virtual bool operator!=(const CSLParam& other) const = 0;
};

//******************************************************************************//
// CSLEnumItem class                                                            //
//******************************************************************************//
class CSLEnumItem : public CSLParam {
  private:
    CSLClassPointVect                                   m_preDeclVect;

  public:
    CSLEnumItem(bool preDecl = false);
    ~CSLEnumItem();

    CSLClassPointVect getPreDeclVect() const;

    void print(ostream& output);
    bool operator==(const CSLParam& other) const;
    bool operator!=(const CSLParam& other) const;
};

//******************************************************************************//
// CSLObjDecl class                                                             //
//******************************************************************************//
class CSLObjDecl : public CSLParam {
  private:
    ECSLParamDecl                                       m_paramDecl;
    ECSLClass                                           m_objClass;
    CSLParamPointVect                                   m_objParamVect;
    string                                              m_suffix;

  public:
    CSLObjDecl(ECSLClass objClass,
               CSLParamPointVect objParamVect = CSLParamPointVect(),
               ECSLParamDecl paramDecl = PD_GLOBAL,
               string sufix = "");

    ~CSLObjDecl();

    ECSLClass getClass() const;
    CSLParamPointVect getParamVect() const;
    ECSLParamDecl getParamDecl() const;
    string getObjName(unsigned objCount) const;

    void print(ostream& output);

    void print(ostream& output,
               unsigned objCount);

    void print(ostream& output,
               unsigned objCount,
               string alignment);

    bool operator==(const CSLParam& other) const;
    bool operator!=(const CSLParam& other) const;
};

//******************************************************************************//
// CSLKeyWord class                                                             //
//******************************************************************************//
class CSLKeyWord : public CSLParam {
  private:
    string                                              m_keyWord;

  public:
    CSLKeyWord(string keyWord);
    ~CSLKeyWord();

    string getKeyWord() const;

    void print(ostream& output);
    bool operator==(const CSLParam& other) const;
    bool operator!=(const CSLParam& other) const;
};

//******************************************************************************//
// CSLConst class                                                               //
//******************************************************************************//
class CSLConst : public CSLParam {
  private:
    unsigned                                            m_const;

  public:
    CSLConst(unsigned constVal);
    ~CSLConst();

    unsigned getConst() const;

    void print(ostream& output);
    bool operator==(const CSLParam& other) const;
    bool operator!=(const CSLParam& other) const;
};


#endif //_CGEN_BASE_H_
